"""
takes templated file .xxx.src and produces .xxx file  where .xxx is
.i or .c or .h, using the following template rules

/**begin repeat  -- on a line by itself marks the start of a repeated code
                    segment
/**end repeat**/ -- on a line by itself marks it's end

After the /**begin repeat and before the */, all the named templates are placed
these should all have the same number of replacements

Repeat blocks can be nested, with each nested block labeled with its depth,
i.e.
/**begin repeat1
 *....
 */
/**end repeat1**/

When using nested loops, you can optionally exclude particular
combinations of the variables using (inside the comment portion of the inner loop):

 :exclude: var1=value1, var2=value2, ...

This will exclude the pattern where var1 is value1 and var2 is value2 when
the result is being generated.


In the main body each replace will use one entry from the list of named replacements

 Note that all #..# forms in a block must have the same number of
   comma-separated entries.

Example:

    An input file containing

        /**begin repeat
         * #a = 1,2,3#
         * #b = 1,2,3#
         */

        /**begin repeat1
         * #c = ted, jim#
         */
        @a@, @b@, @c@
        /**end repeat1**/

        /**end repeat**/

    produces

        line 1 "template.c.src"

        /*
         *********************************************************************
         **       This file was autogenerated from a template  DO NOT EDIT!!**
         **       Changes should be made to the original source (.src) file **
         *********************************************************************
         */

        #line 9
        1, 1, ted

        #line 9
        1, 1, jim

        #line 9
        2, 2, ted

        #line 9
        2, 2, jim

        #line 9
        3, 3, ted

        #line 9
        3, 3, jim

"""

__all__ = ['process_str', 'process_file']
import os
import sys
import re
global_names = {}
header = '\n/*\n *****************************************************************************\n **       This file was autogenerated from a template  DO NOT EDIT!!!!      **\n **       Changes should be made to the original source (.src) file         **\n *****************************************************************************\n */\n\n'

def parse_structure(astr, level):
    """
    The returned line number is from the beginning of the string, starting
    at zero. Returns an empty list if no loops found.

    """
    import custom_funtemplate
    return custom_funtemplate.rewrite_template('numpy.distutils.conv_template.parse_structure', 'parse_structure(astr, level)', {'astr': astr, 'level': level}, 1)

def paren_repl(obj):
    import custom_funtemplate
    return custom_funtemplate.rewrite_template('numpy.distutils.conv_template.paren_repl', 'paren_repl(obj)', {'obj': obj}, 1)
parenrep = re.compile('\\(([^)]*)\\)\\*(\\d+)')
plainrep = re.compile('([^*]+)\\*(\\d+)')

def parse_values(astr):
    import custom_funtemplate
    return custom_funtemplate.rewrite_template('numpy.distutils.conv_template.parse_values', 'parse_values(astr)', {'parenrep': parenrep, 'paren_repl': paren_repl, 'plainrep': plainrep, 'astr': astr}, 1)
stripast = re.compile('\\n\\s*\\*?')
named_re = re.compile('#\\s*(\\w*)\\s*=([^#]*)#')
exclude_vars_re = re.compile('(\\w*)=(\\w*)')
exclude_re = re.compile(':exclude:')

def parse_loop_header(loophead):
    """Find all named replacements in the header

    Returns a list of dictionaries, one for each loop iteration,
    where each key is a name to be substituted and the corresponding
    value is the replacement string.

    Also return a list of exclusions.  The exclusions are dictionaries
     of key value pairs. There can be more than one exclusion.
     [{'var1':'value1', 'var2', 'value2'[,...]}, ...]

    """
    import custom_funtemplate
    return custom_funtemplate.rewrite_template('numpy.distutils.conv_template.parse_loop_header', 'parse_loop_header(loophead)', {'stripast': stripast, 'named_re': named_re, 'parse_values': parse_values, 'exclude_re': exclude_re, 'exclude_vars_re': exclude_vars_re, 'loophead': loophead}, 1)
replace_re = re.compile('@(\\w+)@')

def parse_string(astr, env, level, line):
    import custom_funtemplate
    return custom_funtemplate.rewrite_template('numpy.distutils.conv_template.parse_string', 'parse_string(astr, env, level, line)', {'parse_structure': parse_structure, 'replace_re': replace_re, 'parse_loop_header': parse_loop_header, 'parse_string': parse_string, 'astr': astr, 'env': env, 'level': level, 'line': line}, 1)

def process_str(astr):
    import custom_funtemplate
    return custom_funtemplate.rewrite_template('numpy.distutils.conv_template.process_str', 'process_str(astr)', {'header': header, 'parse_string': parse_string, 'global_names': global_names, 'astr': astr}, 1)
include_src_re = re.compile('(\\n|\\A)#include\\s*[\'\\"](?P<name>[\\w\\d./\\\\]+[.]src)[\'\\"]', re.I)

def resolve_includes(source):
    import custom_funtemplate
    return custom_funtemplate.rewrite_template('numpy.distutils.conv_template.resolve_includes', 'resolve_includes(source)', {'os': os, 'include_src_re': include_src_re, 'resolve_includes': resolve_includes, 'source': source}, 1)

def process_file(source):
    import custom_funtemplate
    return custom_funtemplate.rewrite_template('numpy.distutils.conv_template.process_file', 'process_file(source)', {'resolve_includes': resolve_includes, 'os': os, 'process_str': process_str, 'source': source}, 1)

def unique_key(adict):
    import custom_funtemplate
    return custom_funtemplate.rewrite_template('numpy.distutils.conv_template.unique_key', 'unique_key(adict)', {'adict': adict}, 1)

def main():
    import custom_funtemplate
    custom_funtemplate.rewrite_template('numpy.distutils.conv_template.main', 'main()', {'sys': sys, 'os': os, 'process_str': process_str}, 0)
if __name__ == '__main__':
    main()

