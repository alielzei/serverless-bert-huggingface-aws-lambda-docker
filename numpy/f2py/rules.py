"""

Rules for building C/API module with f2py2e.

Here is a skeleton of a new wrapper function (13Dec2001):

wrapper_function(args)
  declarations
  get_python_arguments, say, `a' and `b'

  get_a_from_python
  if (successful) {

    get_b_from_python
    if (successful) {

      callfortran
      if (successful) {

        put_a_to_python
        if (successful) {

          put_b_to_python
          if (successful) {

            buildvalue = ...

          }

        }

      }

    }
    cleanup_b

  }
  cleanup_a

  return buildvalue

Copyright 1999,2000 Pearu Peterson all rights reserved,
Pearu Peterson <pearu@ioc.ee>
Permission to use, modify, and distribute this software is given under the
terms of the NumPy License.

NO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.
$Date: 2005/08/30 08:58:42 $
Pearu Peterson

"""

import os, sys
import time
import copy
from pathlib import Path
from . import __version__
from .auxfuncs import applyrules, debugcapi, dictappend, errmess, gentitle, getargs2, hascallstatement, hasexternals, hasinitvalue, hasnote, hasresultnote, isarray, isarrayofstrings, ischaracter, ischaracterarray, ischaracter_or_characterarray, iscomplex, iscomplexarray, iscomplexfunction, iscomplexfunction_warn, isdummyroutine, isexternal, isfunction, isfunction_wrap, isint1, isint1array, isintent_aux, isintent_c, isintent_callback, isintent_copy, isintent_hide, isintent_inout, isintent_nothide, isintent_out, isintent_overwrite, islogical, islong_complex, islong_double, islong_doublefunction, islong_long, islong_longfunction, ismoduleroutine, isoptional, isrequired, isscalar, issigned_long_longarray, isstring, isstringarray, isstringfunction, issubroutine, isattr_value, issubroutine_wrap, isthreadsafe, isunsigned, isunsigned_char, isunsigned_chararray, isunsigned_long_long, isunsigned_long_longarray, isunsigned_short, isunsigned_shortarray, l_and, l_not, l_or, outmess, replace, stripcomma, requiresf90wrapper
from . import capi_maps
from . import cfuncs
from . import common_rules
from . import use_rules
from . import f90mod_rules
from . import func2subr
f2py_version = __version__.version
numpy_version = __version__.version
options = {}
sepdict = {}
for k in ['decl', 'frompyobj', 'cleanupfrompyobj', 'topyarr', 'method', 'pyobjfrom', 'closepyobjfrom', 'freemem', 'userincludes', 'includes0', 'includes', 'typedefs', 'typedefs_generated', 'cppmacros', 'cfuncs', 'callbacks', 'latexdoc', 'restdoc', 'routine_defs', 'externroutines', 'initf2pywraphooks', 'commonhooks', 'initcommonhooks', 'f90modhooks', 'initf90modhooks']:
    sepdict[k] = '\n'
generationtime = int(os.environ.get('SOURCE_DATE_EPOCH', time.time()))
module_rules = {'modulebody': '/* File: #modulename#module.c\n * This file is auto-generated with f2py (version:#f2py_version#).\n * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition,\n * written by Pearu Peterson <pearu@cens.ioc.ee>.\n * Generation date: ' + time.asctime(time.gmtime(generationtime)) + '\n * Do not edit this file directly unless you know what you are doing!!!\n */\n\n#ifdef __cplusplus\nextern "C" {\n#endif\n\n#ifndef PY_SSIZE_T_CLEAN\n#define PY_SSIZE_T_CLEAN\n#endif /* PY_SSIZE_T_CLEAN */\n\n/* Unconditionally included */\n#include <Python.h>\n#include <numpy/npy_os.h>\n\n' + gentitle('See f2py2e/cfuncs.py: includes') + '\n#includes#\n#includes0#\n\n' + gentitle("See f2py2e/rules.py: mod_rules['modulebody']") + '\nstatic PyObject *#modulename#_error;\nstatic PyObject *#modulename#_module;\n\n' + gentitle('See f2py2e/cfuncs.py: typedefs') + '\n#typedefs#\n\n' + gentitle('See f2py2e/cfuncs.py: typedefs_generated') + '\n#typedefs_generated#\n\n' + gentitle('See f2py2e/cfuncs.py: cppmacros') + '\n#cppmacros#\n\n' + gentitle('See f2py2e/cfuncs.py: cfuncs') + '\n#cfuncs#\n\n' + gentitle('See f2py2e/cfuncs.py: userincludes') + '\n#userincludes#\n\n' + gentitle('See f2py2e/capi_rules.py: usercode') + '\n#usercode#\n\n/* See f2py2e/rules.py */\n#externroutines#\n\n' + gentitle('See f2py2e/capi_rules.py: usercode1') + '\n#usercode1#\n\n' + gentitle('See f2py2e/cb_rules.py: buildcallback') + '\n#callbacks#\n\n' + gentitle('See f2py2e/rules.py: buildapi') + '\n#body#\n\n' + gentitle('See f2py2e/f90mod_rules.py: buildhooks') + '\n#f90modhooks#\n\n' + gentitle("See f2py2e/rules.py: module_rules['modulebody']") + '\n\n' + gentitle('See f2py2e/common_rules.py: buildhooks') + '\n#commonhooks#\n\n' + gentitle('See f2py2e/rules.py') + '\n\nstatic FortranDataDef f2py_routine_defs[] = {\n#routine_defs#\n    {NULL}\n};\n\nstatic PyMethodDef f2py_module_methods[] = {\n#pymethoddef#\n    {NULL,NULL}\n};\n\nstatic struct PyModuleDef moduledef = {\n    PyModuleDef_HEAD_INIT,\n    "#modulename#",\n    NULL,\n    -1,\n    f2py_module_methods,\n    NULL,\n    NULL,\n    NULL,\n    NULL\n};\n\nPyMODINIT_FUNC PyInit_#modulename#(void) {\n    int i;\n    PyObject *m,*d, *s, *tmp;\n    m = #modulename#_module = PyModule_Create(&moduledef);\n    Py_SET_TYPE(&PyFortran_Type, &PyType_Type);\n    import_array();\n    if (PyErr_Occurred())\n        {PyErr_SetString(PyExc_ImportError, "can\'t initialize module #modulename# (failed to import numpy)"); return m;}\n    d = PyModule_GetDict(m);\n    s = PyUnicode_FromString("#f2py_version#");\n    PyDict_SetItemString(d, "__version__", s);\n    Py_DECREF(s);\n    s = PyUnicode_FromString(\n        "This module \'#modulename#\' is auto-generated with f2py (version:#f2py_version#).\\nFunctions:\\n"\n#docs#".");\n    PyDict_SetItemString(d, "__doc__", s);\n    Py_DECREF(s);\n    s = PyUnicode_FromString("' + numpy_version + '");\n    PyDict_SetItemString(d, "__f2py_numpy_version__", s);\n    Py_DECREF(s);\n    #modulename#_error = PyErr_NewException ("#modulename#.error", NULL, NULL);\n    /*\n     * Store the error object inside the dict, so that it could get deallocated.\n     * (in practice, this is a module, so it likely will not and cannot.)\n     */\n    PyDict_SetItemString(d, "_#modulename#_error", #modulename#_error);\n    Py_DECREF(#modulename#_error);\n    for(i=0;f2py_routine_defs[i].name!=NULL;i++) {\n        tmp = PyFortranObject_NewAsAttr(&f2py_routine_defs[i]);\n        PyDict_SetItemString(d, f2py_routine_defs[i].name, tmp);\n        Py_DECREF(tmp);\n    }\n#initf2pywraphooks#\n#initf90modhooks#\n#initcommonhooks#\n#interface_usercode#\n\n#ifdef F2PY_REPORT_ATEXIT\n    if (! PyErr_Occurred())\n        on_exit(f2py_report_on_exit,(void*)"#modulename#");\n#endif\n    return m;\n}\n#ifdef __cplusplus\n}\n#endif\n', 'separatorsfor': {'latexdoc': '\n\n', 'restdoc': '\n\n'}, 'latexdoc': ['\\section{Module \\texttt{#texmodulename#}}\n', '#modnote#\n', '#latexdoc#'], 'restdoc': ['Module #modulename#\n' + '=' * 80, '\n#restdoc#']}
defmod_rules = [{'body': '/*eof body*/', 'method': '/*eof method*/', 'externroutines': '/*eof externroutines*/', 'routine_defs': '/*eof routine_defs*/', 'initf90modhooks': '/*eof initf90modhooks*/', 'initf2pywraphooks': '/*eof initf2pywraphooks*/', 'initcommonhooks': '/*eof initcommonhooks*/', 'latexdoc': '', 'restdoc': '', 'modnote': {hasnote: '#note#', l_not(hasnote): ''}}]
routine_rules = {'separatorsfor': sepdict, 'body': '\n#begintitle#\nstatic char doc_#apiname#[] = "\\\n#docreturn##name#(#docsignatureshort#)\\n\\nWrapper for ``#name#``.\\\n\\n#docstrsigns#";\n/* #declfortranroutine# */\nstatic PyObject *#apiname#(const PyObject *capi_self,\n                           PyObject *capi_args,\n                           PyObject *capi_keywds,\n                           #functype# (*f2py_func)(#callprotoargument#)) {\n    PyObject * volatile capi_buildvalue = NULL;\n    volatile int f2py_success = 1;\n#decl#\n    static char *capi_kwlist[] = {#kwlist##kwlistopt##kwlistxa#NULL};\n#usercode#\n#routdebugenter#\n#ifdef F2PY_REPORT_ATEXIT\nf2py_start_clock();\n#endif\n    if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\\\n        "#argformat#|#keyformat##xaformat#:#pyname#",\\\n        capi_kwlist#args_capi##keys_capi##keys_xa#))\n        return NULL;\n#frompyobj#\n/*end of frompyobj*/\n#ifdef F2PY_REPORT_ATEXIT\nf2py_start_call_clock();\n#endif\n#callfortranroutine#\nif (PyErr_Occurred())\n  f2py_success = 0;\n#ifdef F2PY_REPORT_ATEXIT\nf2py_stop_call_clock();\n#endif\n/*end of callfortranroutine*/\n        if (f2py_success) {\n#pyobjfrom#\n/*end of pyobjfrom*/\n        CFUNCSMESS("Building return value.\\n");\n        capi_buildvalue = Py_BuildValue("#returnformat#"#return#);\n/*closepyobjfrom*/\n#closepyobjfrom#\n        } /*if (f2py_success) after callfortranroutine*/\n/*cleanupfrompyobj*/\n#cleanupfrompyobj#\n    if (capi_buildvalue == NULL) {\n#routdebugfailure#\n    } else {\n#routdebugleave#\n    }\n    CFUNCSMESS("Freeing memory.\\n");\n#freemem#\n#ifdef F2PY_REPORT_ATEXIT\nf2py_stop_clock();\n#endif\n    return capi_buildvalue;\n}\n#endtitle#\n', 'routine_defs': '#routine_def#', 'initf2pywraphooks': '#initf2pywraphook#', 'externroutines': '#declfortranroutine#', 'doc': '#docreturn##name#(#docsignature#)', 'docshort': '#docreturn##name#(#docsignatureshort#)', 'docs': '"    #docreturn##name#(#docsignature#)\\n"\n', 'need': ['arrayobject.h', 'CFUNCSMESS', 'MINMAX'], 'cppmacros': {debugcapi: '#define DEBUGCFUNCS'}, 'latexdoc': ['\\subsection{Wrapper function \\texttt{#texname#}}\n', '\n\\noindent{{}\\verb@#docreturn##name#@{}}\\texttt{(#latexdocsignatureshort#)}\n#routnote#\n\n#latexdocstrsigns#\n'], 'restdoc': ['Wrapped function ``#name#``\n' + '-' * 80]}
rout_rules = [{'separatorsfor': {'callfortranroutine': '\n', 'routdebugenter': '\n', 'decl': '\n', 'routdebugleave': '\n', 'routdebugfailure': '\n', 'setjmpbuf': ' || ', 'docstrreq': '\n', 'docstropt': '\n', 'docstrout': '\n', 'docstrcbs': '\n', 'docstrsigns': '\\n"\n"', 'latexdocstrsigns': '\n', 'latexdocstrreq': '\n', 'latexdocstropt': '\n', 'latexdocstrout': '\n', 'latexdocstrcbs': '\n'}, 'kwlist': '', 'kwlistopt': '', 'callfortran': '', 'callfortranappend': '', 'docsign': '', 'docsignopt': '', 'decl': '/*decl*/', 'freemem': '/*freemem*/', 'docsignshort': '', 'docsignoptshort': '', 'docstrsigns': '', 'latexdocstrsigns': '', 'docstrreq': '\\nParameters\\n----------', 'docstropt': '\\nOther Parameters\\n----------------', 'docstrout': '\\nReturns\\n-------', 'docstrcbs': '\\nNotes\\n-----\\nCall-back functions::\\n', 'latexdocstrreq': '\\noindent Required arguments:', 'latexdocstropt': '\\noindent Optional arguments:', 'latexdocstrout': '\\noindent Return objects:', 'latexdocstrcbs': '\\noindent Call-back functions:', 'args_capi': '', 'keys_capi': '', 'functype': '', 'frompyobj': '/*frompyobj*/', 'cleanupfrompyobj': ['/*end of cleanupfrompyobj*/'], 'pyobjfrom': '/*pyobjfrom*/', 'closepyobjfrom': ['/*end of closepyobjfrom*/'], 'topyarr': '/*topyarr*/', 'routdebugleave': '/*routdebugleave*/', 'routdebugenter': '/*routdebugenter*/', 'routdebugfailure': '/*routdebugfailure*/', 'callfortranroutine': '/*callfortranroutine*/', 'argformat': '', 'keyformat': '', 'need_cfuncs': '', 'docreturn': '', 'return': '', 'returnformat': '', 'rformat': '', 'kwlistxa': '', 'keys_xa': '', 'xaformat': '', 'docsignxa': '', 'docsignxashort': '', 'initf2pywraphook': '', 'routnote': {hasnote: '--- #note#', l_not(hasnote): ''}}, {'apiname': 'f2py_rout_#modulename#_#name#', 'pyname': '#modulename#.#name#', 'decl': '', '_check': l_not(ismoduleroutine)}, {'apiname': 'f2py_rout_#modulename#_#f90modulename#_#name#', 'pyname': '#modulename#.#f90modulename#.#name#', 'decl': '', '_check': ismoduleroutine}, {'functype': 'void', 'declfortranroutine': {l_and(l_not(l_or(ismoduleroutine, isintent_c)), l_not(isdummyroutine)): 'extern void #F_FUNC#(#fortranname#,#FORTRANNAME#)(#callprotoargument#);', l_and(l_not(ismoduleroutine), isintent_c, l_not(isdummyroutine)): 'extern void #fortranname#(#callprotoargument#);', ismoduleroutine: '', isdummyroutine: ''}, 'routine_def': {l_not(l_or(ismoduleroutine, isintent_c, isdummyroutine)): '    {"#name#",-1,{{-1}},0,0,(char *)  #F_FUNC#(#fortranname#,#FORTRANNAME#),  (f2py_init_func)#apiname#,doc_#apiname#},', l_and(l_not(ismoduleroutine), isintent_c, l_not(isdummyroutine)): '    {"#name#",-1,{{-1}},0,0,(char *)#fortranname#,  (f2py_init_func)#apiname#,doc_#apiname#},', l_and(l_not(ismoduleroutine), isdummyroutine): '    {"#name#",-1,{{-1}},0,0,NULL,  (f2py_init_func)#apiname#,doc_#apiname#},'}, 'need': {l_and(l_not(l_or(ismoduleroutine, isintent_c)), l_not(isdummyroutine)): 'F_FUNC'}, 'callfortranroutine': [{debugcapi: ['    fprintf(stderr,"debug-capi:Fortran subroutine `#fortranname#(#callfortran#)\'\\n");']}, {hasexternals: '        if (#setjmpbuf#) {\n            f2py_success = 0;\n        } else {'}, {isthreadsafe: '            Py_BEGIN_ALLOW_THREADS'}, {hascallstatement: '                #callstatement#;\n                /*(*f2py_func)(#callfortran#);*/'}, {l_not(l_or(hascallstatement, isdummyroutine)): '                (*f2py_func)(#callfortran#);'}, {isthreadsafe: '            Py_END_ALLOW_THREADS'}, {hasexternals: '        }'}], '_check': l_and(issubroutine, l_not(issubroutine_wrap))}, {'functype': 'void', 'declfortranroutine': {l_not(l_or(ismoduleroutine, isdummyroutine)): 'extern void #F_WRAPPEDFUNC#(#name_lower#,#NAME#)(#callprotoargument#);', isdummyroutine: ''}, 'routine_def': {l_not(l_or(ismoduleroutine, isdummyroutine)): '    {"#name#",-1,{{-1}},0,0,(char *)  #F_WRAPPEDFUNC#(#name_lower#,#NAME#),  (f2py_init_func)#apiname#,doc_#apiname#},', isdummyroutine: '    {"#name#",-1,{{-1}},0,0,NULL,  (f2py_init_func)#apiname#,doc_#apiname#},'}, 'initf2pywraphook': {l_not(l_or(ismoduleroutine, isdummyroutine)): '\n    {\n      extern #ctype# #F_FUNC#(#name_lower#,#NAME#)(void);\n      PyObject* o = PyDict_GetItemString(d,"#name#");\n      tmp = F2PyCapsule_FromVoidPtr((void*)#F_FUNC#(#name_lower#,#NAME#),NULL);\n      PyObject_SetAttrString(o,"_cpointer", tmp);\n      Py_DECREF(tmp);\n      s = PyUnicode_FromString("#name#");\n      PyObject_SetAttrString(o,"__name__", s);\n      Py_DECREF(s);\n    }\n    '}, 'need': {l_not(l_or(ismoduleroutine, isdummyroutine)): ['F_WRAPPEDFUNC', 'F_FUNC']}, 'callfortranroutine': [{debugcapi: ['    fprintf(stderr,"debug-capi:Fortran subroutine `f2pywrap#name_lower#(#callfortran#)\'\\n");']}, {hasexternals: '    if (#setjmpbuf#) {\n        f2py_success = 0;\n    } else {'}, {isthreadsafe: '    Py_BEGIN_ALLOW_THREADS'}, {l_not(l_or(hascallstatement, isdummyroutine)): '    (*f2py_func)(#callfortran#);'}, {hascallstatement: '    #callstatement#;\n    /*(*f2py_func)(#callfortran#);*/'}, {isthreadsafe: '    Py_END_ALLOW_THREADS'}, {hasexternals: '    }'}], '_check': isfunction_wrap}, {'functype': 'void', 'declfortranroutine': {l_not(l_or(ismoduleroutine, isdummyroutine)): 'extern void #F_WRAPPEDFUNC#(#name_lower#,#NAME#)(#callprotoargument#);', isdummyroutine: ''}, 'routine_def': {l_not(l_or(ismoduleroutine, isdummyroutine)): '    {"#name#",-1,{{-1}},0,0,(char *)  #F_WRAPPEDFUNC#(#name_lower#,#NAME#),  (f2py_init_func)#apiname#,doc_#apiname#},', isdummyroutine: '    {"#name#",-1,{{-1}},0,0,NULL,  (f2py_init_func)#apiname#,doc_#apiname#},'}, 'initf2pywraphook': {l_not(l_or(ismoduleroutine, isdummyroutine)): '\n    {\n      extern void #F_FUNC#(#name_lower#,#NAME#)(void);\n      PyObject* o = PyDict_GetItemString(d,"#name#");\n      tmp = F2PyCapsule_FromVoidPtr((void*)#F_FUNC#(#name_lower#,#NAME#),NULL);\n      PyObject_SetAttrString(o,"_cpointer", tmp);\n      Py_DECREF(tmp);\n      s = PyUnicode_FromString("#name#");\n      PyObject_SetAttrString(o,"__name__", s);\n      Py_DECREF(s);\n    }\n    '}, 'need': {l_not(l_or(ismoduleroutine, isdummyroutine)): ['F_WRAPPEDFUNC', 'F_FUNC']}, 'callfortranroutine': [{debugcapi: ['    fprintf(stderr,"debug-capi:Fortran subroutine `f2pywrap#name_lower#(#callfortran#)\'\\n");']}, {hasexternals: '    if (#setjmpbuf#) {\n        f2py_success = 0;\n    } else {'}, {isthreadsafe: '    Py_BEGIN_ALLOW_THREADS'}, {l_not(l_or(hascallstatement, isdummyroutine)): '    (*f2py_func)(#callfortran#);'}, {hascallstatement: '    #callstatement#;\n    /*(*f2py_func)(#callfortran#);*/'}, {isthreadsafe: '    Py_END_ALLOW_THREADS'}, {hasexternals: '    }'}], '_check': issubroutine_wrap}, {'functype': '#ctype#', 'docreturn': {l_not(isintent_hide): '#rname#,'}, 'docstrout': '#pydocsignout#', 'latexdocstrout': ['\\item[]{{}\\verb@#pydocsignout#@{}}', {hasresultnote: '--- #resultnote#'}], 'callfortranroutine': [{l_and(debugcapi, isstringfunction): '#ifdef USESCOMPAQFORTRAN\n    fprintf(stderr,"debug-capi:Fortran function #ctype# #fortranname#(#callcompaqfortran#)\\n");\n#else\n    fprintf(stderr,"debug-capi:Fortran function #ctype# #fortranname#(#callfortran#)\\n");\n#endif\n'}, {l_and(debugcapi, l_not(isstringfunction)): '    fprintf(stderr,"debug-capi:Fortran function #ctype# #fortranname#(#callfortran#)\\n");\n'}], '_check': l_and(isfunction, l_not(isfunction_wrap))}, {'declfortranroutine': {l_and(l_not(l_or(ismoduleroutine, isintent_c)), l_not(isdummyroutine)): 'extern #ctype# #F_FUNC#(#fortranname#,#FORTRANNAME#)(#callprotoargument#);', l_and(l_not(ismoduleroutine), isintent_c, l_not(isdummyroutine)): 'extern #ctype# #fortranname#(#callprotoargument#);', isdummyroutine: ''}, 'routine_def': {l_and(l_not(l_or(ismoduleroutine, isintent_c)), l_not(isdummyroutine)): '    {"#name#",-1,{{-1}},0,0,(char *)  #F_FUNC#(#fortranname#,#FORTRANNAME#),  (f2py_init_func)#apiname#,doc_#apiname#},', l_and(l_not(ismoduleroutine), isintent_c, l_not(isdummyroutine)): '    {"#name#",-1,{{-1}},0,0,(char *)#fortranname#,  (f2py_init_func)#apiname#,doc_#apiname#},', isdummyroutine: '    {"#name#",-1,{{-1}},0,0,NULL,(f2py_init_func)#apiname#,doc_#apiname#},'}, 'decl': [{iscomplexfunction_warn: '    #ctype# #name#_return_value={0,0};', l_not(iscomplexfunction): '    #ctype# #name#_return_value=0;'}, {iscomplexfunction: '    PyObject *#name#_return_value_capi = Py_None;'}], 'callfortranroutine': [{hasexternals: '    if (#setjmpbuf#) {\n        f2py_success = 0;\n    } else {'}, {isthreadsafe: '    Py_BEGIN_ALLOW_THREADS'}, {hascallstatement: '    #callstatement#;\n/*    #name#_return_value = (*f2py_func)(#callfortran#);*/\n'}, {l_not(l_or(hascallstatement, isdummyroutine)): '    #name#_return_value = (*f2py_func)(#callfortran#);'}, {isthreadsafe: '    Py_END_ALLOW_THREADS'}, {hasexternals: '    }'}, {l_and(debugcapi, iscomplexfunction): '    fprintf(stderr,"#routdebugshowvalue#\\n",#name#_return_value.r,#name#_return_value.i);'}, {l_and(debugcapi, l_not(iscomplexfunction)): '    fprintf(stderr,"#routdebugshowvalue#\\n",#name#_return_value);'}], 'pyobjfrom': {iscomplexfunction: '    #name#_return_value_capi = pyobj_from_#ctype#1(#name#_return_value);'}, 'need': [{l_not(isdummyroutine): 'F_FUNC'}, {iscomplexfunction: 'pyobj_from_#ctype#1'}, {islong_longfunction: 'long_long'}, {islong_doublefunction: 'long_double'}], 'returnformat': {l_not(isintent_hide): '#rformat#'}, 'return': {iscomplexfunction: ',#name#_return_value_capi', l_not(l_or(iscomplexfunction, isintent_hide)): ',#name#_return_value'}, '_check': l_and(isfunction, l_not(isstringfunction), l_not(isfunction_wrap))}, {'declfortranroutine': 'extern void #F_FUNC#(#fortranname#,#FORTRANNAME#)(#callprotoargument#);', 'routine_def': {l_not(l_or(ismoduleroutine, isintent_c)): '    {"#name#",-1,{{-1}},0,0,(char *)#F_FUNC#(#fortranname#,#FORTRANNAME#),(f2py_init_func)#apiname#,doc_#apiname#},', l_and(l_not(ismoduleroutine), isintent_c): '    {"#name#",-1,{{-1}},0,0,(char *)#fortranname#,(f2py_init_func)#apiname#,doc_#apiname#},'}, 'decl': ['    #ctype# #name#_return_value = NULL;', '    int #name#_return_value_len = 0;'], 'callfortran': '#name#_return_value,#name#_return_value_len,', 'callfortranroutine': ['    #name#_return_value_len = #rlength#;', '    if ((#name#_return_value = (string)malloc(' + '#name#_return_value_len+1) == NULL) {', '        PyErr_SetString(PyExc_MemoryError, "out of memory");', '        f2py_success = 0;', '    } else {', "        (#name#_return_value)[#name#_return_value_len] = '\\0';", '    }', '    if (f2py_success) {', {hasexternals: '        if (#setjmpbuf#) {\n            f2py_success = 0;\n        } else {'}, {isthreadsafe: '        Py_BEGIN_ALLOW_THREADS'}, '#ifdef USESCOMPAQFORTRAN\n        (*f2py_func)(#callcompaqfortran#);\n#else\n        (*f2py_func)(#callfortran#);\n#endif\n', {isthreadsafe: '        Py_END_ALLOW_THREADS'}, {hasexternals: '        }'}, {debugcapi: '        fprintf(stderr,"#routdebugshowvalue#\\n",#name#_return_value_len,#name#_return_value);'}, '    } /* if (f2py_success) after (string)malloc */'], 'returnformat': '#rformat#', 'return': ',#name#_return_value', 'freemem': '    STRINGFREE(#name#_return_value);', 'need': ['F_FUNC', '#ctype#', 'STRINGFREE'], '_check': l_and(isstringfunction, l_not(isfunction_wrap))}, {'routdebugenter': '    fprintf(stderr,"debug-capi:Python C/API function #modulename#.#name#(#docsignature#)\\n");', 'routdebugleave': '    fprintf(stderr,"debug-capi:Python C/API function #modulename#.#name#: successful.\\n");', 'routdebugfailure': '    fprintf(stderr,"debug-capi:Python C/API function #modulename#.#name#: failure.\\n");', '_check': debugcapi}]
typedef_need_dict = {islong_long: 'long_long', islong_double: 'long_double', islong_complex: 'complex_long_double', isunsigned_char: 'unsigned_char', isunsigned_short: 'unsigned_short', isunsigned: 'unsigned', isunsigned_long_long: 'unsigned_long_long', isunsigned_chararray: 'unsigned_char', isunsigned_shortarray: 'unsigned_short', isunsigned_long_longarray: 'unsigned_long_long', issigned_long_longarray: 'long_long', isint1: 'signed_char', ischaracter_or_characterarray: 'character'}
aux_rules = [{'separatorsfor': sepdict}, {'frompyobj': ['    /* Processing auxiliary variable #varname# */', {debugcapi: '    fprintf(stderr,"#vardebuginfo#\\n");'}], 'cleanupfrompyobj': '    /* End of cleaning variable #varname# */', 'need': typedef_need_dict}, {'decl': '    #ctype# #varname# = 0;', 'need': {hasinitvalue: 'math.h'}, 'frompyobj': {hasinitvalue: '    #varname# = #init#;'}, '_check': l_and(isscalar, l_not(iscomplex))}, {'return': ',#varname#', 'docstrout': '#pydocsignout#', 'docreturn': '#outvarname#,', 'returnformat': '#varrformat#', '_check': l_and(isscalar, l_not(iscomplex), isintent_out)}, {'decl': '    #ctype# #varname#;', 'frompyobj': {hasinitvalue: '    #varname#.r = #init.r#, #varname#.i = #init.i#;'}, '_check': iscomplex}, {'decl': ['    #ctype# #varname# = NULL;', '    int slen(#varname#);'], 'need': ['len..'], '_check': isstring}, {'decl': ['    #ctype# *#varname# = NULL;', '    npy_intp #varname#_Dims[#rank#] = {#rank*[-1]#};', '    const int #varname#_Rank = #rank#;'], 'need': ['len..', {hasinitvalue: 'forcomb'}, {hasinitvalue: 'CFUNCSMESS'}], '_check': isarray}, {'_check': l_and(isarray, l_not(iscomplexarray))}, {'_check': l_and(isarray, l_not(iscomplexarray), isintent_nothide)}, {'need': '#ctype#', '_check': isint1array, '_depend': ''}, {'need': '#ctype#', '_check': l_or(isunsigned_chararray, isunsigned_char), '_depend': ''}, {'need': '#ctype#', '_check': isunsigned_shortarray, '_depend': ''}, {'need': '#ctype#', '_check': isunsigned_long_longarray, '_depend': ''}, {'need': '#ctype#', '_check': iscomplexarray, '_depend': ''}, {'callfortranappend': {isarrayofstrings: 'flen(#varname#),'}, 'need': 'string', '_check': isstringarray}]
arg_rules = [{'separatorsfor': sepdict}, {'frompyobj': ['    /* Processing variable #varname# */', {debugcapi: '    fprintf(stderr,"#vardebuginfo#\\n");'}], 'cleanupfrompyobj': '    /* End of cleaning variable #varname# */', '_depend': '', 'need': typedef_need_dict}, {'docstropt': {l_and(isoptional, isintent_nothide): '#pydocsign#'}, 'docstrreq': {l_and(isrequired, isintent_nothide): '#pydocsign#'}, 'docstrout': {isintent_out: '#pydocsignout#'}, 'latexdocstropt': {l_and(isoptional, isintent_nothide): ['\\item[]{{}\\verb@#pydocsign#@{}}', {hasnote: '--- #note#'}]}, 'latexdocstrreq': {l_and(isrequired, isintent_nothide): ['\\item[]{{}\\verb@#pydocsign#@{}}', {hasnote: '--- #note#'}]}, 'latexdocstrout': {isintent_out: ['\\item[]{{}\\verb@#pydocsignout#@{}}', {l_and(hasnote, isintent_hide): '--- #note#', l_and(hasnote, isintent_nothide): '--- See above.'}]}, 'depend': ''}, {'kwlist': '"#varname#",', 'docsign': '#varname#,', '_check': l_and(isintent_nothide, l_not(isoptional))}, {'kwlistopt': '"#varname#",', 'docsignopt': '#varname#=#showinit#,', 'docsignoptshort': '#varname#,', '_check': l_and(isintent_nothide, isoptional)}, {'docreturn': '#outvarname#,', 'returnformat': '#varrformat#', '_check': isintent_out}, {'docsignxa': {isintent_nothide: '#varname#_extra_args=(),'}, 'docsignxashort': {isintent_nothide: '#varname#_extra_args,'}, 'docstropt': {isintent_nothide: '#varname#_extra_args : input tuple, optional\\n    Default: ()'}, 'docstrcbs': '#cbdocstr#', 'latexdocstrcbs': '\\item[] #cblatexdocstr#', 'latexdocstropt': {isintent_nothide: '\\item[]{{}\\verb@#varname#_extra_args := () input tuple@{}} --- Extra arguments for call-back function {{}\\verb@#varname#@{}}.'}, 'decl': ['    #cbname#_t #varname#_cb = { Py_None, NULL, 0 };', '    #cbname#_t *#varname#_cb_ptr = &#varname#_cb;', '    PyTupleObject *#varname#_xa_capi = NULL;', {l_not(isintent_callback): '    #cbname#_typedef #varname#_cptr;'}], 'kwlistxa': {isintent_nothide: '"#varname#_extra_args",'}, 'argformat': {isrequired: 'O'}, 'keyformat': {isoptional: 'O'}, 'xaformat': {isintent_nothide: 'O!'}, 'args_capi': {isrequired: ',&#varname#_cb.capi'}, 'keys_capi': {isoptional: ',&#varname#_cb.capi'}, 'keys_xa': ',&PyTuple_Type,&#varname#_xa_capi', 'setjmpbuf': '(setjmp(#varname#_cb.jmpbuf))', 'callfortran': {l_not(isintent_callback): '#varname#_cptr,'}, 'need': ['#cbname#', 'setjmp.h'], '_check': isexternal}, {'frompyobj': [{l_not(isintent_callback): 'if(F2PyCapsule_Check(#varname#_cb.capi)) {\n  #varname#_cptr = F2PyCapsule_AsVoidPtr(#varname#_cb.capi);\n} else {\n  #varname#_cptr = #cbname#;\n}\n'}, {isintent_callback: 'if (#varname#_cb.capi==Py_None) {\n  #varname#_cb.capi = PyObject_GetAttrString(#modulename#_module,"#varname#");\n  if (#varname#_cb.capi) {\n    if (#varname#_xa_capi==NULL) {\n      if (PyObject_HasAttrString(#modulename#_module,"#varname#_extra_args")) {\n        PyObject* capi_tmp = PyObject_GetAttrString(#modulename#_module,"#varname#_extra_args");\n        if (capi_tmp) {\n          #varname#_xa_capi = (PyTupleObject *)PySequence_Tuple(capi_tmp);\n          Py_DECREF(capi_tmp);\n        }\n        else {\n          #varname#_xa_capi = (PyTupleObject *)Py_BuildValue("()");\n        }\n        if (#varname#_xa_capi==NULL) {\n          PyErr_SetString(#modulename#_error,"Failed to convert #modulename#.#varname#_extra_args to tuple.\\n");\n          return NULL;\n        }\n      }\n    }\n  }\n  if (#varname#_cb.capi==NULL) {\n    PyErr_SetString(#modulename#_error,"Callback #varname# not defined (as an argument or module #modulename# attribute).\\n");\n    return NULL;\n  }\n}\n'}, '    if (create_cb_arglist(#varname#_cb.capi,#varname#_xa_capi,#maxnofargs#,#nofoptargs#,&#varname#_cb.nofargs,&#varname#_cb.args_capi,"failed in processing argument list for call-back #varname#.")) {\n', {debugcapi: ['        fprintf(stderr,"debug-capi:Assuming %d arguments; at most #maxnofargs#(-#nofoptargs#) is expected.\\n",#varname#_cb.nofargs);\n        CFUNCSMESSPY("for #varname#=",#varname#_cb.capi);', {l_not(isintent_callback): '        fprintf(stderr,"#vardebugshowvalue# (call-back in C).\\n",#cbname#);'}]}, '        CFUNCSMESS("Saving callback variables for `#varname#`.\\n");\n        #varname#_cb_ptr = swap_active_#cbname#(#varname#_cb_ptr);'], 'cleanupfrompyobj': '        CFUNCSMESS("Restoring callback variables for `#varname#`.\\n");\n        #varname#_cb_ptr = swap_active_#cbname#(#varname#_cb_ptr);\n        Py_DECREF(#varname#_cb.args_capi);\n    }', 'need': ['SWAP', 'create_cb_arglist'], '_check': isexternal, '_depend': ''}, {'decl': '    #ctype# #varname# = 0;', 'pyobjfrom': {debugcapi: '    fprintf(stderr,"#vardebugshowvalue#\\n",#varname#);'}, 'callfortran': {l_or(isintent_c, isattr_value): '#varname#,', l_not(l_or(isintent_c, isattr_value)): '&#varname#,'}, 'return': {isintent_out: ',#varname#'}, '_check': l_and(isscalar, l_not(iscomplex))}, {'need': {hasinitvalue: 'math.h'}, '_check': l_and(isscalar, l_not(iscomplex))}, {'decl': '    PyObject *#varname#_capi = Py_None;', 'argformat': {isrequired: 'O'}, 'keyformat': {isoptional: 'O'}, 'args_capi': {isrequired: ',&#varname#_capi'}, 'keys_capi': {isoptional: ',&#varname#_capi'}, 'pyobjfrom': {isintent_inout: '    f2py_success = try_pyarr_from_#ctype#(#varname#_capi,&#varname#);\n    if (f2py_success) {'}, 'closepyobjfrom': {isintent_inout: '    } /*if (f2py_success) of #varname# pyobjfrom*/'}, 'need': {isintent_inout: 'try_pyarr_from_#ctype#'}, '_check': l_and(isscalar, l_not(iscomplex), l_not(isstring), isintent_nothide)}, {'frompyobj': [{hasinitvalue: '    if (#varname#_capi == Py_None) #varname# = #init#; else', '_depend': ''}, {l_and(isoptional, l_not(hasinitvalue)): '    if (#varname#_capi != Py_None)', '_depend': ''}, {l_not(islogical): '        f2py_success = #ctype#_from_pyobj(&#varname#,#varname#_capi,"#pyname#() #nth# (#varname#) can\'t be converted to #ctype#");\n    if (f2py_success) {'}, {islogical: '        #varname# = (#ctype#)PyObject_IsTrue(#varname#_capi);\n        f2py_success = 1;\n    if (f2py_success) {'}], 'cleanupfrompyobj': '    } /*if (f2py_success) of #varname#*/', 'need': {l_not(islogical): '#ctype#_from_pyobj'}, '_check': l_and(isscalar, l_not(iscomplex), isintent_nothide), '_depend': ''}, {'frompyobj': {hasinitvalue: '    #varname# = #init#;'}, 'need': typedef_need_dict, '_check': l_and(isscalar, l_not(iscomplex), isintent_hide), '_depend': ''}, {'frompyobj': {debugcapi: '    fprintf(stderr,"#vardebugshowvalue#\\n",#varname#);'}, '_check': l_and(isscalar, l_not(iscomplex)), '_depend': ''}, {'decl': '    #ctype# #varname#;', 'callfortran': {isintent_c: '#varname#,', l_not(isintent_c): '&#varname#,'}, 'pyobjfrom': {debugcapi: '    fprintf(stderr,"#vardebugshowvalue#\\n",#varname#.r,#varname#.i);'}, 'return': {isintent_out: ',#varname#_capi'}, '_check': iscomplex}, {'decl': '    PyObject *#varname#_capi = Py_None;', 'argformat': {isrequired: 'O'}, 'keyformat': {isoptional: 'O'}, 'args_capi': {isrequired: ',&#varname#_capi'}, 'keys_capi': {isoptional: ',&#varname#_capi'}, 'need': {isintent_inout: 'try_pyarr_from_#ctype#'}, 'pyobjfrom': {isintent_inout: '        f2py_success = try_pyarr_from_#ctype#(#varname#_capi,&#varname#);\n        if (f2py_success) {'}, 'closepyobjfrom': {isintent_inout: '        } /*if (f2py_success) of #varname# pyobjfrom*/'}, '_check': l_and(iscomplex, isintent_nothide)}, {'frompyobj': [{hasinitvalue: '    if (#varname#_capi==Py_None) {#varname#.r = #init.r#, #varname#.i = #init.i#;} else'}, {l_and(isoptional, l_not(hasinitvalue)): '    if (#varname#_capi != Py_None)'}, '        f2py_success = #ctype#_from_pyobj(&#varname#,#varname#_capi,"#pyname#() #nth# (#varname#) can\'t be converted to #ctype#");\n    if (f2py_success) {'], 'cleanupfrompyobj': '    }  /*if (f2py_success) of #varname# frompyobj*/', 'need': ['#ctype#_from_pyobj'], '_check': l_and(iscomplex, isintent_nothide), '_depend': ''}, {'decl': {isintent_out: '    PyObject *#varname#_capi = Py_None;'}, '_check': l_and(iscomplex, isintent_hide)}, {'frompyobj': {hasinitvalue: '    #varname#.r = #init.r#, #varname#.i = #init.i#;'}, '_check': l_and(iscomplex, isintent_hide), '_depend': ''}, {'pyobjfrom': {isintent_out: '    #varname#_capi = pyobj_from_#ctype#1(#varname#);'}, 'need': ['pyobj_from_#ctype#1'], '_check': iscomplex}, {'frompyobj': {debugcapi: '    fprintf(stderr,"#vardebugshowvalue#\\n",#varname#.r,#varname#.i);'}, '_check': iscomplex, '_depend': ''}, {'decl': ['    #ctype# #varname# = NULL;', '    int slen(#varname#);', '    PyObject *#varname#_capi = Py_None;'], 'callfortran': '#varname#,', 'callfortranappend': 'slen(#varname#),', 'pyobjfrom': [{debugcapi: '    fprintf(stderr,"#vardebugshowvalue#\\n",slen(#varname#),#varname#);'}, {l_and(isintent_out, l_not(isintent_c)): "        STRINGPADN(#varname#, slen(#varname#), ' ', '\\0');"}], 'return': {isintent_out: ',#varname#'}, 'need': ['len..', {l_and(isintent_out, l_not(isintent_c)): 'STRINGPADN'}], '_check': isstring}, {'frompyobj': ['    slen(#varname#) = #elsize#;\n    f2py_success = #ctype#_from_pyobj(&#varname#,&slen(#varname#),#init#,#varname#_capi,"#ctype#_from_pyobj failed in converting #nth#`#varname#\' of #pyname# to C #ctype#");\n    if (f2py_success) {', {l_not(isintent_c): "        STRINGPADN(#varname#, slen(#varname#), '\\0', ' ');"}], 'cleanupfrompyobj': '        STRINGFREE(#varname#);\n    }  /*if (f2py_success) of #varname#*/', 'need': ['#ctype#_from_pyobj', 'len..', 'STRINGFREE', {l_not(isintent_c): 'STRINGPADN'}], '_check': isstring, '_depend': ''}, {'argformat': {isrequired: 'O'}, 'keyformat': {isoptional: 'O'}, 'args_capi': {isrequired: ',&#varname#_capi'}, 'keys_capi': {isoptional: ',&#varname#_capi'}, 'pyobjfrom': [{l_and(isintent_inout, l_not(isintent_c)): "        STRINGPADN(#varname#, slen(#varname#), ' ', '\\0');"}, {isintent_inout: '    f2py_success = try_pyarr_from_#ctype#(#varname#_capi, #varname#,\n                                          slen(#varname#));\n    if (f2py_success) {'}], 'closepyobjfrom': {isintent_inout: '    } /*if (f2py_success) of #varname# pyobjfrom*/'}, 'need': {isintent_inout: 'try_pyarr_from_#ctype#', l_and(isintent_inout, l_not(isintent_c)): 'STRINGPADN'}, '_check': l_and(isstring, isintent_nothide)}, {'_check': l_and(isstring, isintent_hide)}, {'frompyobj': {debugcapi: '    fprintf(stderr,"#vardebugshowvalue#\\n",slen(#varname#),#varname#);'}, '_check': isstring, '_depend': ''}, {'decl': ['    #ctype# *#varname# = NULL;', '    npy_intp #varname#_Dims[#rank#] = {#rank*[-1]#};', '    const int #varname#_Rank = #rank#;', '    PyArrayObject *capi_#varname#_as_array = NULL;', '    int capi_#varname#_intent = 0;', {isstringarray: '    int slen(#varname#) = 0;'}], 'callfortran': '#varname#,', 'callfortranappend': {isstringarray: 'slen(#varname#),'}, 'return': {isintent_out: ',capi_#varname#_as_array'}, 'need': 'len..', '_check': isarray}, {'decl': '    int capi_overwrite_#varname# = 1;', 'kwlistxa': '"overwrite_#varname#",', 'xaformat': 'i', 'keys_xa': ',&capi_overwrite_#varname#', 'docsignxa': 'overwrite_#varname#=1,', 'docsignxashort': 'overwrite_#varname#,', 'docstropt': 'overwrite_#varname# : input int, optional\\n    Default: 1', '_check': l_and(isarray, isintent_overwrite)}, {'frompyobj': '    capi_#varname#_intent |= (capi_overwrite_#varname#?0:F2PY_INTENT_COPY);', '_check': l_and(isarray, isintent_overwrite), '_depend': ''}, {'decl': '    int capi_overwrite_#varname# = 0;', 'kwlistxa': '"overwrite_#varname#",', 'xaformat': 'i', 'keys_xa': ',&capi_overwrite_#varname#', 'docsignxa': 'overwrite_#varname#=0,', 'docsignxashort': 'overwrite_#varname#,', 'docstropt': 'overwrite_#varname# : input int, optional\\n    Default: 0', '_check': l_and(isarray, isintent_copy)}, {'frompyobj': '    capi_#varname#_intent |= (capi_overwrite_#varname#?0:F2PY_INTENT_COPY);', '_check': l_and(isarray, isintent_copy), '_depend': ''}, {'need': [{hasinitvalue: 'forcomb'}, {hasinitvalue: 'CFUNCSMESS'}], '_check': isarray, '_depend': ''}, {'decl': '    PyObject *#varname#_capi = Py_None;', 'argformat': {isrequired: 'O'}, 'keyformat': {isoptional: 'O'}, 'args_capi': {isrequired: ',&#varname#_capi'}, 'keys_capi': {isoptional: ',&#varname#_capi'}, '_check': l_and(isarray, isintent_nothide)}, {'frompyobj': ['    #setdims#;', '    capi_#varname#_intent |= #intent#;', '    const char * capi_errmess = "#modulename#.#pyname#: failed to create array from the #nth# `#varname#`";', {isintent_hide: '    capi_#varname#_as_array = ndarray_from_pyobj(  #atype#,#elsize#,#varname#_Dims,#varname#_Rank,  capi_#varname#_intent,Py_None,capi_errmess);'}, {isintent_nothide: '    capi_#varname#_as_array = ndarray_from_pyobj(  #atype#,#elsize#,#varname#_Dims,#varname#_Rank,  capi_#varname#_intent,#varname#_capi,capi_errmess);'}, '    if (capi_#varname#_as_array == NULL) {\n        PyObject* capi_err = PyErr_Occurred();\n        if (capi_err == NULL) {\n            capi_err = #modulename#_error;\n            PyErr_SetString(capi_err, capi_errmess);\n        }\n    } else {\n        #varname# = (#ctype# *)(PyArray_DATA(capi_#varname#_as_array));\n', {isstringarray: '    slen(#varname#) = f2py_itemsize(#varname#);'}, {hasinitvalue: [{isintent_nothide: '    if (#varname#_capi == Py_None) {'}, {isintent_hide: '    {'}, {iscomplexarray: '        #ctype# capi_c;'}, '        int *_i,capi_i=0;\n        CFUNCSMESS("#name#: Initializing #varname#=#init#\\n");\n        if (initforcomb(PyArray_DIMS(capi_#varname#_as_array),\n                        PyArray_NDIM(capi_#varname#_as_array),1)) {\n            while ((_i = nextforcomb()))\n                #varname#[capi_i++] = #init#; /* fortran way */\n        } else {\n            PyObject *exc, *val, *tb;\n            PyErr_Fetch(&exc, &val, &tb);\n            PyErr_SetString(exc ? exc : #modulename#_error,\n                "Initialization of #nth# #varname# failed (initforcomb).");\n            npy_PyErr_ChainExceptionsCause(exc, val, tb);\n            f2py_success = 0;\n        }\n    }\n    if (f2py_success) {']}], 'cleanupfrompyobj': ['    }  /* if (capi_#varname#_as_array == NULL) ... else of #varname# */', {l_not(l_or(isintent_out, isintent_hide)): '    if((PyObject *)capi_#varname#_as_array!=#varname#_capi) {\n        Py_XDECREF(capi_#varname#_as_array); }'}, {l_and(isintent_hide, l_not(isintent_out)): '        Py_XDECREF(capi_#varname#_as_array);'}, {hasinitvalue: '    }  /*if (f2py_success) of #varname# init*/'}], '_check': isarray, '_depend': ''}, {'_check': l_and(isarray, l_not(iscomplexarray))}, {'_check': l_and(isarray, l_not(iscomplexarray), isintent_nothide)}, {'need': '#ctype#', '_check': isint1array, '_depend': ''}, {'need': '#ctype#', '_check': isunsigned_chararray, '_depend': ''}, {'need': '#ctype#', '_check': isunsigned_shortarray, '_depend': ''}, {'need': '#ctype#', '_check': isunsigned_long_longarray, '_depend': ''}, {'need': '#ctype#', '_check': iscomplexarray, '_depend': ''}, {'need': 'string', '_check': ischaracter}, {'need': 'string', '_check': ischaracterarray}, {'callfortranappend': {isarrayofstrings: 'flen(#varname#),'}, 'need': 'string', '_check': isstringarray}]
check_rules = [{'frompyobj': {debugcapi: '    fprintf(stderr,"debug-capi:Checking `#check#\'\\n");'}, 'need': 'len..'}, {'frompyobj': '    CHECKSCALAR(#check#,"#check#","#nth# #varname#","#varshowvalue#",#varname#) {', 'cleanupfrompyobj': '    } /*CHECKSCALAR(#check#)*/', 'need': 'CHECKSCALAR', '_check': l_and(isscalar, l_not(iscomplex)), '_break': ''}, {'frompyobj': '    CHECKSTRING(#check#,"#check#","#nth# #varname#","#varshowvalue#",#varname#) {', 'cleanupfrompyobj': '    } /*CHECKSTRING(#check#)*/', 'need': 'CHECKSTRING', '_check': isstring, '_break': ''}, {'need': 'CHECKARRAY', 'frompyobj': '    CHECKARRAY(#check#,"#check#","#nth# #varname#") {', 'cleanupfrompyobj': '    } /*CHECKARRAY(#check#)*/', '_check': isarray, '_break': ''}, {'need': 'CHECKGENERIC', 'frompyobj': '    CHECKGENERIC(#check#,"#check#","#nth# #varname#") {', 'cleanupfrompyobj': '    } /*CHECKGENERIC(#check#)*/'}]

def buildmodule(m, um):
    """
    Return
    """
    import custom_funtemplate
    return custom_funtemplate.rewrite_template('numpy.f2py.rules.buildmodule', 'buildmodule(m, um)', {'outmess': outmess, 'defmod_rules': defmod_rules, 'capi_maps': capi_maps, 'dictappend': dictappend, 'f2py_version': f2py_version, 'errmess': errmess, 'sys': sys, 'copy': copy, 'requiresf90wrapper': requiresf90wrapper, 'options': options, 'Path': Path, 'buildapi': buildapi, 'applyrules': applyrules, 'common_rules': common_rules, 'f90mod_rules': f90mod_rules, 'use_rules': use_rules, 'cfuncs': cfuncs, 'typedef_need_dict': typedef_need_dict, 'module_rules': module_rules, 'os': os, 'm': m, 'um': um}, 1)
stnd = {1: 'st', 2: 'nd', 3: 'rd', 4: 'th', 5: 'th', 6: 'th', 7: 'th', 8: 'th', 9: 'th', 0: 'th'}

def buildapi(rout):
    import custom_funtemplate
    return custom_funtemplate.rewrite_template('numpy.f2py.rules.buildapi', 'buildapi(rout)', {'func2subr': func2subr, 'getargs2': getargs2, 'capi_maps': capi_maps, 'ismoduleroutine': ismoduleroutine, 'outmess': outmess, 'dictappend': dictappend, 'rout_rules': rout_rules, 'applyrules': applyrules, 'isintent_aux': isintent_aux, 'aux_rules': aux_rules, 'arg_rules': arg_rules, 'isintent_hide': isintent_hide, 'isoptional': isoptional, 'stnd': stnd, 'check_rules': check_rules, 'stripcomma': stripcomma, 'routine_rules': routine_rules, 'rout': rout}, 2)

