"""Adds docstrings to Tensor functions"""

import torch._C
from torch._C import _add_docstr as add_docstr
from ._torch_docs import parse_kwargs

def add_docstr_all(method, docstr):
    add_docstr(getattr(torch._C._TensorBase, method), docstr)
common_args = parse_kwargs('\n    memory_format (:class:`torch.memory_format`, optional): the desired memory format of\n        returned Tensor. Default: ``torch.preserve_format``.\n')
new_common_args = parse_kwargs('\n    size (int...): a list, tuple, or :class:`torch.Size` of integers defining the\n        shape of the output tensor.\n    dtype (:class:`torch.dtype`, optional): the desired type of returned tensor.\n        Default: if None, same :class:`torch.dtype` as this tensor.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if None, same :class:`torch.device` as this tensor.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    pin_memory (bool, optional): If set, returned tensor would be allocated in\n        the pinned memory. Works only for CPU tensors. Default: ``False``.\n')
add_docstr_all('new_tensor', "\nnew_tensor(data, dtype=None, device=None, requires_grad=False) -> Tensor\n\nReturns a new Tensor with :attr:`data` as the tensor data.\nBy default, the returned Tensor has the same :class:`torch.dtype` and\n:class:`torch.device` as this tensor.\n\n.. warning::\n\n    :func:`new_tensor` always copies :attr:`data`. If you have a Tensor\n    ``data`` and want to avoid a copy, use :func:`torch.Tensor.requires_grad_`\n    or :func:`torch.Tensor.detach`.\n    If you have a numpy array and want to avoid a copy, use\n    :func:`torch.from_numpy`.\n\n.. warning::\n\n    When data is a tensor `x`, :func:`new_tensor()` reads out 'the data' from whatever it is passed,\n    and constructs a leaf variable. Therefore ``tensor.new_tensor(x)`` is equivalent to ``x.clone().detach()``\n    and ``tensor.new_tensor(x, requires_grad=True)`` is equivalent to ``x.clone().detach().requires_grad_(True)``.\n    The equivalents using ``clone()`` and ``detach()`` are recommended.\n\nArgs:\n    data (array_like): The returned Tensor copies :attr:`data`.\n    {dtype}\n    {device}\n    {requires_grad}\n\nExample::\n\n    >>> tensor = torch.ones((2,), dtype=torch.int8)\n    >>> data = [[0, 1], [2, 3]]\n    >>> tensor.new_tensor(data)\n    tensor([[ 0,  1],\n            [ 2,  3]], dtype=torch.int8)\n\n".format(**new_common_args))
add_docstr_all('new_full', '\nnew_full(size, fill_value, dtype=None, device=None, requires_grad=False) -> Tensor\n\nReturns a Tensor of size :attr:`size` filled with :attr:`fill_value`.\nBy default, the returned Tensor has the same :class:`torch.dtype` and\n:class:`torch.device` as this tensor.\n\nArgs:\n    fill_value (scalar): the number to fill the output tensor with.\n    {dtype}\n    {device}\n    {requires_grad}\n\nExample::\n\n    >>> tensor = torch.ones((2,), dtype=torch.float64)\n    >>> tensor.new_full((3, 4), 3.141592)\n    tensor([[ 3.1416,  3.1416,  3.1416,  3.1416],\n            [ 3.1416,  3.1416,  3.1416,  3.1416],\n            [ 3.1416,  3.1416,  3.1416,  3.1416]], dtype=torch.float64)\n\n'.format(**new_common_args))
add_docstr_all('new_empty', '\nnew_empty(size, dtype=None, device=None, requires_grad=False) -> Tensor\n\nReturns a Tensor of size :attr:`size` filled with uninitialized data.\nBy default, the returned Tensor has the same :class:`torch.dtype` and\n:class:`torch.device` as this tensor.\n\nArgs:\n    {dtype}\n    {device}\n    {requires_grad}\n\nExample::\n\n    >>> tensor = torch.ones(())\n    >>> tensor.new_empty((2, 3))\n    tensor([[ 5.8182e-18,  4.5765e-41, -1.0545e+30],\n            [ 3.0949e-41,  4.4842e-44,  0.0000e+00]])\n\n'.format(**new_common_args))
add_docstr_all('new_ones', '\nnew_ones(size, dtype=None, device=None, requires_grad=False) -> Tensor\n\nReturns a Tensor of size :attr:`size` filled with ``1``.\nBy default, the returned Tensor has the same :class:`torch.dtype` and\n:class:`torch.device` as this tensor.\n\nArgs:\n    size (int...): a list, tuple, or :class:`torch.Size` of integers defining the\n        shape of the output tensor.\n    {dtype}\n    {device}\n    {requires_grad}\n\nExample::\n\n    >>> tensor = torch.tensor((), dtype=torch.int32)\n    >>> tensor.new_ones((2, 3))\n    tensor([[ 1,  1,  1],\n            [ 1,  1,  1]], dtype=torch.int32)\n\n'.format(**new_common_args))
add_docstr_all('new_zeros', '\nnew_zeros(size, dtype=None, device=None, requires_grad=False) -> Tensor\n\nReturns a Tensor of size :attr:`size` filled with ``0``.\nBy default, the returned Tensor has the same :class:`torch.dtype` and\n:class:`torch.device` as this tensor.\n\nArgs:\n    size (int...): a list, tuple, or :class:`torch.Size` of integers defining the\n        shape of the output tensor.\n    {dtype}\n    {device}\n    {requires_grad}\n\nExample::\n\n    >>> tensor = torch.tensor((), dtype=torch.float64)\n    >>> tensor.new_zeros((2, 3))\n    tensor([[ 0.,  0.,  0.],\n            [ 0.,  0.,  0.]], dtype=torch.float64)\n\n'.format(**new_common_args))
add_docstr_all('abs', '\nabs() -> Tensor\n\nSee :func:`torch.abs`\n')
add_docstr_all('abs_', '\nabs_() -> Tensor\n\nIn-place version of :meth:`~Tensor.abs`\n')
add_docstr_all('acos', '\nacos() -> Tensor\n\nSee :func:`torch.acos`\n')
add_docstr_all('acos_', '\nacos_() -> Tensor\n\nIn-place version of :meth:`~Tensor.acos`\n')
add_docstr_all('add', '\nadd(other, *, alpha=1) -> Tensor\n\nAdd a scalar or tensor to :attr:`self` tensor. If both :attr:`alpha`\nand :attr:`other` are specified, each element of :attr:`other` is scaled by\n:attr:`alpha` before being used.\n\nWhen :attr:`other` is a tensor, the shape of :attr:`other` must be\n:ref:`broadcastable <broadcasting-semantics>` with the shape of the underlying\ntensor\n\nSee :func:`torch.add`\n')
add_docstr_all('add_', '\nadd_(other, *, alpha=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.add`\n')
add_docstr_all('addbmm', '\naddbmm(batch1, batch2, *, beta=1, alpha=1) -> Tensor\n\nSee :func:`torch.addbmm`\n')
add_docstr_all('addbmm_', '\naddbmm_(batch1, batch2, *, beta=1, alpha=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.addbmm`\n')
add_docstr_all('addcdiv', '\naddcdiv(tensor1, tensor2, *, value=1) -> Tensor\n\nSee :func:`torch.addcdiv`\n')
add_docstr_all('addcdiv_', '\naddcdiv_(tensor1, tensor2, *, value=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.addcdiv`\n')
add_docstr_all('addcmul', '\naddcmul(tensor1, tensor2, *, value=1) -> Tensor\n\nSee :func:`torch.addcmul`\n')
add_docstr_all('addcmul_', '\naddcmul_(tensor1, tensor2, *, value=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.addcmul`\n')
add_docstr_all('addmm', '\naddmm(mat1, mat2, *, beta=1, alpha=1) -> Tensor\n\nSee :func:`torch.addmm`\n')
add_docstr_all('addmm_', '\naddmm_(mat1, mat2, *, beta=1, alpha=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.addmm`\n')
add_docstr_all('addmv', '\naddmv(mat, vec, *, beta=1, alpha=1) -> Tensor\n\nSee :func:`torch.addmv`\n')
add_docstr_all('addmv_', '\naddmv_(mat, vec, *, beta=1, alpha=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.addmv`\n')
add_docstr_all('addr', '\naddr(vec1, vec2, *, beta=1, alpha=1) -> Tensor\n\nSee :func:`torch.addr`\n')
add_docstr_all('addr_', '\naddr_(vec1, vec2, *, beta=1, alpha=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.addr`\n')
add_docstr_all('align_as', "\nalign_as(other) -> Tensor\n\nPermutes the dimensions of the :attr:`self` tensor to match the dimension order\nin the :attr:`other` tensor, adding size-one dims for any new names.\n\nThis operation is useful for explicit broadcasting by names (see examples).\n\nAll of the dims of :attr:`self` must be named in order to use this method.\nThe resulting tensor is a view on the original tensor.\n\nAll dimension names of :attr:`self` must be present in ``other.names``.\n:attr:`other` may contain named dimensions that are not in ``self.names``;\nthe output tensor has a size-one dimension for each of those new names.\n\nTo align a tensor to a specific order, use :meth:`~Tensor.align_to`.\n\nExamples::\n\n    # Example 1: Applying a mask\n    >>> mask = torch.randint(2, [127, 128], dtype=torch.bool).refine_names('W', 'H')\n    >>> imgs = torch.randn(32, 128, 127, 3, names=('N', 'H', 'W', 'C'))\n    >>> imgs.masked_fill_(mask.align_as(imgs), 0)\n\n\n    # Example 2: Applying a per-channel-scale\n    def scale_channels(input, scale):\n        scale = scale.refine_names('C')\n        return input * scale.align_as(input)\n\n    >>> num_channels = 3\n    >>> scale = torch.randn(num_channels, names=('C',))\n    >>> imgs = torch.rand(32, 128, 128, num_channels, names=('N', 'H', 'W', 'C'))\n    >>> more_imgs = torch.rand(32, num_channels, 128, 128, names=('N', 'C', 'H', 'W'))\n    >>> videos = torch.randn(3, num_channels, 128, 128, 128, names=('N', 'C', 'H', 'W', 'D'))\n\n    # scale_channels is agnostic to the dimension order of the input\n    >>> scale_channels(imgs, scale)\n    >>> scale_channels(more_imgs, scale)\n    >>> scale_channels(videos, scale)\n\n.. warning::\n    The named tensor API is experimental and subject to change.\n\n")
add_docstr_all('all', '\n.. function:: all() -> bool\n\nReturns True if all elements in the tensor are True, False otherwise.\n\nExample::\n\n    >>> a = torch.rand(1, 2).bool()\n    >>> a\n    tensor([[False, True]], dtype=torch.bool)\n    >>> a.all()\n    tensor(False, dtype=torch.bool)\n\n.. function:: all(dim, keepdim=False, out=None) -> Tensor\n\nReturns True if all elements in each row of the tensor in the given\ndimension :attr:`dim` are True, False otherwise.\n\nIf :attr:`keepdim` is ``True``, the output tensor is of the same size as\n:attr:`input` except in the dimension :attr:`dim` where it is of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting\nin the output tensor having 1 fewer dimension than :attr:`input`.\n\nArgs:\n    dim (int): the dimension to reduce\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not\n    out (Tensor, optional): the output tensor\n\nExample::\n\n    >>> a = torch.rand(4, 2).bool()\n    >>> a\n    tensor([[True, True],\n            [True, False],\n            [True, True],\n            [True, True]], dtype=torch.bool)\n    >>> a.all(dim=1)\n    tensor([ True, False,  True,  True], dtype=torch.bool)\n    >>> a.all(dim=0)\n    tensor([ True, False], dtype=torch.bool)\n')
add_docstr_all('allclose', '\nallclose(other, rtol=1e-05, atol=1e-08, equal_nan=False) -> Tensor\n\nSee :func:`torch.allclose`\n')
add_docstr_all('angle', '\nangle() -> Tensor\n\nSee :func:`torch.angle`\n')
add_docstr_all('any', '\n.. function:: any() -> bool\n\nReturns True if any elements in the tensor are True, False otherwise.\n\nExample::\n\n    >>> a = torch.rand(1, 2).bool()\n    >>> a\n    tensor([[False, True]], dtype=torch.bool)\n    >>> a.any()\n    tensor(True, dtype=torch.bool)\n\n.. function:: any(dim, keepdim=False, out=None) -> Tensor\n\nReturns True if any elements in each row of the tensor in the given\ndimension :attr:`dim` are True, False otherwise.\n\nIf :attr:`keepdim` is ``True``, the output tensor is of the same size as\n:attr:`input` except in the dimension :attr:`dim` where it is of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting\nin the output tensor having 1 fewer dimension than :attr:`input`.\n\nArgs:\n    dim (int): the dimension to reduce\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not\n    out (Tensor, optional): the output tensor\n\nExample::\n\n    >>> a = torch.randn(4, 2) < 0\n    >>> a\n    tensor([[ True,  True],\n            [False,  True],\n            [ True,  True],\n            [False, False]])\n    >>> a.any(1)\n    tensor([ True,  True,  True, False])\n    >>> a.any(0)\n    tensor([True, True])\n')
add_docstr_all('apply_', '\napply_(callable) -> Tensor\n\nApplies the function :attr:`callable` to each element in the tensor, replacing\neach element with the value returned by :attr:`callable`.\n\n.. note::\n\n    This function only works with CPU tensors and should not be used in code\n    sections that require high performance.\n')
add_docstr_all('asin', '\nasin() -> Tensor\n\nSee :func:`torch.asin`\n')
add_docstr_all('asin_', '\nasin_() -> Tensor\n\nIn-place version of :meth:`~Tensor.asin`\n')
add_docstr_all('as_strided', '\nas_strided(size, stride, storage_offset=0) -> Tensor\n\nSee :func:`torch.as_strided`\n')
add_docstr_all('atan', '\natan() -> Tensor\n\nSee :func:`torch.atan`\n')
add_docstr_all('atan2', '\natan2(other) -> Tensor\n\nSee :func:`torch.atan2`\n')
add_docstr_all('atan2_', '\natan2_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.atan2`\n')
add_docstr_all('atan_', '\natan_() -> Tensor\n\nIn-place version of :meth:`~Tensor.atan`\n')
add_docstr_all('baddbmm', '\nbaddbmm(batch1, batch2, *, beta=1, alpha=1) -> Tensor\n\nSee :func:`torch.baddbmm`\n')
add_docstr_all('baddbmm_', '\nbaddbmm_(batch1, batch2, *, beta=1, alpha=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.baddbmm`\n')
add_docstr_all('bernoulli', '\nbernoulli(*, generator=None) -> Tensor\n\nReturns a result tensor where each :math:`\\texttt{result[i]}` is independently\nsampled from :math:`\\text{Bernoulli}(\\texttt{self[i]})`. :attr:`self` must have\nfloating point ``dtype``, and the result will have the same ``dtype``.\n\nSee :func:`torch.bernoulli`\n')
add_docstr_all('bernoulli_', '\n.. function:: bernoulli_(p=0.5, *, generator=None) -> Tensor\n\n    Fills each location of :attr:`self` with an independent sample from\n    :math:`\\text{Bernoulli}(\\texttt{p})`. :attr:`self` can have integral\n    ``dtype``.\n\n.. function:: bernoulli_(p_tensor, *, generator=None) -> Tensor\n\n    :attr:`p_tensor` should be a tensor containing probabilities to be used for\n    drawing the binary random number.\n\n    The :math:`\\text{i}^{th}` element of :attr:`self` tensor will be set to a\n    value sampled from :math:`\\text{Bernoulli}(\\texttt{p\\_tensor[i]})`.\n\n    :attr:`self` can have integral ``dtype``, but :attr:`p_tensor` must have\n    floating point ``dtype``.\n\nSee also :meth:`~Tensor.bernoulli` and :func:`torch.bernoulli`\n')
add_docstr_all('bincount', '\nbincount(weights=None, minlength=0) -> Tensor\n\nSee :func:`torch.bincount`\n')
add_docstr_all('bitwise_not', '\nbitwise_not() -> Tensor\n\nSee :func:`torch.bitwise_not`\n')
add_docstr_all('bitwise_not_', '\nbitwise_not_() -> Tensor\n\nIn-place version of :meth:`~Tensor.bitwise_not`\n')
add_docstr_all('bitwise_and', '\nbitwise_and() -> Tensor\n\nSee :func:`torch.bitwise_and`\n')
add_docstr_all('bitwise_and_', '\nbitwise_and_() -> Tensor\n\nIn-place version of :meth:`~Tensor.bitwise_and`\n')
add_docstr_all('bitwise_or', '\nbitwise_or() -> Tensor\n\nSee :func:`torch.bitwise_or`\n')
add_docstr_all('bitwise_or_', '\nbitwise_or_() -> Tensor\n\nIn-place version of :meth:`~Tensor.bitwise_or`\n')
add_docstr_all('bitwise_xor', '\nbitwise_xor() -> Tensor\n\nSee :func:`torch.bitwise_xor`\n')
add_docstr_all('bitwise_xor_', '\nbitwise_xor_() -> Tensor\n\nIn-place version of :meth:`~Tensor.bitwise_xor`\n')
add_docstr_all('logical_and', '\nlogical_and() -> Tensor\n\nSee :func:`torch.logical_and`\n')
add_docstr_all('logical_and_', '\nlogical_and_() -> Tensor\n\nIn-place version of :meth:`~Tensor.logical_and`\n')
add_docstr_all('logical_not', '\nlogical_not() -> Tensor\n\nSee :func:`torch.logical_not`\n')
add_docstr_all('logical_not_', '\nlogical_not_() -> Tensor\n\nIn-place version of :meth:`~Tensor.logical_not`\n')
add_docstr_all('logical_or', '\nlogical_or() -> Tensor\n\nSee :func:`torch.logical_or`\n')
add_docstr_all('logical_or_', '\nlogical_or_() -> Tensor\n\nIn-place version of :meth:`~Tensor.logical_or`\n')
add_docstr_all('logical_xor', '\nlogical_xor() -> Tensor\n\nSee :func:`torch.logical_xor`\n')
add_docstr_all('logical_xor_', '\nlogical_xor_() -> Tensor\n\nIn-place version of :meth:`~Tensor.logical_xor`\n')
add_docstr_all('bmm', '\nbmm(batch2) -> Tensor\n\nSee :func:`torch.bmm`\n')
add_docstr_all('cauchy_', '\ncauchy_(median=0, sigma=1, *, generator=None) -> Tensor\n\nFills the tensor with numbers drawn from the Cauchy distribution:\n\n.. math::\n\n    f(x) = \\dfrac{1}{\\pi} \\dfrac{\\sigma}{(x - \\text{median})^2 + \\sigma^2}\n')
add_docstr_all('ceil', '\nceil() -> Tensor\n\nSee :func:`torch.ceil`\n')
add_docstr_all('ceil_', '\nceil_() -> Tensor\n\nIn-place version of :meth:`~Tensor.ceil`\n')
add_docstr_all('cholesky', '\ncholesky(upper=False) -> Tensor\n\nSee :func:`torch.cholesky`\n')
add_docstr_all('cholesky_solve', '\ncholesky_solve(input2, upper=False) -> Tensor\n\nSee :func:`torch.cholesky_solve`\n')
add_docstr_all('cholesky_inverse', '\ncholesky_inverse(upper=False) -> Tensor\n\nSee :func:`torch.cholesky_inverse`\n')
add_docstr_all('clamp', '\nclamp(min, max) -> Tensor\n\nSee :func:`torch.clamp`\n')
add_docstr_all('clamp_', '\nclamp_(min, max) -> Tensor\n\nIn-place version of :meth:`~Tensor.clamp`\n')
add_docstr_all('clone', '\nclone(memory_format=torch.preserve_format) -> Tensor\n\nReturns a copy of the :attr:`self` tensor. The copy has the same size and data\ntype as :attr:`self`.\n\n.. note::\n\n    Unlike `copy_()`, this function is recorded in the computation graph. Gradients\n    propagating to the cloned tensor will propagate to the original tensor.\n\nArgs:\n    {memory_format}\n'.format(**common_args))
add_docstr_all('contiguous', '\ncontiguous(memory_format=torch.contiguous_format) -> Tensor\n\nReturns a contiguous in memory tensor containing the same data as :attr:`self` tensor. If\n:attr:`self` tensor is already in the specified memory format, this function returns the\n:attr:`self` tensor.\n\nArgs:\n    memory_format (:class:`torch.memory_format`, optional): the desired memory format of\n        returned Tensor. Default: ``torch.contiguous_format``.\n')
add_docstr_all('copy_', '\ncopy_(src, non_blocking=False) -> Tensor\n\nCopies the elements from :attr:`src` into :attr:`self` tensor and returns\n:attr:`self`.\n\nThe :attr:`src` tensor must be :ref:`broadcastable <broadcasting-semantics>`\nwith the :attr:`self` tensor. It may be of a different data type or reside on a\ndifferent device.\n\nArgs:\n    src (Tensor): the source tensor to copy from\n    non_blocking (bool): if ``True`` and this copy is between CPU and GPU,\n        the copy may occur asynchronously with respect to the host. For other\n        cases, this argument has no effect.\n')
add_docstr_all('conj', '\nconj() -> Tensor\n\nSee :func:`torch.conj`\n')
add_docstr_all('cos', '\ncos() -> Tensor\n\nSee :func:`torch.cos`\n')
add_docstr_all('cos_', '\ncos_() -> Tensor\n\nIn-place version of :meth:`~Tensor.cos`\n')
add_docstr_all('cosh', '\ncosh() -> Tensor\n\nSee :func:`torch.cosh`\n')
add_docstr_all('cosh_', '\ncosh_() -> Tensor\n\nIn-place version of :meth:`~Tensor.cosh`\n')
add_docstr_all('cpu', '\ncpu(memory_format=torch.preserve_format) -> Tensor\n\nReturns a copy of this object in CPU memory.\n\nIf this object is already in CPU memory and on the correct device,\nthen no copy is performed and the original object is returned.\n\nArgs:\n    {memory_format}\n\n'.format(**common_args))
add_docstr_all('cross', '\ncross(other, dim=-1) -> Tensor\n\nSee :func:`torch.cross`\n')
add_docstr_all('cuda', '\ncuda(device=None, non_blocking=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns a copy of this object in CUDA memory.\n\nIf this object is already in CUDA memory and on the correct device,\nthen no copy is performed and the original object is returned.\n\nArgs:\n    device (:class:`torch.device`): The destination GPU device.\n        Defaults to the current CUDA device.\n    non_blocking (bool): If ``True`` and the source is in pinned memory,\n        the copy will be asynchronous with respect to the host.\n        Otherwise, the argument has no effect. Default: ``False``.\n    {memory_format}\n'.format(**common_args))
add_docstr_all('cummax', '\ncummax(dim) -> (Tensor, Tensor)\n\nSee :func:`torch.cummax`\n')
add_docstr_all('cummin', '\ncummin(dim) -> (Tensor, Tensor)\n\nSee :func:`torch.cummin`\n')
add_docstr_all('cumprod', '\ncumprod(dim, dtype=None) -> Tensor\n\nSee :func:`torch.cumprod`\n')
add_docstr_all('cumsum', '\ncumsum(dim, dtype=None) -> Tensor\n\nSee :func:`torch.cumsum`\n')
add_docstr_all('data_ptr', '\ndata_ptr() -> int\n\nReturns the address of the first element of :attr:`self` tensor.\n')
add_docstr_all('dequantize', '\ndequantize() -> Tensor\n\nGiven a quantized Tensor, dequantize it and return the dequantized float Tensor.\n')
add_docstr_all('dense_dim', '\ndense_dim() -> int\n\nIf :attr:`self` is a sparse COO tensor (i.e., with ``torch.sparse_coo`` layout),\nthis returns the number of dense dimensions. Otherwise, this throws an error.\n\nSee also :meth:`Tensor.sparse_dim`.\n')
add_docstr_all('diag', '\ndiag(diagonal=0) -> Tensor\n\nSee :func:`torch.diag`\n')
add_docstr_all('diag_embed', '\ndiag_embed(offset=0, dim1=-2, dim2=-1) -> Tensor\n\nSee :func:`torch.diag_embed`\n')
add_docstr_all('diagflat', '\ndiagflat(offset=0) -> Tensor\n\nSee :func:`torch.diagflat`\n')
add_docstr_all('diagonal', '\ndiagonal(offset=0, dim1=0, dim2=1) -> Tensor\n\nSee :func:`torch.diagonal`\n')
add_docstr_all('fill_diagonal_', "\nfill_diagonal_(fill_value, wrap=False) -> Tensor\n\nFill the main diagonal of a tensor that has at least 2-dimensions.\nWhen dims>2, all dimensions of input must be of equal length.\nThis function modifies the input tensor in-place, and returns the input tensor.\n\nArguments:\n    fill_value (Scalar): the fill value\n    wrap (bool): the diagonal 'wrapped' after N columns for tall matrices.\n\nExample::\n\n    >>> a = torch.zeros(3, 3)\n    >>> a.fill_diagonal_(5)\n    tensor([[5., 0., 0.],\n            [0., 5., 0.],\n            [0., 0., 5.]])\n    >>> b = torch.zeros(7, 3)\n    >>> b.fill_diagonal_(5)\n    tensor([[5., 0., 0.],\n            [0., 5., 0.],\n            [0., 0., 5.],\n            [0., 0., 0.],\n            [0., 0., 0.],\n            [0., 0., 0.],\n            [0., 0., 0.]])\n    >>> c = torch.zeros(7, 3)\n    >>> c.fill_diagonal_(5, wrap=True)\n    tensor([[5., 0., 0.],\n            [0., 5., 0.],\n            [0., 0., 5.],\n            [0., 0., 0.],\n            [5., 0., 0.],\n            [0., 5., 0.],\n            [0., 0., 5.]])\n\n")
add_docstr_all('floor_divide', '\nfloor_divide(value) -> Tensor\n\nSee :func:`torch.floor_divide`\n')
add_docstr_all('floor_divide_', '\nfloor_divide_(value) -> Tensor\n\nIn-place version of :meth:`~Tensor.floor_divide`\n')
add_docstr_all('digamma', '\ndigamma() -> Tensor\n\nSee :func:`torch.digamma`\n')
add_docstr_all('digamma_', '\ndigamma_() -> Tensor\n\nIn-place version of :meth:`~Tensor.digamma`\n')
add_docstr_all('dim', '\ndim() -> int\n\nReturns the number of dimensions of :attr:`self` tensor.\n')
add_docstr_all('dist', '\ndist(other, p=2) -> Tensor\n\nSee :func:`torch.dist`\n')
add_docstr_all('div', '\ndiv(value) -> Tensor\n\nSee :func:`torch.div`\n')
add_docstr_all('div_', '\ndiv_(value) -> Tensor\n\nIn-place version of :meth:`~Tensor.div`\n')
add_docstr_all('dot', '\ndot(tensor2) -> Tensor\n\nSee :func:`torch.dot`\n')
add_docstr_all('eig', '\neig(eigenvectors=False) -> (Tensor, Tensor)\n\nSee :func:`torch.eig`\n')
add_docstr_all('element_size', '\nelement_size() -> int\n\nReturns the size in bytes of an individual element.\n\nExample::\n\n    >>> torch.tensor([]).element_size()\n    4\n    >>> torch.tensor([], dtype=torch.uint8).element_size()\n    1\n\n')
add_docstr_all('eq', '\neq(other) -> Tensor\n\nSee :func:`torch.eq`\n')
add_docstr_all('eq_', '\neq_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.eq`\n')
add_docstr_all('equal', '\nequal(other) -> bool\n\nSee :func:`torch.equal`\n')
add_docstr_all('erf', '\nerf() -> Tensor\n\nSee :func:`torch.erf`\n')
add_docstr_all('erf_', '\nerf_() -> Tensor\n\nIn-place version of :meth:`~Tensor.erf`\n')
add_docstr_all('erfc', '\nerfc() -> Tensor\n\nSee :func:`torch.erfc`\n')
add_docstr_all('erfc_', '\nerfc_() -> Tensor\n\nIn-place version of :meth:`~Tensor.erfc`\n')
add_docstr_all('erfinv', '\nerfinv() -> Tensor\n\nSee :func:`torch.erfinv`\n')
add_docstr_all('erfinv_', '\nerfinv_() -> Tensor\n\nIn-place version of :meth:`~Tensor.erfinv`\n')
add_docstr_all('exp', '\nexp() -> Tensor\n\nSee :func:`torch.exp`\n')
add_docstr_all('exp_', '\nexp_() -> Tensor\n\nIn-place version of :meth:`~Tensor.exp`\n')
add_docstr_all('expm1', '\nexpm1() -> Tensor\n\nSee :func:`torch.expm1`\n')
add_docstr_all('expm1_', '\nexpm1_() -> Tensor\n\nIn-place version of :meth:`~Tensor.expm1`\n')
add_docstr_all('exponential_', '\nexponential_(lambd=1, *, generator=None) -> Tensor\n\nFills :attr:`self` tensor with elements drawn from the exponential distribution:\n\n.. math::\n\n    f(x) = \\lambda e^{-\\lambda x}\n')
add_docstr_all('fill_', '\nfill_(value) -> Tensor\n\nFills :attr:`self` tensor with the specified value.\n')
add_docstr_all('floor', '\nfloor() -> Tensor\n\nSee :func:`torch.floor`\n')
add_docstr_all('flip', '\nflip(dims) -> Tensor\n\nSee :func:`torch.flip`\n')
add_docstr_all('roll', '\nroll(shifts, dims) -> Tensor\n\nSee :func:`torch.roll`\n')
add_docstr_all('floor_', '\nfloor_() -> Tensor\n\nIn-place version of :meth:`~Tensor.floor`\n')
add_docstr_all('fmod', '\nfmod(divisor) -> Tensor\n\nSee :func:`torch.fmod`\n')
add_docstr_all('fmod_', '\nfmod_(divisor) -> Tensor\n\nIn-place version of :meth:`~Tensor.fmod`\n')
add_docstr_all('frac', '\nfrac() -> Tensor\n\nSee :func:`torch.frac`\n')
add_docstr_all('frac_', '\nfrac_() -> Tensor\n\nIn-place version of :meth:`~Tensor.frac`\n')
add_docstr_all('flatten', '\nflatten(input, start_dim=0, end_dim=-1) -> Tensor\n\nsee :func:`torch.flatten`\n')
add_docstr_all('gather', '\ngather(dim, index) -> Tensor\n\nSee :func:`torch.gather`\n')
add_docstr_all('ge', '\nge(other) -> Tensor\n\nSee :func:`torch.ge`\n')
add_docstr_all('ge_', '\nge_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.ge`\n')
add_docstr_all('geometric_', '\ngeometric_(p, *, generator=None) -> Tensor\n\nFills :attr:`self` tensor with elements drawn from the geometric distribution:\n\n.. math::\n\n    f(X=k) = p^{k - 1} (1 - p)\n\n')
add_docstr_all('geqrf', '\ngeqrf() -> (Tensor, Tensor)\n\nSee :func:`torch.geqrf`\n')
add_docstr_all('ger', '\nger(vec2) -> Tensor\n\nSee :func:`torch.ger`\n')
add_docstr_all('indices', '\nindices() -> Tensor\n\nIf :attr:`self` is a sparse COO tensor (i.e., with ``torch.sparse_coo`` layout),\nthis returns a view of the contained indices tensor. Otherwise, this throws an\nerror.\n\nSee also :meth:`Tensor.values`.\n\n.. note::\n  This method can only be called on a coalesced sparse tensor. See\n  :meth:`Tensor.coalesce` for details.\n')
add_docstr_all('get_device', "\nget_device() -> Device ordinal (Integer)\n\nFor CUDA tensors, this function returns the device ordinal of the GPU on which the tensor resides.\nFor CPU tensors, an error is thrown.\n\nExample::\n\n    >>> x = torch.randn(3, 4, 5, device='cuda:0')\n    >>> x.get_device()\n    0\n    >>> x.cpu().get_device()  # RuntimeError: get_device is not implemented for type torch.FloatTensor\n")
add_docstr_all('values', '\nvalues() -> Tensor\n\nIf :attr:`self` is a sparse COO tensor (i.e., with ``torch.sparse_coo`` layout),\nthis returns a view of the contained values tensor. Otherwise, this throws an\nerror.\n\nSee also :meth:`Tensor.indices`.\n\n.. note::\n  This method can only be called on a coalesced sparse tensor. See\n  :meth:`Tensor.coalesce` for details.\n')
add_docstr_all('gt', '\ngt(other) -> Tensor\n\nSee :func:`torch.gt`\n')
add_docstr_all('gt_', '\ngt_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.gt`\n')
add_docstr_all('has_names', "\nIs ``True`` if any of this tensor's dimensions are named. Otherwise, is ``False``.\n")
add_docstr_all('hardshrink', '\nhardshrink(lambd=0.5) -> Tensor\n\nSee :func:`torch.nn.functional.hardshrink`\n')
add_docstr_all('histc', '\nhistc(bins=100, min=0, max=0) -> Tensor\n\nSee :func:`torch.histc`\n')
add_docstr_all('index_add_', '\nindex_add_(dim, index, tensor) -> Tensor\n\nAccumulate the elements of :attr:`tensor` into the :attr:`self` tensor by adding\nto the indices in the order given in :attr:`index`. For example, if ``dim == 0``\nand ``index[i] == j``, then the ``i``\\ th row of :attr:`tensor` is added to the\n``j``\\ th row of :attr:`self`.\n\nThe :attr:`dim`\\ th dimension of :attr:`tensor` must have the same size as the\nlength of :attr:`index` (which must be a vector), and all other dimensions must\nmatch :attr:`self`, or an error will be raised.\n\n.. include:: cuda_deterministic.rst\n\nArgs:\n    dim (int): dimension along which to index\n    index (LongTensor): indices of :attr:`tensor` to select from\n    tensor (Tensor): the tensor containing values to add\n\nExample::\n\n    >>> x = torch.ones(5, 3)\n    >>> t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)\n    >>> index = torch.tensor([0, 4, 2])\n    >>> x.index_add_(0, index, t)\n    tensor([[  2.,   3.,   4.],\n            [  1.,   1.,   1.],\n            [  8.,   9.,  10.],\n            [  1.,   1.,   1.],\n            [  5.,   6.,   7.]])\n')
add_docstr_all('index_copy_', '\nindex_copy_(dim, index, tensor) -> Tensor\n\nCopies the elements of :attr:`tensor` into the :attr:`self` tensor by selecting\nthe indices in the order given in :attr:`index`. For example, if ``dim == 0``\nand ``index[i] == j``, then the ``i``\\ th row of :attr:`tensor` is copied to the\n``j``\\ th row of :attr:`self`.\n\nThe :attr:`dim`\\ th dimension of :attr:`tensor` must have the same size as the\nlength of :attr:`index` (which must be a vector), and all other dimensions must\nmatch :attr:`self`, or an error will be raised.\n\nArgs:\n    dim (int): dimension along which to index\n    index (LongTensor): indices of :attr:`tensor` to select from\n    tensor (Tensor): the tensor containing values to copy\n\nExample::\n\n    >>> x = torch.zeros(5, 3)\n    >>> t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)\n    >>> index = torch.tensor([0, 4, 2])\n    >>> x.index_copy_(0, index, t)\n    tensor([[ 1.,  2.,  3.],\n            [ 0.,  0.,  0.],\n            [ 7.,  8.,  9.],\n            [ 0.,  0.,  0.],\n            [ 4.,  5.,  6.]])\n')
add_docstr_all('index_fill_', '\nindex_fill_(dim, index, val) -> Tensor\n\nFills the elements of the :attr:`self` tensor with value :attr:`val` by\nselecting the indices in the order given in :attr:`index`.\n\nArgs:\n    dim (int): dimension along which to index\n    index (LongTensor): indices of :attr:`self` tensor to fill in\n    val (float): the value to fill with\n\nExample::\n    >>> x = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)\n    >>> index = torch.tensor([0, 2])\n    >>> x.index_fill_(1, index, -1)\n    tensor([[-1.,  2., -1.],\n            [-1.,  5., -1.],\n            [-1.,  8., -1.]])\n')
add_docstr_all('index_put_', '\nindex_put_(indices, value, accumulate=False) -> Tensor\n\nPuts values from the tensor :attr:`value` into the tensor :attr:`self` using\nthe indices specified in :attr:`indices` (which is a tuple of Tensors). The\nexpression ``tensor.index_put_(indices, value)`` is equivalent to\n``tensor[indices] = value``. Returns :attr:`self`.\n\nIf :attr:`accumulate` is ``True``, the elements in :attr:`value` are added to\n:attr:`self`. If accumulate is ``False``, the behavior is undefined if indices\ncontain duplicate elements.\n\nArgs:\n    indices (tuple of LongTensor): tensors used to index into `self`.\n    value (Tensor): tensor of same dtype as `self`.\n    accumulate (bool): whether to accumulate into self\n')
add_docstr_all('index_put', '\nindex_put(indices, value, accumulate=False) -> Tensor\n\nOut-place version of :meth:`~Tensor.index_put_`\n')
add_docstr_all('index_select', '\nindex_select(dim, index) -> Tensor\n\nSee :func:`torch.index_select`\n')
add_docstr_all('sparse_mask', '\nsparse_mask(input, mask) -> Tensor\n\nReturns a new SparseTensor with values from Tensor :attr:`input` filtered\nby indices of :attr:`mask` and values are ignored. :attr:`input` and :attr:`mask`\nmust have the same shape.\n\nArgs:\n    input (Tensor): an input Tensor\n    mask (SparseTensor): a SparseTensor which we filter :attr:`input` based on its indices\n\nExample::\n\n    >>> nnz = 5\n    >>> dims = [5, 5, 2, 2]\n    >>> I = torch.cat([torch.randint(0, dims[0], size=(nnz,)),\n                       torch.randint(0, dims[1], size=(nnz,))], 0).reshape(2, nnz)\n    >>> V = torch.randn(nnz, dims[2], dims[3])\n    >>> size = torch.Size(dims)\n    >>> S = torch.sparse_coo_tensor(I, V, size).coalesce()\n    >>> D = torch.randn(dims)\n    >>> D.sparse_mask(S)\n    tensor(indices=tensor([[0, 0, 0, 2],\n                           [0, 1, 4, 3]]),\n           values=tensor([[[ 1.6550,  0.2397],\n                           [-0.1611, -0.0779]],\n\n                          [[ 0.2326, -1.0558],\n                           [ 1.4711,  1.9678]],\n\n                          [[-0.5138, -0.0411],\n                           [ 1.9417,  0.5158]],\n\n                          [[ 0.0793,  0.0036],\n                           [-0.2569, -0.1055]]]),\n           size=(5, 5, 2, 2), nnz=4, layout=torch.sparse_coo)\n')
add_docstr_all('inverse', '\ninverse() -> Tensor\n\nSee :func:`torch.inverse`\n')
add_docstr_all('is_contiguous', '\nis_contiguous(memory_format=torch.contiguous_format) -> bool\n\nReturns True if :attr:`self` tensor is contiguous in memory in the order specified\nby memory format.\n\nArgs:\n    memory_format (:class:`torch.memory_format`, optional): Specifies memory allocation\n        order. Default: ``torch.contiguous_format``.\n')
add_docstr_all('is_pinned', '\nReturns true if this tensor resides in pinned memory.\n')
add_docstr_all('is_floating_point', '\nis_floating_point() -> bool\n\nReturns True if the data type of :attr:`self` is a floating point data type.\n')
add_docstr_all('is_complex', '\nis_complex() -> bool\n\nReturns True if the data type of :attr:`self` is a complex data type.\n')
add_docstr_all('is_signed', '\nis_signed() -> bool\n\nReturns True if the data type of :attr:`self` is a signed data type.\n')
add_docstr_all('is_set_to', '\nis_set_to(tensor) -> bool\n\nReturns True if this object refers to the same ``THTensor`` object from the\nTorch C API as the given tensor.\n')
add_docstr_all('item', '\nitem() -> number\n\nReturns the value of this tensor as a standard Python number. This only works\nfor tensors with one element. For other cases, see :meth:`~Tensor.tolist`.\n\nThis operation is not differentiable.\n\nExample::\n\n    >>> x = torch.tensor([1.0])\n    >>> x.item()\n    1.0\n\n')
add_docstr_all('kthvalue', '\nkthvalue(k, dim=None, keepdim=False) -> (Tensor, LongTensor)\n\nSee :func:`torch.kthvalue`\n')
add_docstr_all('le', '\nle(other) -> Tensor\n\nSee :func:`torch.le`\n')
add_docstr_all('le_', '\nle_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.le`\n')
add_docstr_all('lerp', '\nlerp(end, weight) -> Tensor\n\nSee :func:`torch.lerp`\n')
add_docstr_all('lerp_', '\nlerp_(end, weight) -> Tensor\n\nIn-place version of :meth:`~Tensor.lerp`\n')
add_docstr_all('lgamma', '\nlgamma() -> Tensor\n\nSee :func:`torch.lgamma`\n')
add_docstr_all('lgamma_', '\nlgamma_() -> Tensor\n\nIn-place version of :meth:`~Tensor.lgamma`\n')
add_docstr_all('log', '\nlog() -> Tensor\n\nSee :func:`torch.log`\n')
add_docstr_all('log_', '\nlog_() -> Tensor\n\nIn-place version of :meth:`~Tensor.log`\n')
add_docstr_all('log10', '\nlog10() -> Tensor\n\nSee :func:`torch.log10`\n')
add_docstr_all('log10_', '\nlog10_() -> Tensor\n\nIn-place version of :meth:`~Tensor.log10`\n')
add_docstr_all('log1p', '\nlog1p() -> Tensor\n\nSee :func:`torch.log1p`\n')
add_docstr_all('log1p_', '\nlog1p_() -> Tensor\n\nIn-place version of :meth:`~Tensor.log1p`\n')
add_docstr_all('log2', '\nlog2() -> Tensor\n\nSee :func:`torch.log2`\n')
add_docstr_all('log2_', '\nlog2_() -> Tensor\n\nIn-place version of :meth:`~Tensor.log2`\n')
add_docstr_all('log_normal_', '\nlog_normal_(mean=1, std=2, *, generator=None)\n\nFills :attr:`self` tensor with numbers samples from the log-normal distribution\nparameterized by the given mean :math:`\\mu` and standard deviation\n:math:`\\sigma`. Note that :attr:`mean` and :attr:`std` are the mean and\nstandard deviation of the underlying normal distribution, and not of the\nreturned distribution:\n\n.. math::\n\n    f(x) = \\dfrac{1}{x \\sigma \\sqrt{2\\pi}}\\ e^{-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}}\n')
add_docstr_all('logsumexp', '\nlogsumexp(dim, keepdim=False) -> Tensor\n\nSee :func:`torch.logsumexp`\n')
add_docstr_all('lstsq', '\nlstsq(A) -> (Tensor, Tensor)\n\nSee :func:`torch.lstsq`\n')
add_docstr_all('lt', '\nlt(other) -> Tensor\n\nSee :func:`torch.lt`\n')
add_docstr_all('lt_', '\nlt_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.lt`\n')
add_docstr_all('lu_solve', '\nlu_solve(LU_data, LU_pivots) -> Tensor\n\nSee :func:`torch.lu_solve`\n')
add_docstr_all('map_', '\nmap_(tensor, callable)\n\nApplies :attr:`callable` for each element in :attr:`self` tensor and the given\n:attr:`tensor` and stores the results in :attr:`self` tensor. :attr:`self` tensor and\nthe given :attr:`tensor` must be :ref:`broadcastable <broadcasting-semantics>`.\n\nThe :attr:`callable` should have the signature::\n\n    def callable(a, b) -> number\n')
add_docstr_all('masked_scatter_', '\nmasked_scatter_(mask, source)\n\nCopies elements from :attr:`source` into :attr:`self` tensor at positions where\nthe :attr:`mask` is True.\nThe shape of :attr:`mask` must be :ref:`broadcastable <broadcasting-semantics>`\nwith the shape of the underlying tensor. The :attr:`source` should have at least\nas many elements as the number of ones in :attr:`mask`\n\nArgs:\n    mask (BoolTensor): the boolean mask\n    source (Tensor): the tensor to copy from\n\n.. note::\n\n    The :attr:`mask` operates on the :attr:`self` tensor, not on the given\n    :attr:`source` tensor.\n')
add_docstr_all('masked_fill_', '\nmasked_fill_(mask, value)\n\nFills elements of :attr:`self` tensor with :attr:`value` where :attr:`mask` is\nTrue. The shape of :attr:`mask` must be\n:ref:`broadcastable <broadcasting-semantics>` with the shape of the underlying\ntensor.\n\nArgs:\n    mask (BoolTensor): the boolean mask\n    value (float): the value to fill in with\n')
add_docstr_all('masked_select', '\nmasked_select(mask) -> Tensor\n\nSee :func:`torch.masked_select`\n')
add_docstr_all('matrix_power', '\nmatrix_power(n) -> Tensor\n\nSee :func:`torch.matrix_power`\n')
add_docstr_all('max', '\nmax(dim=None, keepdim=False) -> Tensor or (Tensor, Tensor)\n\nSee :func:`torch.max`\n')
add_docstr_all('argmax', '\nargmax(dim=None, keepdim=False) -> LongTensor\n\nSee :func:`torch.argmax`\n')
add_docstr_all('mean', '\nmean(dim=None, keepdim=False) -> Tensor or (Tensor, Tensor)\n\nSee :func:`torch.mean`\n')
add_docstr_all('median', '\nmedian(dim=None, keepdim=False) -> (Tensor, LongTensor)\n\nSee :func:`torch.median`\n')
add_docstr_all('min', '\nmin(dim=None, keepdim=False) -> Tensor or (Tensor, Tensor)\n\nSee :func:`torch.min`\n')
add_docstr_all('argmin', '\nargmin(dim=None, keepdim=False) -> LongTensor\n\nSee :func:`torch.argmin`\n')
add_docstr_all('mm', '\nmm(mat2) -> Tensor\n\nSee :func:`torch.mm`\n')
add_docstr_all('mode', '\nmode(dim=None, keepdim=False) -> (Tensor, LongTensor)\n\nSee :func:`torch.mode`\n')
add_docstr_all('mul', '\nmul(value) -> Tensor\n\nSee :func:`torch.mul`\n')
add_docstr_all('mul_', '\nmul_(value)\n\nIn-place version of :meth:`~Tensor.mul`\n')
add_docstr_all('multinomial', '\nmultinomial(num_samples, replacement=False, *, generator=None) -> Tensor\n\nSee :func:`torch.multinomial`\n')
add_docstr_all('mv', '\nmv(vec) -> Tensor\n\nSee :func:`torch.mv`\n')
add_docstr_all('mvlgamma', '\nmvlgamma(p) -> Tensor\n\nSee :func:`torch.mvlgamma`\n')
add_docstr_all('mvlgamma_', '\nmvlgamma_(p) -> Tensor\n\nIn-place version of :meth:`~Tensor.mvlgamma`\n')
add_docstr_all('narrow', '\nnarrow(dimension, start, length) -> Tensor\n\nSee :func:`torch.narrow`\n\nExample::\n\n    >>> x = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> x.narrow(0, 0, 2)\n    tensor([[ 1,  2,  3],\n            [ 4,  5,  6]])\n    >>> x.narrow(1, 1, 2)\n    tensor([[ 2,  3],\n            [ 5,  6],\n            [ 8,  9]])\n')
add_docstr_all('narrow_copy', '\nnarrow_copy(dimension, start, length) -> Tensor\n\nSame as :meth:`Tensor.narrow` except returning a copy rather\nthan shared storage.  This is primarily for sparse tensors, which\ndo not have a shared-storage narrow method.  Calling ```narrow_copy``\nwith ```dimemsion > self.sparse_dim()``` will return a copy with the\nrelevant dense dimension narrowed, and ```self.shape``` updated accordingly.\n')
add_docstr_all('ndimension', '\nndimension() -> int\n\nAlias for :meth:`~Tensor.dim()`\n')
add_docstr_all('ne', '\nne(other) -> Tensor\n\nSee :func:`torch.ne`\n')
add_docstr_all('ne_', '\nne_(other) -> Tensor\n\nIn-place version of :meth:`~Tensor.ne`\n')
add_docstr_all('neg', '\nneg() -> Tensor\n\nSee :func:`torch.neg`\n')
add_docstr_all('neg_', '\nneg_() -> Tensor\n\nIn-place version of :meth:`~Tensor.neg`\n')
add_docstr_all('nelement', '\nnelement() -> int\n\nAlias for :meth:`~Tensor.numel`\n')
add_docstr_all('nonzero', '\nnonzero() -> LongTensor\n\nSee :func:`torch.nonzero`\n')
add_docstr_all('norm', '\nnorm(p=2, dim=None, keepdim=False) -> Tensor\n\nSee :func:`torch.norm`\n')
add_docstr_all('normal_', '\nnormal_(mean=0, std=1, *, generator=None) -> Tensor\n\nFills :attr:`self` tensor with elements samples from the normal distribution\nparameterized by :attr:`mean` and :attr:`std`.\n')
add_docstr_all('numel', '\nnumel() -> int\n\nSee :func:`torch.numel`\n')
add_docstr_all('numpy', '\nnumpy() -> numpy.ndarray\n\nReturns :attr:`self` tensor as a NumPy :class:`ndarray`. This tensor and the\nreturned :class:`ndarray` share the same underlying storage. Changes to\n:attr:`self` tensor will be reflected in the :class:`ndarray` and vice versa.\n')
add_docstr_all('orgqr', '\norgqr(input2) -> Tensor\n\nSee :func:`torch.orgqr`\n')
add_docstr_all('ormqr', '\normqr(input2, input3, left=True, transpose=False) -> Tensor\n\nSee :func:`torch.ormqr`\n')
add_docstr_all('permute', '\npermute(*dims) -> Tensor\n\nReturns a view of the original tensor with its dimensions permuted.\n\nArgs:\n    *dims (int...): The desired ordering of dimensions\n\nExample:\n    >>> x = torch.randn(2, 3, 5)\n    >>> x.size()\n    torch.Size([2, 3, 5])\n    >>> x.permute(2, 0, 1).size()\n    torch.Size([5, 2, 3])\n')
add_docstr_all('polygamma', '\npolygamma(n) -> Tensor\n\nSee :func:`torch.polygamma`\n')
add_docstr_all('polygamma_', '\npolygamma_(n) -> Tensor\n\nIn-place version of :meth:`~Tensor.polygamma`\n')
add_docstr_all('pow', '\npow(exponent) -> Tensor\n\nSee :func:`torch.pow`\n')
add_docstr_all('pow_', '\npow_(exponent) -> Tensor\n\nIn-place version of :meth:`~Tensor.pow`\n')
add_docstr_all('prod', '\nprod(dim=None, keepdim=False, dtype=None) -> Tensor\n\nSee :func:`torch.prod`\n')
add_docstr_all('put_', '\nput_(indices, tensor, accumulate=False) -> Tensor\n\nCopies the elements from :attr:`tensor` into the positions specified by\nindices. For the purpose of indexing, the :attr:`self` tensor is treated as if\nit were a 1-D tensor.\n\nIf :attr:`accumulate` is ``True``, the elements in :attr:`tensor` are added to\n:attr:`self`. If accumulate is ``False``, the behavior is undefined if indices\ncontain duplicate elements.\n\nArgs:\n    indices (LongTensor): the indices into self\n    tensor (Tensor): the tensor containing values to copy from\n    accumulate (bool): whether to accumulate into self\n\nExample::\n\n    >>> src = torch.tensor([[4, 3, 5],\n                            [6, 7, 8]])\n    >>> src.put_(torch.tensor([1, 3]), torch.tensor([9, 10]))\n    tensor([[  4,   9,   5],\n            [ 10,   7,   8]])\n')
add_docstr_all('qr', '\nqr(some=True) -> (Tensor, Tensor)\n\nSee :func:`torch.qr`\n')
add_docstr_all('qscheme', '\nqscheme() -> torch.qscheme\n\nReturns the quantization scheme of a given QTensor.\n')
add_docstr_all('q_scale', '\nq_scale() -> float\n\nGiven a Tensor quantized by linear(affine) quantization,\nreturns the scale of the underlying quantizer().\n')
add_docstr_all('q_zero_point', '\nq_zero_point() -> int\n\nGiven a Tensor quantized by linear(affine) quantization,\nreturns the zero_point of the underlying quantizer().\n')
add_docstr_all('q_per_channel_scales', '\nq_per_channel_scales() -> Tensor\n\nGiven a Tensor quantized by linear (affine) per-channel quantization,\nreturns a Tensor of scales of the underlying quantizer. It has the number of\nelements that matches the corresponding dimensions (from q_per_channel_axis) of\nthe tensor.\n')
add_docstr_all('q_per_channel_zero_points', '\nq_per_channel_zero_points() -> Tensor\n\nGiven a Tensor quantized by linear (affine) per-channel quantization,\nreturns a tensor of zero_points of the underlying quantizer. It has the number of\nelements that matches the corresponding dimensions (from q_per_channel_axis) of\nthe tensor.\n')
add_docstr_all('q_per_channel_axis', '\nq_per_channel_axis() -> int\n\nGiven a Tensor quantized by linear (affine) per-channel quantization,\nreturns the index of dimension on which per-channel quantization is applied.\n')
add_docstr_all('random_', "\nrandom_(from=0, to=None, *, generator=None) -> Tensor\n\nFills :attr:`self` tensor with numbers sampled from the discrete uniform\ndistribution over ``[from, to - 1]``. If not specified, the values are usually\nonly bounded by :attr:`self` tensor's data type. However, for floating point\ntypes, if unspecified, range will be ``[0, 2^mantissa]`` to ensure that every\nvalue is representable. For example, `torch.tensor(1, dtype=torch.double).random_()`\nwill be uniform in ``[0, 2^53]``.\n")
add_docstr_all('reciprocal', '\nreciprocal() -> Tensor\n\nSee :func:`torch.reciprocal`\n')
add_docstr_all('reciprocal_', '\nreciprocal_() -> Tensor\n\nIn-place version of :meth:`~Tensor.reciprocal`\n')
add_docstr_all('record_stream', '\nrecord_stream(stream)\n\nEnsures that the tensor memory is not reused for another tensor until all\ncurrent work queued on :attr:`stream` are complete.\n\n.. note::\n\n    The caching allocator is aware of only the stream where a tensor was\n    allocated. Due to the awareness, it already correctly manages the life\n    cycle of tensors on only one stream. But if a tensor is used on a stream\n    different from the stream of origin, the allocator might reuse the memory\n    unexpectedly. Calling this method lets the allocator know which streams\n    have used the tensor.\n\n')
add_docstr_all('remainder', '\nremainder(divisor) -> Tensor\n\nSee :func:`torch.remainder`\n')
add_docstr_all('remainder_', '\nremainder_(divisor) -> Tensor\n\nIn-place version of :meth:`~Tensor.remainder`\n')
add_docstr_all('renorm', '\nrenorm(p, dim, maxnorm) -> Tensor\n\nSee :func:`torch.renorm`\n')
add_docstr_all('renorm_', '\nrenorm_(p, dim, maxnorm) -> Tensor\n\nIn-place version of :meth:`~Tensor.renorm`\n')
add_docstr_all('repeat', "\nrepeat(*sizes) -> Tensor\n\nRepeats this tensor along the specified dimensions.\n\nUnlike :meth:`~Tensor.expand`, this function copies the tensor's data.\n\n.. warning::\n\n    :meth:`~Tensor.repeat` behaves differently from\n    `numpy.repeat <https://docs.scipy.org/doc/numpy/reference/generated/numpy.repeat.html>`_,\n    but is more similar to\n    `numpy.tile <https://docs.scipy.org/doc/numpy/reference/generated/numpy.tile.html>`_.\n    For the operator similar to `numpy.repeat`, see :func:`torch.repeat_interleave`.\n\nArgs:\n    sizes (torch.Size or int...): The number of times to repeat this tensor along each\n        dimension\n\nExample::\n\n    >>> x = torch.tensor([1, 2, 3])\n    >>> x.repeat(4, 2)\n    tensor([[ 1,  2,  3,  1,  2,  3],\n            [ 1,  2,  3,  1,  2,  3],\n            [ 1,  2,  3,  1,  2,  3],\n            [ 1,  2,  3,  1,  2,  3]])\n    >>> x.repeat(4, 2, 1).size()\n    torch.Size([4, 2, 3])\n")
add_docstr_all('repeat_interleave', '\nrepeat_interleave(repeats, dim=None) -> Tensor\n\nSee :func:`torch.repeat_interleave`.\n')
add_docstr_all('requires_grad_', "\nrequires_grad_(requires_grad=True) -> Tensor\n\nChange if autograd should record operations on this tensor: sets this tensor's\n:attr:`requires_grad` attribute in-place. Returns this tensor.\n\n:func:`requires_grad_`'s main use case is to tell autograd to begin recording\noperations on a Tensor ``tensor``. If ``tensor`` has ``requires_grad=False``\n(because it was obtained through a DataLoader, or required preprocessing or\ninitialization), ``tensor.requires_grad_()`` makes it so that autograd will\nbegin to record operations on ``tensor``.\n\nArgs:\n    requires_grad (bool): If autograd should record operations on this tensor.\n        Default: ``True``.\n\nExample::\n\n    >>> # Let's say we want to preprocess some saved weights and use\n    >>> # the result as new weights.\n    >>> saved_weights = [0.1, 0.2, 0.3, 0.25]\n    >>> loaded_weights = torch.tensor(saved_weights)\n    >>> weights = preprocess(loaded_weights)  # some function\n    >>> weights\n    tensor([-0.5503,  0.4926, -2.1158, -0.8303])\n\n    >>> # Now, start to record operations done to weights\n    >>> weights.requires_grad_()\n    >>> out = weights.pow(2).sum()\n    >>> out.backward()\n    >>> weights.grad\n    tensor([-1.1007,  0.9853, -4.2316, -1.6606])\n\n")
add_docstr_all('reshape', '\nreshape(*shape) -> Tensor\n\nReturns a tensor with the same data and number of elements as :attr:`self`\nbut with the specified shape. This method returns a view if :attr:`shape` is\ncompatible with the current shape. See :meth:`torch.Tensor.view` on when it is\npossible to return a view.\n\nSee :func:`torch.reshape`\n\nArgs:\n    shape (tuple of ints or int...): the desired shape\n\n')
add_docstr_all('reshape_as', '\nreshape_as(other) -> Tensor\n\nReturns this tensor as the same shape as :attr:`other`.\n``self.reshape_as(other)`` is equivalent to ``self.reshape(other.sizes())``.\nThis method returns a view if ``other.sizes()`` is compatible with the current\nshape. See :meth:`torch.Tensor.view` on when it is possible to return a view.\n\nPlease see :meth:`reshape` for more information about ``reshape``.\n\nArgs:\n    other (:class:`torch.Tensor`): The result tensor has the same shape\n        as :attr:`other`.\n')
add_docstr_all('resize_', '\nresize_(*sizes, memory_format=torch.contiguous_format) -> Tensor\n\nResizes :attr:`self` tensor to the specified size. If the number of elements is\nlarger than the current storage size, then the underlying storage is resized\nto fit the new number of elements. If the number of elements is smaller, the\nunderlying storage is not changed. Existing elements are preserved but any new\nmemory is uninitialized.\n\n.. warning::\n\n    This is a low-level method. The storage is reinterpreted as C-contiguous,\n    ignoring the current strides (unless the target size equals the current\n    size, in which case the tensor is left unchanged). For most purposes, you\n    will instead want to use :meth:`~Tensor.view()`, which checks for\n    contiguity, or :meth:`~Tensor.reshape()`, which copies data if needed. To\n    change the size in-place with custom strides, see :meth:`~Tensor.set_()`.\n\nArgs:\n    sizes (torch.Size or int...): the desired size\n    memory_format (:class:`torch.memory_format`, optional): the desired memory format of\n        Tensor. Default: ``torch.contiguous_format``. Note that memory format of\n        :attr:`self` is going to be unaffected if ``self.size()`` matches ``sizes``.\n\nExample::\n\n    >>> x = torch.tensor([[1, 2], [3, 4], [5, 6]])\n    >>> x.resize_(2, 2)\n    tensor([[ 1,  2],\n            [ 3,  4]])\n')
add_docstr_all('resize_as_', '\nresize_as_(tensor, memory_format=torch.contiguous_format) -> Tensor\n\nResizes the :attr:`self` tensor to be the same size as the specified\n:attr:`tensor`. This is equivalent to ``self.resize_(tensor.size())``.\n\nArgs:\n    memory_format (:class:`torch.memory_format`, optional): the desired memory format of\n        Tensor. Default: ``torch.contiguous_format``. Note that memory format of\n        :attr:`self` is going to be unaffected if ``self.size()`` matches ``tensor.size()``.\n\n')
add_docstr_all('rot90', '\nrot90(k, dims) -> Tensor\n\nSee :func:`torch.rot90`\n')
add_docstr_all('round', '\nround() -> Tensor\n\nSee :func:`torch.round`\n')
add_docstr_all('round_', '\nround_() -> Tensor\n\nIn-place version of :meth:`~Tensor.round`\n')
add_docstr_all('rsqrt', '\nrsqrt() -> Tensor\n\nSee :func:`torch.rsqrt`\n')
add_docstr_all('rsqrt_', '\nrsqrt_() -> Tensor\n\nIn-place version of :meth:`~Tensor.rsqrt`\n')
add_docstr_all('scatter_', '\nscatter_(dim, index, src) -> Tensor\n\nWrites all values from the tensor :attr:`src` into :attr:`self` at the indices\nspecified in the :attr:`index` tensor. For each value in :attr:`src`, its output\nindex is specified by its index in :attr:`src` for ``dimension != dim`` and by\nthe corresponding value in :attr:`index` for ``dimension = dim``.\n\nFor a 3-D tensor, :attr:`self` is updated as::\n\n    self[index[i][j][k]][j][k] = src[i][j][k]  # if dim == 0\n    self[i][index[i][j][k]][k] = src[i][j][k]  # if dim == 1\n    self[i][j][index[i][j][k]] = src[i][j][k]  # if dim == 2\n\nThis is the reverse operation of the manner described in :meth:`~Tensor.gather`.\n\n:attr:`self`, :attr:`index` and :attr:`src` (if it is a Tensor) should have same\nnumber of dimensions. It is also required that ``index.size(d) <= src.size(d)``\nfor all dimensions ``d``, and that ``index.size(d) <= self.size(d)`` for all\ndimensions ``d != dim``.\n\nMoreover, as for :meth:`~Tensor.gather`, the values of :attr:`index` must be\nbetween ``0`` and ``self.size(dim) - 1`` inclusive, and all values in a row\nalong the specified dimension :attr:`dim` must be unique.\n\nArgs:\n    dim (int): the axis along which to index\n    index (LongTensor): the indices of elements to scatter,\n      can be either empty or the same size of src.\n      When empty, the operation returns identity\n    src (Tensor): the source element(s) to scatter,\n      incase `value` is not specified\n    value (float): the source element(s) to scatter,\n      incase `src` is not specified\n\nExample::\n\n    >>> x = torch.rand(2, 5)\n    >>> x\n    tensor([[ 0.3992,  0.2908,  0.9044,  0.4850,  0.6004],\n            [ 0.5735,  0.9006,  0.6797,  0.4152,  0.1732]])\n    >>> torch.zeros(3, 5).scatter_(0, torch.tensor([[0, 1, 2, 0, 0], [2, 0, 0, 1, 2]]), x)\n    tensor([[ 0.3992,  0.9006,  0.6797,  0.4850,  0.6004],\n            [ 0.0000,  0.2908,  0.0000,  0.4152,  0.0000],\n            [ 0.5735,  0.0000,  0.9044,  0.0000,  0.1732]])\n\n    >>> z = torch.zeros(2, 4).scatter_(1, torch.tensor([[2], [3]]), 1.23)\n    >>> z\n    tensor([[ 0.0000,  0.0000,  1.2300,  0.0000],\n            [ 0.0000,  0.0000,  0.0000,  1.2300]])\n')
add_docstr_all('scatter_add_', '\nscatter_add_(dim, index, src) -> Tensor\n\nAdds all values from the tensor :attr:`other` into :attr:`self` at the indices\nspecified in the :attr:`index` tensor in a similar fashion as\n:meth:`~torch.Tensor.scatter_`. For each value in :attr:`src`, it is added to\nan index in :attr:`self` which is specified by its index in :attr:`src`\nfor ``dimension != dim`` and by the corresponding value in :attr:`index` for\n``dimension = dim``.\n\nFor a 3-D tensor, :attr:`self` is updated as::\n\n    self[index[i][j][k]][j][k] += src[i][j][k]  # if dim == 0\n    self[i][index[i][j][k]][k] += src[i][j][k]  # if dim == 1\n    self[i][j][index[i][j][k]] += src[i][j][k]  # if dim == 2\n\n:attr:`self`, :attr:`index` and :attr:`src` should have same number of\ndimensions. It is also required that ``index.size(d) <= src.size(d)`` for all\ndimensions ``d``, and that ``index.size(d) <= self.size(d)`` for all dimensions\n``d != dim``.\n\n.. include:: cuda_deterministic.rst\n\nArgs:\n    dim (int): the axis along which to index\n    index (LongTensor): the indices of elements to scatter and add,\n      can be either empty or the same size of src.\n      When empty, the operation returns identity.\n    src (Tensor): the source elements to scatter and add\n\nExample::\n\n    >>> x = torch.rand(2, 5)\n    >>> x\n    tensor([[0.7404, 0.0427, 0.6480, 0.3806, 0.8328],\n            [0.7953, 0.2009, 0.9154, 0.6782, 0.9620]])\n    >>> torch.ones(3, 5).scatter_add_(0, torch.tensor([[0, 1, 2, 0, 0], [2, 0, 0, 1, 2]]), x)\n    tensor([[1.7404, 1.2009, 1.9154, 1.3806, 1.8328],\n            [1.0000, 1.0427, 1.0000, 1.6782, 1.0000],\n            [1.7953, 1.0000, 1.6480, 1.0000, 1.9620]])\n\n')
add_docstr_all('select', '\nselect(dim, index) -> Tensor\n\nSlices the :attr:`self` tensor along the selected dimension at the given index.\nThis function returns a view of the original tensor with the given dimension removed.\n\nArgs:\n    dim (int): the dimension to slice\n    index (int): the index to select with\n\n.. note::\n\n    :meth:`select` is equivalent to slicing. For example,\n    ``tensor.select(0, index)`` is equivalent to ``tensor[index]`` and\n    ``tensor.select(2, index)`` is equivalent to ``tensor[:,:,index]``.\n')
add_docstr_all('set_', '\nset_(source=None, storage_offset=0, size=None, stride=None) -> Tensor\n\nSets the underlying storage, size, and strides. If :attr:`source` is a tensor,\n:attr:`self` tensor will share the same storage and have the same size and\nstrides as :attr:`source`. Changes to elements in one tensor will be reflected\nin the other.\n\nIf :attr:`source` is a :class:`~torch.Storage`, the method sets the underlying\nstorage, offset, size, and stride.\n\nArgs:\n    source (Tensor or Storage): the tensor or storage to use\n    storage_offset (int, optional): the offset in the storage\n    size (torch.Size, optional): the desired size. Defaults to the size of the source.\n    stride (tuple, optional): the desired stride. Defaults to C-contiguous strides.\n')
add_docstr_all('sigmoid', '\nsigmoid() -> Tensor\n\nSee :func:`torch.sigmoid`\n')
add_docstr_all('sigmoid_', '\nsigmoid_() -> Tensor\n\nIn-place version of :meth:`~Tensor.sigmoid`\n')
add_docstr_all('sign', '\nsign() -> Tensor\n\nSee :func:`torch.sign`\n')
add_docstr_all('sign_', '\nsign_() -> Tensor\n\nIn-place version of :meth:`~Tensor.sign`\n')
add_docstr_all('sin', '\nsin() -> Tensor\n\nSee :func:`torch.sin`\n')
add_docstr_all('sin_', '\nsin_() -> Tensor\n\nIn-place version of :meth:`~Tensor.sin`\n')
add_docstr_all('sinh', '\nsinh() -> Tensor\n\nSee :func:`torch.sinh`\n')
add_docstr_all('sinh_', '\nsinh_() -> Tensor\n\nIn-place version of :meth:`~Tensor.sinh`\n')
add_docstr_all('size', '\nsize() -> torch.Size\n\nReturns the size of the :attr:`self` tensor. The returned value is a subclass of\n:class:`tuple`.\n\nExample::\n\n    >>> torch.empty(3, 4, 5).size()\n    torch.Size([3, 4, 5])\n\n')
add_docstr_all('solve', '\nsolve(A) -> Tensor, Tensor\n\nSee :func:`torch.solve`\n')
add_docstr_all('sort', '\nsort(dim=-1, descending=False) -> (Tensor, LongTensor)\n\nSee :func:`torch.sort`\n')
add_docstr_all('argsort', '\nargsort(dim=-1, descending=False) -> LongTensor\n\nSee :func:`torch.argsort`\n')
add_docstr_all('sparse_dim', '\nsparse_dim() -> int\n\nIf :attr:`self` is a sparse COO tensor (i.e., with ``torch.sparse_coo`` layout),\nthis returns the number of sparse dimensions. Otherwise, this throws an error.\n\nSee also :meth:`Tensor.dense_dim`.\n')
add_docstr_all('sqrt', '\nsqrt() -> Tensor\n\nSee :func:`torch.sqrt`\n')
add_docstr_all('sqrt_', '\nsqrt_() -> Tensor\n\nIn-place version of :meth:`~Tensor.sqrt`\n')
add_docstr_all('square', '\nsquare() -> Tensor\n\nSee :func:`torch.square`\n')
add_docstr_all('square_', '\nsquare_() -> Tensor\n\nIn-place version of :meth:`~Tensor.square`\n')
add_docstr_all('squeeze', '\nsqueeze(dim=None) -> Tensor\n\nSee :func:`torch.squeeze`\n')
add_docstr_all('squeeze_', '\nsqueeze_(dim=None) -> Tensor\n\nIn-place version of :meth:`~Tensor.squeeze`\n')
add_docstr_all('std', '\nstd(dim=None, unbiased=True, keepdim=False) -> Tensor\n\nSee :func:`torch.std`\n')
add_docstr_all('storage', '\nstorage() -> torch.Storage\n\nReturns the underlying storage.\n')
add_docstr_all('storage_offset', "\nstorage_offset() -> int\n\nReturns :attr:`self` tensor's offset in the underlying storage in terms of\nnumber of storage elements (not bytes).\n\nExample::\n\n    >>> x = torch.tensor([1, 2, 3, 4, 5])\n    >>> x.storage_offset()\n    0\n    >>> x[3:].storage_offset()\n    3\n\n")
add_docstr_all('storage_type', '\nstorage_type() -> type\n\nReturns the type of the underlying storage.\n')
add_docstr_all('stride', '\nstride(dim) -> tuple or int\n\nReturns the stride of :attr:`self` tensor.\n\nStride is the jump necessary to go from one element to the next one in the\nspecified dimension :attr:`dim`. A tuple of all strides is returned when no\nargument is passed in. Otherwise, an integer value is returned as the stride in\nthe particular dimension :attr:`dim`.\n\nArgs:\n    dim (int, optional): the desired dimension in which stride is required\n\nExample::\n\n    >>> x = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])\n    >>> x.stride()\n    (5, 1)\n    >>>x.stride(0)\n    5\n    >>> x.stride(-1)\n    1\n\n')
add_docstr_all('sub', '\nsub(other, *, alpha=1) -> Tensor\n\nSubtracts a scalar or tensor from :attr:`self` tensor. If both :attr:`alpha`\nand :attr:`other` are specified, each element of :attr:`other` is scaled by\n:attr:`alpha` before being used.\n\nWhen :attr:`other` is a tensor, the shape of :attr:`other` must be\n:ref:`broadcastable <broadcasting-semantics>` with the shape of the underlying\ntensor.\n\n')
add_docstr_all('sub_', '\nsub_(other, *, alpha=1) -> Tensor\n\nIn-place version of :meth:`~Tensor.sub`\n')
add_docstr_all('sum', '\nsum(dim=None, keepdim=False, dtype=None) -> Tensor\n\nSee :func:`torch.sum`\n')
add_docstr_all('svd', '\nsvd(some=True, compute_uv=True) -> (Tensor, Tensor, Tensor)\n\nSee :func:`torch.svd`\n')
add_docstr_all('symeig', '\nsymeig(eigenvectors=False, upper=True) -> (Tensor, Tensor)\n\nSee :func:`torch.symeig`\n')
add_docstr_all('t', '\nt() -> Tensor\n\nSee :func:`torch.t`\n')
add_docstr_all('t_', '\nt_() -> Tensor\n\nIn-place version of :meth:`~Tensor.t`\n')
add_docstr_all('to', "\nto(*args, **kwargs) -> Tensor\n\nPerforms Tensor dtype and/or device conversion. A :class:`torch.dtype` and :class:`torch.device` are\ninferred from the arguments of ``self.to(*args, **kwargs)``.\n\n.. note::\n\n    If the ``self`` Tensor already\n    has the correct :class:`torch.dtype` and :class:`torch.device`, then ``self`` is returned.\n    Otherwise, the returned tensor is a copy of ``self`` with the desired\n    :class:`torch.dtype` and :class:`torch.device`.\n\nHere are the ways to call ``to``:\n\n.. function:: to(dtype, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor\n\n    Returns a Tensor with the specified :attr:`dtype`\n\n    Args:\n        {memory_format}\n\n.. function:: to(device=None, dtype=None, non_blocking=False, copy=False, memory_format=torch.preserve_format) -> Tensor\n\n    Returns a Tensor with the specified :attr:`device` and (optional)\n    :attr:`dtype`. If :attr:`dtype` is ``None`` it is inferred to be ``self.dtype``.\n    When :attr:`non_blocking`, tries to convert asynchronously with respect to\n    the host if possible, e.g., converting a CPU Tensor with pinned memory to a\n    CUDA Tensor.\n    When :attr:`copy` is set, a new Tensor is created even when the Tensor\n    already matches the desired conversion.\n\n    Args:\n        {memory_format}\n\n.. function:: to(other, non_blocking=False, copy=False) -> Tensor\n\n    Returns a Tensor with same :class:`torch.dtype` and :class:`torch.device` as\n    the Tensor :attr:`other`. When :attr:`non_blocking`, tries to convert\n    asynchronously with respect to the host if possible, e.g., converting a CPU\n    Tensor with pinned memory to a CUDA Tensor.\n    When :attr:`copy` is set, a new Tensor is created even when the Tensor\n    already matches the desired conversion.\n\nExample::\n\n    >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu\n    >>> tensor.to(torch.float64)\n    tensor([[-0.5044,  0.0005],\n            [ 0.3310, -0.0584]], dtype=torch.float64)\n\n    >>> cuda0 = torch.device('cuda:0')\n    >>> tensor.to(cuda0)\n    tensor([[-0.5044,  0.0005],\n            [ 0.3310, -0.0584]], device='cuda:0')\n\n    >>> tensor.to(cuda0, dtype=torch.float64)\n    tensor([[-0.5044,  0.0005],\n            [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')\n\n    >>> other = torch.randn((), dtype=torch.float64, device=cuda0)\n    >>> tensor.to(other, non_blocking=True)\n    tensor([[-0.5044,  0.0005],\n            [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')\n".format(**common_args))
add_docstr_all('byte', '\nbyte(memory_format=torch.preserve_format) -> Tensor\n\n``self.byte()`` is equivalent to ``self.to(torch.uint8)``. See :func:`to`.\n\nArgs:\n    {memory_format}\n'.format(**common_args))
add_docstr_all('bool', '\nbool(memory_format=torch.preserve_format) -> Tensor\n\n``self.bool()`` is equivalent to ``self.to(torch.bool)``. See :func:`to`.\n\nArgs:\n    {memory_format}\n'.format(**common_args))
add_docstr_all('char', '\nchar(memory_format=torch.preserve_format) -> Tensor\n\n``self.char()`` is equivalent to ``self.to(torch.int8)``. See :func:`to`.\n\nArgs:\n    {memory_format}\n'.format(**common_args))
add_docstr_all('bfloat16', '\nbfloat16(memory_format=torch.preserve_format) -> Tensor\n``self.bfloat16()`` is equivalent to ``self.to(torch.bfloat16)``. See :func:`to`.\n\nArgs:\n    {memory_format}\n'.format(**common_args))
add_docstr_all('double', '\ndouble(memory_format=torch.preserve_format) -> Tensor\n\n``self.double()`` is equivalent to ``self.to(torch.float64)``. See :func:`to`.\n\nArgs:\n    {memory_format}\n'.format(**common_args))
add_docstr_all('float', '\nfloat(memory_format=torch.preserve_format) -> Tensor\n\n``self.float()`` is equivalent to ``self.to(torch.float32)``. See :func:`to`.\n\nArgs:\n    {memory_format}\n'.format(**common_args))
add_docstr_all('half', '\nhalf(memory_format=torch.preserve_format) -> Tensor\n\n``self.half()`` is equivalent to ``self.to(torch.float16)``. See :func:`to`.\n\nArgs:\n    {memory_format}\n'.format(**common_args))
add_docstr_all('int', '\nint(memory_format=torch.preserve_format) -> Tensor\n\n``self.int()`` is equivalent to ``self.to(torch.int32)``. See :func:`to`.\n\nArgs:\n    {memory_format}\n'.format(**common_args))
add_docstr_all('int_repr', '\nint_repr() -> Tensor\n\nGiven a quantized Tensor,\n``self.int_repr()`` returns a CPU Tensor with uint8_t as data type that stores the\nunderlying uint8_t values of the given Tensor.\n')
add_docstr_all('long', '\nlong(memory_format=torch.preserve_format) -> Tensor\n\n``self.long()`` is equivalent to ``self.to(torch.int64)``. See :func:`to`.\n\nArgs:\n    {memory_format}\n'.format(**common_args))
add_docstr_all('short', '\nshort(memory_format=torch.preserve_format) -> Tensor\n\n``self.short()`` is equivalent to ``self.to(torch.int16)``. See :func:`to`.\n\nArgs:\n    {memory_format}\n'.format(**common_args))
add_docstr_all('take', '\ntake(indices) -> Tensor\n\nSee :func:`torch.take`\n')
add_docstr_all('tan', '\ntan() -> Tensor\n\nSee :func:`torch.tan`\n')
add_docstr_all('tan_', '\ntan_() -> Tensor\n\nIn-place version of :meth:`~Tensor.tan`\n')
add_docstr_all('tanh', '\ntanh() -> Tensor\n\nSee :func:`torch.tanh`\n')
add_docstr_all('tanh_', '\ntanh_() -> Tensor\n\nIn-place version of :meth:`~Tensor.tanh`\n')
add_docstr_all('tolist', '"\ntolist() -> list or number\n\nReturns the tensor as a (nested) list. For scalars, a standard\nPython number is returned, just like with :meth:`~Tensor.item`.\nTensors are automatically moved to the CPU first if necessary.\n\nThis operation is not differentiable.\n\nExamples::\n\n    >>> a = torch.randn(2, 2)\n    >>> a.tolist()\n    [[0.012766935862600803, 0.5415473580360413],\n     [-0.08909505605697632, 0.7729271650314331]]\n    >>> a[0,0].tolist()\n    0.012766935862600803\n')
add_docstr_all('topk', '\ntopk(k, dim=None, largest=True, sorted=True) -> (Tensor, LongTensor)\n\nSee :func:`torch.topk`\n')
add_docstr_all('to_sparse', '\nto_sparse(sparseDims) -> Tensor\nReturns a sparse copy of the tensor.  PyTorch supports sparse tensors in\n:ref:`coordinate format <sparse-docs>`.\n\nArgs:\n    sparseDims (int, optional): the number of sparse dimensions to include in the new sparse tensor\n\nExample::\n\n    >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])\n    >>> d\n    tensor([[ 0,  0,  0],\n            [ 9,  0, 10],\n            [ 0,  0,  0]])\n    >>> d.to_sparse()\n    tensor(indices=tensor([[1, 1],\n                           [0, 2]]),\n           values=tensor([ 9, 10]),\n           size=(3, 3), nnz=2, layout=torch.sparse_coo)\n    >>> d.to_sparse(1)\n    tensor(indices=tensor([[1]]),\n           values=tensor([[ 9,  0, 10]]),\n           size=(3, 3), nnz=1, layout=torch.sparse_coo)\n')
add_docstr_all('to_mkldnn', '\nto_mkldnn() -> Tensor\nReturns a copy of the tensor in ``torch.mkldnn`` layout.\n\n')
add_docstr_all('trace', '\ntrace() -> Tensor\n\nSee :func:`torch.trace`\n')
add_docstr_all('transpose', '\ntranspose(dim0, dim1) -> Tensor\n\nSee :func:`torch.transpose`\n')
add_docstr_all('transpose_', '\ntranspose_(dim0, dim1) -> Tensor\n\nIn-place version of :meth:`~Tensor.transpose`\n')
add_docstr_all('triangular_solve', '\ntriangular_solve(A, upper=True, transpose=False, unitriangular=False) -> (Tensor, Tensor)\n\nSee :func:`torch.triangular_solve`\n')
add_docstr_all('tril', '\ntril(k=0) -> Tensor\n\nSee :func:`torch.tril`\n')
add_docstr_all('tril_', '\ntril_(k=0) -> Tensor\n\nIn-place version of :meth:`~Tensor.tril`\n')
add_docstr_all('triu', '\ntriu(k=0) -> Tensor\n\nSee :func:`torch.triu`\n')
add_docstr_all('triu_', '\ntriu_(k=0) -> Tensor\n\nIn-place version of :meth:`~Tensor.triu`\n')
add_docstr_all('true_divide', '\ntrue_divide(value) -> Tensor\n\nSee :func:`torch.true_divide`\n')
add_docstr_all('true_divide_', '\ntrue_divide_(value) -> Tensor\n\nIn-place version of :meth:`~Tensor.true_divide_`\n')
add_docstr_all('trunc', '\ntrunc() -> Tensor\n\nSee :func:`torch.trunc`\n')
add_docstr_all('trunc_', '\ntrunc_() -> Tensor\n\nIn-place version of :meth:`~Tensor.trunc`\n')
add_docstr_all('type', '\ntype(dtype=None, non_blocking=False, **kwargs) -> str or Tensor\nReturns the type if `dtype` is not provided, else casts this object to\nthe specified type.\n\nIf this is already of the correct type, no copy is performed and the\noriginal object is returned.\n\nArgs:\n    dtype (type or string): The desired type\n    non_blocking (bool): If ``True``, and the source is in pinned memory\n        and destination is on the GPU or vice versa, the copy is performed\n        asynchronously with respect to the host. Otherwise, the argument\n        has no effect.\n    **kwargs: For compatibility, may contain the key ``async`` in place of\n        the ``non_blocking`` argument. The ``async`` arg is deprecated.\n')
add_docstr_all('type_as', '\ntype_as(tensor) -> Tensor\n\nReturns this tensor cast to the type of the given tensor.\n\nThis is a no-op if the tensor is already of the correct type. This is\nequivalent to ``self.type(tensor.type())``\n\nArgs:\n    tensor (Tensor): the tensor which has the desired type\n')
add_docstr_all('unfold', '\nunfold(dimension, size, step) -> Tensor\n\nReturns a view of the original tensor which contains all slices of size :attr:`size` from\n:attr:`self` tensor in the dimension :attr:`dimension`.\n\nStep between two slices is given by :attr:`step`.\n\nIf `sizedim` is the size of dimension :attr:`dimension` for :attr:`self`, the size of\ndimension :attr:`dimension` in the returned tensor will be\n`(sizedim - size) / step + 1`.\n\nAn additional dimension of size :attr:`size` is appended in the returned tensor.\n\nArgs:\n    dimension (int): dimension in which unfolding happens\n    size (int): the size of each slice that is unfolded\n    step (int): the step between each slice\n\nExample::\n\n    >>> x = torch.arange(1., 8)\n    >>> x\n    tensor([ 1.,  2.,  3.,  4.,  5.,  6.,  7.])\n    >>> x.unfold(0, 2, 1)\n    tensor([[ 1.,  2.],\n            [ 2.,  3.],\n            [ 3.,  4.],\n            [ 4.,  5.],\n            [ 5.,  6.],\n            [ 6.,  7.]])\n    >>> x.unfold(0, 2, 2)\n    tensor([[ 1.,  2.],\n            [ 3.,  4.],\n            [ 5.,  6.]])\n')
add_docstr_all('uniform_', '\nuniform_(from=0, to=1) -> Tensor\n\nFills :attr:`self` tensor with numbers sampled from the continuous uniform\ndistribution:\n\n.. math::\n    P(x) = \\dfrac{1}{\\text{to} - \\text{from}}\n')
add_docstr_all('unsqueeze', '\nunsqueeze(dim) -> Tensor\n\nSee :func:`torch.unsqueeze`\n')
add_docstr_all('unsqueeze_', '\nunsqueeze_(dim) -> Tensor\n\nIn-place version of :meth:`~Tensor.unsqueeze`\n')
add_docstr_all('var', '\nvar(dim=None, unbiased=True, keepdim=False) -> Tensor\n\nSee :func:`torch.var`\n')
add_docstr_all('view', '\nview(*shape) -> Tensor\n\nReturns a new tensor with the same data as the :attr:`self` tensor but of a\ndifferent :attr:`shape`.\n\nThe returned tensor shares the same data and must have the same number\nof elements, but may have a different size. For a tensor to be viewed, the new\nview size must be compatible with its original size and stride, i.e., each new\nview dimension must either be a subspace of an original dimension, or only span\nacross original dimensions :math:`d, d+1, \\dots, d+k` that satisfy the following\ncontiguity-like condition that :math:`\\forall i = 0, \\dots, k-1`,\n\n.. math::\n\n  \\text{stride}[i] = \\text{stride}[i+1] \\times \\text{size}[i+1]\n\nOtherwise, :meth:`contiguous` needs to be called before the tensor can be\nviewed. See also: :meth:`reshape`, which returns a view if the shapes are\ncompatible, and copies (equivalent to calling :meth:`contiguous`) otherwise.\n\nArgs:\n    shape (torch.Size or int...): the desired size\n\nExample::\n\n    >>> x = torch.randn(4, 4)\n    >>> x.size()\n    torch.Size([4, 4])\n    >>> y = x.view(16)\n    >>> y.size()\n    torch.Size([16])\n    >>> z = x.view(-1, 8)  # the size -1 is inferred from other dimensions\n    >>> z.size()\n    torch.Size([2, 8])\n\n    >>> a = torch.randn(1, 2, 3, 4)\n    >>> a.size()\n    torch.Size([1, 2, 3, 4])\n    >>> b = a.transpose(1, 2)  # Swaps 2nd and 3rd dimension\n    >>> b.size()\n    torch.Size([1, 3, 2, 4])\n    >>> c = a.view(1, 3, 2, 4)  # Does not change tensor layout in memory\n    >>> c.size()\n    torch.Size([1, 3, 2, 4])\n    >>> torch.equal(b, c)\n    False\n\n')
add_docstr_all('view_as', '\nview_as(other) -> Tensor\n\nView this tensor as the same size as :attr:`other`.\n``self.view_as(other)`` is equivalent to ``self.view(other.size())``.\n\nPlease see :meth:`~Tensor.view` for more information about ``view``.\n\nArgs:\n    other (:class:`torch.Tensor`): The result tensor has the same size\n        as :attr:`other`.\n')
add_docstr_all('expand', '\nexpand(*sizes) -> Tensor\n\nReturns a new view of the :attr:`self` tensor with singleton dimensions expanded\nto a larger size.\n\nPassing -1 as the size for a dimension means not changing the size of\nthat dimension.\n\nTensor can be also expanded to a larger number of dimensions, and the\nnew ones will be appended at the front. For the new dimensions, the\nsize cannot be set to -1.\n\nExpanding a tensor does not allocate new memory, but only creates a\nnew view on the existing tensor where a dimension of size one is\nexpanded to a larger size by setting the ``stride`` to 0. Any dimension\nof size 1 can be expanded to an arbitrary value without allocating new\nmemory.\n\nArgs:\n    *sizes (torch.Size or int...): the desired expanded size\n\n.. warning::\n\n    More than one element of an expanded tensor may refer to a single\n    memory location. As a result, in-place operations (especially ones that\n    are vectorized) may result in incorrect behavior. If you need to write\n    to the tensors, please clone them first.\n\nExample::\n\n    >>> x = torch.tensor([[1], [2], [3]])\n    >>> x.size()\n    torch.Size([3, 1])\n    >>> x.expand(3, 4)\n    tensor([[ 1,  1,  1,  1],\n            [ 2,  2,  2,  2],\n            [ 3,  3,  3,  3]])\n    >>> x.expand(-1, 4)   # -1 means not changing the size of that dimension\n    tensor([[ 1,  1,  1,  1],\n            [ 2,  2,  2,  2],\n            [ 3,  3,  3,  3]])\n')
add_docstr_all('expand_as', '\nexpand_as(other) -> Tensor\n\nExpand this tensor to the same size as :attr:`other`.\n``self.expand_as(other)`` is equivalent to ``self.expand(other.size())``.\n\nPlease see :meth:`~Tensor.expand` for more information about ``expand``.\n\nArgs:\n    other (:class:`torch.Tensor`): The result tensor has the same size\n        as :attr:`other`.\n')
add_docstr_all('sum_to_size', '\nsum_to_size(*size) -> Tensor\n\nSum ``this`` tensor to :attr:`size`.\n:attr:`size` must be broadcastable to ``this`` tensor size.\n\nArgs:\n    size (int...): a sequence of integers defining the shape of the output tensor.\n')
add_docstr_all('zero_', '\nzero_() -> Tensor\n\nFills :attr:`self` tensor with zeros.\n')
add_docstr_all('matmul', '\nmatmul(tensor2) -> Tensor\n\nSee :func:`torch.matmul`\n')
add_docstr_all('chunk', '\nchunk(chunks, dim=0) -> List of Tensors\n\nSee :func:`torch.chunk`\n')
add_docstr_all('stft', '\nstft(frame_length, hop, fft_size=None, return_onesided=True, window=None, pad_end=0) -> Tensor\n\nSee :func:`torch.stft`\n')
add_docstr_all('fft', '\nfft(signal_ndim, normalized=False) -> Tensor\n\nSee :func:`torch.fft`\n')
add_docstr_all('ifft', '\nifft(signal_ndim, normalized=False) -> Tensor\n\nSee :func:`torch.ifft`\n')
add_docstr_all('rfft', '\nrfft(signal_ndim, normalized=False, onesided=True) -> Tensor\n\nSee :func:`torch.rfft`\n')
add_docstr_all('irfft', '\nirfft(signal_ndim, normalized=False, onesided=True, signal_sizes=None) -> Tensor\n\nSee :func:`torch.irfft`\n')
add_docstr_all('det', '\ndet() -> Tensor\n\nSee :func:`torch.det`\n')
add_docstr_all('where', '\nwhere(condition, y) -> Tensor\n\n``self.where(condition, y)`` is equivalent to ``torch.where(condition, self, y)``.\nSee :func:`torch.where`\n')
add_docstr_all('logdet', '\nlogdet() -> Tensor\n\nSee :func:`torch.logdet`\n')
add_docstr_all('slogdet', '\nslogdet() -> (Tensor, Tensor)\n\nSee :func:`torch.slogdet`\n')
add_docstr_all('unbind', '\nunbind(dim=0) -> seq\n\nSee :func:`torch.unbind`\n')
add_docstr_all('pin_memory', "\npin_memory() -> Tensor\n\nCopies the tensor to pinned memory, if it's not already pinned.\n")
add_docstr_all('pinverse', '\npinverse() -> Tensor\n\nSee :func:`torch.pinverse`\n')
add_docstr_all('index_add', '\nindex_add(dim, index, tensor) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.index_add_`\n')
add_docstr_all('index_copy', '\nindex_copy(dim, index, tensor) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.index_copy_`\n')
add_docstr_all('index_fill', '\nindex_fill(dim, index, value) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.index_fill_`\n')
add_docstr_all('scatter', '\nscatter(dim, index, src) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.scatter_`\n')
add_docstr_all('scatter_add', '\nscatter_add(dim, index, src) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.scatter_add_`\n')
add_docstr_all('masked_scatter', '\nmasked_scatter(mask, tensor) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.masked_scatter_`\n')
add_docstr_all('masked_fill', '\nmasked_fill(mask, value) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.masked_fill_`\n')
add_docstr_all('requires_grad', '\nIs ``True`` if gradients need to be computed for this Tensor, ``False`` otherwise.\n\n.. note::\n\n    The fact that gradients need to be computed for a Tensor do not mean that the :attr:`grad`\n    attribute will be populated, see :attr:`is_leaf` for more details.\n\n')
add_docstr_all('is_leaf', '\nAll Tensors that have :attr:`requires_grad` which is ``False`` will be leaf Tensors by convention.\n\nFor Tensors that have :attr:`requires_grad` which is ``True``, they will be leaf Tensors if they were\ncreated by the user. This means that they are not the result of an operation and so\n:attr:`grad_fn` is None.\n\nOnly leaf Tensors will have their :attr:`grad` populated during a call to :func:`backward`.\nTo get :attr:`grad` populated for non-leaf Tensors, you can use :func:`retain_grad`.\n\nExample::\n\n    >>> a = torch.rand(10, requires_grad=True)\n    >>> a.is_leaf\n    True\n    >>> b = torch.rand(10, requires_grad=True).cuda()\n    >>> b.is_leaf\n    False\n    # b was created by the operation that cast a cpu Tensor into a cuda Tensor\n    >>> c = torch.rand(10, requires_grad=True) + 2\n    >>> c.is_leaf\n    False\n    # c was created by the addition operation\n    >>> d = torch.rand(10).cuda()\n    >>> d.is_leaf\n    True\n    # d does not require gradients and so has no operation creating it (that is tracked by the autograd engine)\n    >>> e = torch.rand(10).cuda().requires_grad_()\n    >>> e.is_leaf\n    True\n    # e requires gradients and has no operations creating it\n    >>> f = torch.rand(10, requires_grad=True, device="cuda")\n    >>> f.is_leaf\n    True\n    # f requires grad, has no operation creating it\n\n\n')
add_docstr_all('names', "\nStores names for each of this tensor's dimensions.\n\n``names[idx]`` corresponds to the name of tensor dimension ``idx``.\nNames are either a string if the dimension is named or ``None`` if the\ndimension is unnamed.\n\nDimension names may contain characters or underscore. Furthermore, a dimension\nname must be a valid Python variable name (i.e., does not start with underscore).\n\nTensors may not have two named dimensions with the same name.\n\n.. warning::\n    The named tensor API is experimental and subject to change.\n\n")
add_docstr_all('is_cuda', '\nIs ``True`` if the Tensor is stored on the GPU, ``False`` otherwise.\n')
add_docstr_all('is_quantized', '\nIs ``True`` if the Tensor is quantized, ``False`` otherwise.\n')
add_docstr_all('device', '\nIs the :class:`torch.device` where this Tensor is.\n')
add_docstr_all('ndim', '\nAlias for :meth:`~Tensor.dim()`\n')
add_docstr_all('T', '\nIs this Tensor with its dimensions reversed.\n\nIf ``n`` is the number of dimensions in ``x``,\n``x.T`` is equivalent to ``x.permute(n-1, n-2, ..., 0)``.\n')

