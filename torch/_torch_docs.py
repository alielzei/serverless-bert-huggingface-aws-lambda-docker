"""Adds docstrings to functions defined in the torch._C"""

import re
import torch._C
from torch._C import _add_docstr as add_docstr

def parse_kwargs(desc):
    """Maps a description of args to a dictionary of {argname: description}.
    Input:
        ('    weight (Tensor): a weight tensor
' +
         '        Some optional description')
    Output: {
        'weight':         'weight (Tensor): a weight tensor
        Some optional description'
    }
    """
    regx = re.compile('\\n\\s{4}(?!\\s)')
    kwargs = [section.strip() for section in regx.split(desc)]
    kwargs = [section for section in kwargs if len(section) > 0]
    return {desc.split(' ')[0]: desc for desc in kwargs}

def merge_dicts(*dicts):
    return {x: d[x] for d in dicts for x in d}
common_args = parse_kwargs('\n    input (Tensor): the input tensor.\n    generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling\n    out (Tensor, optional): the output tensor.\n')
reduceops_common_args = merge_dicts(common_args, parse_kwargs('\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        If specified, the input tensor is casted to :attr:`dtype` before the operation\n        is performed. This is useful for preventing data type overflows. Default: None.\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n'))
multi_dim_common = merge_dicts(reduceops_common_args, parse_kwargs('\n    dim (int or tuple of ints): the dimension or dimensions to reduce.\n'), {'keepdim_details': '\nIf :attr:`keepdim` is ``True``, the output tensor is of the same size\nas :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the\noutput tensor having 1 (or ``len(dim)``) fewer dimension(s).\n'})
single_dim_common = merge_dicts(reduceops_common_args, parse_kwargs('\n    dim (int): the dimension to reduce.\n'), {'keepdim_details': 'If :attr:`keepdim` is ``True``, the output tensor is of the same size\nas :attr:`input` except in the dimension :attr:`dim` where it is of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in\nthe output tensor having 1 fewer dimension than :attr:`input`.'})
factory_common_args = merge_dicts(common_args, parse_kwargs('\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).\n    layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.\n        Default: ``torch.strided``.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    pin_memory (bool, optional): If set, returned tensor would be allocated in\n        the pinned memory. Works only for CPU tensors. Default: ``False``.\n    memory_format (:class:`torch.memory_format`, optional): the desired memory format of\n        returned Tensor. Default: ``torch.contiguous_format``.\n'))
factory_like_common_args = parse_kwargs('\n    input (Tensor): the size of :attr:`input` will determine size of the output tensor.\n    layout (:class:`torch.layout`, optional): the desired layout of returned tensor.\n        Default: if ``None``, defaults to the layout of :attr:`input`.\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.\n        Default: if ``None``, defaults to the dtype of :attr:`input`.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, defaults to the device of :attr:`input`.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    pin_memory (bool, optional): If set, returned tensor would be allocated in\n        the pinned memory. Works only for CPU tensors. Default: ``False``.\n    memory_format (:class:`torch.memory_format`, optional): the desired memory format of\n        returned Tensor. Default: ``torch.preserve_format``.\n')
factory_data_common_args = parse_kwargs('\n    data (array_like): Initial data for the tensor. Can be a list, tuple,\n        NumPy ``ndarray``, scalar, and other types.\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, infers data type from :attr:`data`.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    pin_memory (bool, optional): If set, returned tensor would be allocated in\n        the pinned memory. Works only for CPU tensors. Default: ``False``.\n')
add_docstr(torch.abs, '\nabs(input, out=None) -> Tensor\n\nComputes the element-wise absolute value of the given :attr:`input` tensor.\n\n.. math::\n    \\text{out}_{i} = |\\text{input}_{i}|\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> torch.abs(torch.tensor([-1, -2, 3]))\n    tensor([ 1,  2,  3])\n'.format(**common_args))
add_docstr(torch.acos, '\nacos(input, out=None) -> Tensor\n\nReturns a new tensor with the arccosine  of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\cos^{-1}(\\text{input}_{i})\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.3348, -0.5889,  0.2005, -0.1584])\n    >>> torch.acos(a)\n    tensor([ 1.2294,  2.2004,  1.3690,  1.7298])\n'.format(**common_args))
add_docstr(torch.add, '\n.. function:: add(input, other, out=None)\n\nAdds the scalar :attr:`other` to each element of the input :attr:`input`\nand returns a new resulting tensor.\n\n.. math::\n    \\text{{out}} = \\text{{input}} + \\text{{other}}\n\nIf :attr:`input` is of type FloatTensor or DoubleTensor, :attr:`other` must be\na real number, otherwise it should be an integer.\n\nArgs:\n    {input}\n    value (Number): the number to be added to each element of :attr:`input`\n\nKeyword arguments:\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.0202,  1.0985,  1.3506, -0.6056])\n    >>> torch.add(a, 20)\n    tensor([ 20.0202,  21.0985,  21.3506,  19.3944])\n\n.. function:: add(input, other, *, alpha=1, out=None)\n\nEach element of the tensor :attr:`other` is multiplied by the scalar\n:attr:`alpha` and added to each element of the tensor :attr:`input`.\nThe resulting tensor is returned.\n\nThe shapes of :attr:`input` and :attr:`other` must be\n:ref:`broadcastable <broadcasting-semantics>`.\n\n.. math::\n    \\text{{out}} = \\text{{input}} + \\text{{alpha}} \\times \\text{{other}}\n\nIf :attr:`other` is of type FloatTensor or DoubleTensor, :attr:`alpha` must be\na real number, otherwise it should be an integer.\n\nArgs:\n    input (Tensor): the first input tensor\n    other (Tensor): the second input tensor\n    alpha (Number): the scalar multiplier for :attr:`other`\n\nKeyword arguments:\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-0.9732, -0.3497,  0.6245,  0.4022])\n    >>> b = torch.randn(4, 1)\n    >>> b\n    tensor([[ 0.3743],\n            [-1.7724],\n            [-0.5811],\n            [-0.8017]])\n    >>> torch.add(a, b, alpha=10)\n    tensor([[  2.7695,   3.3930,   4.3672,   4.1450],\n            [-18.6971, -18.0736, -17.0994, -17.3216],\n            [ -6.7845,  -6.1610,  -5.1868,  -5.4090],\n            [ -8.9902,  -8.3667,  -7.3925,  -7.6147]])\n'.format(**common_args))
add_docstr(torch.addbmm, '\naddbmm(input, batch1, batch2, *, beta=1, alpha=1, out=None) -> Tensor\n\nPerforms a batch matrix-matrix product of matrices stored\nin :attr:`batch1` and :attr:`batch2`,\nwith a reduced add step (all matrix multiplications get accumulated\nalong the first dimension).\n:attr:`input` is added to the final result.\n\n:attr:`batch1` and :attr:`batch2` must be 3-D tensors each containing the\nsame number of matrices.\n\nIf :attr:`batch1` is a :math:`(b \\times n \\times m)` tensor, :attr:`batch2` is a\n:math:`(b \\times m \\times p)` tensor, :attr:`input` must be\n:ref:`broadcastable <broadcasting-semantics>` with a :math:`(n \\times p)` tensor\nand :attr:`out` will be a :math:`(n \\times p)` tensor.\n\n.. math::\n    out = \\beta\\ \\text{input} + \\alpha\\ (\\sum_{i=0}^{b-1} \\text{batch1}_i \\mathbin{@} \\text{batch2}_i)\n' + '\nFor inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and :attr:`alpha`\nmust be real numbers, otherwise they should be integers.\n\nArgs:\n    batch1 (Tensor): the first batch of matrices to be multiplied\n    batch2 (Tensor): the second batch of matrices to be multiplied\n    beta (Number, optional): multiplier for :attr:`input` (:math:`\\beta`)\n    input (Tensor): matrix to be added\n    alpha (Number, optional): multiplier for `batch1 @ batch2` (:math:`\\alpha`)\n    {out}\n\nExample::\n\n    >>> M = torch.randn(3, 5)\n    >>> batch1 = torch.randn(10, 3, 4)\n    >>> batch2 = torch.randn(10, 4, 5)\n    >>> torch.addbmm(M, batch1, batch2)\n    tensor([[  6.6311,   0.0503,   6.9768, -12.0362,  -2.1653],\n            [ -4.8185,  -1.4255,  -6.6760,   8.9453,   2.5743],\n            [ -3.8202,   4.3691,   1.0943,  -1.1109,   5.4730]])\n'.format(**common_args))
add_docstr(torch.addcdiv, '\naddcdiv(input, tensor1, tensor2, *, value=1, out=None) -> Tensor\n\nPerforms the element-wise division of :attr:`tensor1` by :attr:`tensor2`,\nmultiply the result by the scalar :attr:`value` and add it to :attr:`input`.\n\n.. warning::\n    Integer division with addcdiv is deprecated, and in a future release\n    addcdiv will perform a true division of :attr:`tensor1` and :attr:`tensor2`.\n    The current addcdiv behavior can be replicated using :func:`floor_divide`\n    for integral inputs\n    (:attr:`input` + :attr:`value` * :attr:`tensor1` // :attr:`tensor2`)\n    and :func:`div` for float inputs\n    (:attr:`input` + :attr:`value` * :attr:`tensor1` / :attr:`tensor2`).\n    The new addcdiv behavior can be implemented with :func:`true_divide`\n    (:attr:`input` + :attr:`value` * torch.true_divide(:attr:`tensor1`,\n    :attr:`tensor2`).\n\n.. math::\n    \\text{out}_i = \\text{input}_i + \\text{value} \\times \\frac{\\text{tensor1}_i}{\\text{tensor2}_i}\n' + '\n\nThe shapes of :attr:`input`, :attr:`tensor1`, and :attr:`tensor2` must be\n:ref:`broadcastable <broadcasting-semantics>`.\n\nFor inputs of type `FloatTensor` or `DoubleTensor`, :attr:`value` must be\na real number, otherwise an integer.\n\nArgs:\n    input (Tensor): the tensor to be added\n    tensor1 (Tensor): the numerator tensor\n    tensor2 (Tensor): the denominator tensor\n    value (Number, optional): multiplier for :math:`\\text{{tensor1}} / \\text{{tensor2}}`\n    {out}\n\nExample::\n\n    >>> t = torch.randn(1, 3)\n    >>> t1 = torch.randn(3, 1)\n    >>> t2 = torch.randn(1, 3)\n    >>> torch.addcdiv(t, t1, t2, value=0.1)\n    tensor([[-0.2312, -3.6496,  0.1312],\n            [-1.0428,  3.4292, -0.1030],\n            [-0.5369, -0.9829,  0.0430]])\n'.format(**common_args))
add_docstr(torch.addcmul, '\naddcmul(input, tensor1, tensor2, *, value=1, out=None) -> Tensor\n\nPerforms the element-wise multiplication of :attr:`tensor1`\nby :attr:`tensor2`, multiply the result by the scalar :attr:`value`\nand add it to :attr:`input`.\n\n.. math::\n    \\text{out}_i = \\text{input}_i + \\text{value} \\times \\text{tensor1}_i \\times \\text{tensor2}_i\n' + '\nThe shapes of :attr:`tensor`, :attr:`tensor1`, and :attr:`tensor2` must be\n:ref:`broadcastable <broadcasting-semantics>`.\n\nFor inputs of type `FloatTensor` or `DoubleTensor`, :attr:`value` must be\na real number, otherwise an integer.\n\nArgs:\n    input (Tensor): the tensor to be added\n    tensor1 (Tensor): the tensor to be multiplied\n    tensor2 (Tensor): the tensor to be multiplied\n    value (Number, optional): multiplier for :math:`tensor1 .* tensor2`\n    {out}\n\nExample::\n\n    >>> t = torch.randn(1, 3)\n    >>> t1 = torch.randn(3, 1)\n    >>> t2 = torch.randn(1, 3)\n    >>> torch.addcmul(t, t1, t2, value=0.1)\n    tensor([[-0.8635, -0.6391,  1.6174],\n            [-0.7617, -0.5879,  1.7388],\n            [-0.8353, -0.6249,  1.6511]])\n'.format(**common_args))
add_docstr(torch.addmm, '\naddmm(input, mat1, mat2, *, beta=1, alpha=1, out=None) -> Tensor\n\nPerforms a matrix multiplication of the matrices :attr:`mat1` and :attr:`mat2`.\nThe matrix :attr:`input` is added to the final result.\n\nIf :attr:`mat1` is a :math:`(n \\times m)` tensor, :attr:`mat2` is a\n:math:`(m \\times p)` tensor, then :attr:`input` must be\n:ref:`broadcastable <broadcasting-semantics>` with a :math:`(n \\times p)` tensor\nand :attr:`out` will be a :math:`(n \\times p)` tensor.\n\n:attr:`alpha` and :attr:`beta` are scaling factors on matrix-vector product between\n:attr:`mat1` and :attr:`mat2` and the added matrix :attr:`input` respectively.\n\n.. math::\n    \\text{out} = \\beta\\ \\text{input} + \\alpha\\ (\\text{mat1}_i \\mathbin{@} \\text{mat2}_i)\n' + '\nFor inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and\n:attr:`alpha` must be real numbers, otherwise they should be integers.\n\nArgs:\n    input (Tensor): matrix to be added\n    mat1 (Tensor): the first matrix to be multiplied\n    mat2 (Tensor): the second matrix to be multiplied\n    beta (Number, optional): multiplier for :attr:`input` (:math:`\\beta`)\n    alpha (Number, optional): multiplier for :math:`mat1 @ mat2` (:math:`\\alpha`)\n    {out}\n\nExample::\n\n    >>> M = torch.randn(2, 3)\n    >>> mat1 = torch.randn(2, 3)\n    >>> mat2 = torch.randn(3, 3)\n    >>> torch.addmm(M, mat1, mat2)\n    tensor([[-4.8716,  1.4671, -1.3746],\n            [ 0.7573, -3.9555, -2.8681]])\n'.format(**common_args))
add_docstr(torch.addmv, '\naddmv(input, mat, vec, *, beta=1, alpha=1, out=None) -> Tensor\n\nPerforms a matrix-vector product of the matrix :attr:`mat` and\nthe vector :attr:`vec`.\nThe vector :attr:`input` is added to the final result.\n\nIf :attr:`mat` is a :math:`(n \\times m)` tensor, :attr:`vec` is a 1-D tensor of\nsize `m`, then :attr:`input` must be\n:ref:`broadcastable <broadcasting-semantics>` with a 1-D tensor of size `n` and\n:attr:`out` will be 1-D tensor of size `n`.\n\n:attr:`alpha` and :attr:`beta` are scaling factors on matrix-vector product between\n:attr:`mat` and :attr:`vec` and the added tensor :attr:`input` respectively.\n\n.. math::\n    \\text{out} = \\beta\\ \\text{input} + \\alpha\\ (\\text{mat} \\mathbin{@} \\text{vec})\n' + '\nFor inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and\n:attr:`alpha` must be real numbers, otherwise they should be integers\n\nArgs:\n    input (Tensor): vector to be added\n    mat (Tensor): matrix to be multiplied\n    vec (Tensor): vector to be multiplied\n    beta (Number, optional): multiplier for :attr:`input` (:math:`\\beta`)\n    alpha (Number, optional): multiplier for :math:`mat @ vec` (:math:`\\alpha`)\n    {out}\n\nExample::\n\n    >>> M = torch.randn(2)\n    >>> mat = torch.randn(2, 3)\n    >>> vec = torch.randn(3)\n    >>> torch.addmv(M, mat, vec)\n    tensor([-0.3768, -5.5565])\n'.format(**common_args))
add_docstr(torch.addr, '\naddr(input, vec1, vec2, *, beta=1, alpha=1, out=None) -> Tensor\n\nPerforms the outer-product of vectors :attr:`vec1` and :attr:`vec2`\nand adds it to the matrix :attr:`input`.\n\nOptional values :attr:`beta` and :attr:`alpha` are scaling factors on the\nouter product between :attr:`vec1` and :attr:`vec2` and the added matrix\n:attr:`input` respectively.\n\n.. math::\n    \\text{out} = \\beta\\ \\text{input} + \\alpha\\ (\\text{vec1} \\otimes \\text{vec2})\n' + '\nIf :attr:`vec1` is a vector of size `n` and :attr:`vec2` is a vector\nof size `m`, then :attr:`input` must be\n:ref:`broadcastable <broadcasting-semantics>` with a matrix of size\n:math:`(n \\times m)` and :attr:`out` will be a matrix of size\n:math:`(n \\times m)`.\n\nFor inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and\n:attr:`alpha` must be real numbers, otherwise they should be integers\n\nArgs:\n    input (Tensor): matrix to be added\n    vec1 (Tensor): the first vector of the outer product\n    vec2 (Tensor): the second vector of the outer product\n    beta (Number, optional): multiplier for :attr:`input` (:math:`\\beta`)\n    alpha (Number, optional): multiplier for :math:`\\text{{vec1}} \\otimes \\text{{vec2}}` (:math:`\\alpha`)\n    {out}\n\nExample::\n\n    >>> vec1 = torch.arange(1., 4.)\n    >>> vec2 = torch.arange(1., 3.)\n    >>> M = torch.zeros(3, 2)\n    >>> torch.addr(M, vec1, vec2)\n    tensor([[ 1.,  2.],\n            [ 2.,  4.],\n            [ 3.,  6.]])\n'.format(**common_args))
add_docstr(torch.allclose, '\nallclose(input, other, rtol=1e-05, atol=1e-08, equal_nan=False) -> bool\n\nThis function checks if all :attr:`input` and :attr:`other` satisfy the condition:\n\n.. math::\n    \\lvert \\text{input} - \\text{other} \\rvert \\leq \\texttt{atol} + \\texttt{rtol} \\times \\lvert \\text{other} \\rvert\n' + "\nelementwise, for all elements of :attr:`input` and :attr:`other`. The behaviour of this function is analogous to\n`numpy.allclose <https://docs.scipy.org/doc/numpy/reference/generated/numpy.allclose.html>`_\n\nArgs:\n    input (Tensor): first tensor to compare\n    other (Tensor): second tensor to compare\n    atol (float, optional): absolute tolerance. Default: 1e-08\n    rtol (float, optional): relative tolerance. Default: 1e-05\n    equal_nan (bool, optional): if ``True``, then two ``NaN`` s will be compared as equal. Default: ``False``\n\nExample::\n\n    >>> torch.allclose(torch.tensor([10000., 1e-07]), torch.tensor([10000.1, 1e-08]))\n    False\n    >>> torch.allclose(torch.tensor([10000., 1e-08]), torch.tensor([10000.1, 1e-09]))\n    True\n    >>> torch.allclose(torch.tensor([1.0, float('nan')]), torch.tensor([1.0, float('nan')]))\n    False\n    >>> torch.allclose(torch.tensor([1.0, float('nan')]), torch.tensor([1.0, float('nan')]), equal_nan=True)\n    True\n")
add_docstr(torch.angle, '\nangle(input, out=None) -> Tensor\n\nComputes the element-wise angle (in radians) of the given :attr:`input` tensor.\n\n.. math::\n    \\text{out}_{i} = angle(\\text{input}_{i})\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> torch.angle(torch.tensor([-1 + 1j, -2 + 2j, 3 - 3j]))*180/3.14159\n    tensor([ 135.,  135,  -45])\n'.format(**common_args))
add_docstr(torch.as_strided, '\nas_strided(input, size, stride, storage_offset=0) -> Tensor\n\nCreate a view of an existing `torch.Tensor` :attr:`input` with specified\n:attr:`size`, :attr:`stride` and :attr:`storage_offset`.\n\n.. warning::\n    More than one element of a created tensor may refer to a single memory\n    location. As a result, in-place operations (especially ones that are\n    vectorized) may result in incorrect behavior. If you need to write to\n    the tensors, please clone them first.\n\n    Many PyTorch functions, which return a view of a tensor, are internally\n    implemented with this function. Those functions, like\n    :meth:`torch.Tensor.expand`, are easier to read and are therefore more\n    advisable to use.\n\n\nArgs:\n    {input}\n    size (tuple or ints): the shape of the output tensor\n    stride (tuple or ints): the stride of the output tensor\n    storage_offset (int, optional): the offset in the underlying storage of the output tensor\n\nExample::\n\n    >>> x = torch.randn(3, 3)\n    >>> x\n    tensor([[ 0.9039,  0.6291,  1.0795],\n            [ 0.1586,  2.1939, -0.4900],\n            [-0.1909, -0.7503,  1.9355]])\n    >>> t = torch.as_strided(x, (2, 2), (1, 2))\n    >>> t\n    tensor([[0.9039, 1.0795],\n            [0.6291, 0.1586]])\n    >>> t = torch.as_strided(x, (2, 2), (1, 2), 1)\n    tensor([[0.6291, 0.1586],\n            [1.0795, 2.1939]])\n'.format(**common_args))
add_docstr(torch.as_tensor, "\nas_tensor(data, dtype=None, device=None) -> Tensor\n\nConvert the data into a `torch.Tensor`. If the data is already a `Tensor` with the same `dtype` and `device`,\nno copy will be performed, otherwise a new `Tensor` will be returned with computational graph retained if data\n`Tensor` has ``requires_grad=True``. Similarly, if the data is an ``ndarray`` of the corresponding `dtype` and\nthe `device` is the cpu, no copy will be performed.\n\nArgs:\n    {data}\n    {dtype}\n    {device}\n\nExample::\n\n    >>> a = numpy.array([1, 2, 3])\n    >>> t = torch.as_tensor(a)\n    >>> t\n    tensor([ 1,  2,  3])\n    >>> t[0] = -1\n    >>> a\n    array([-1,  2,  3])\n\n    >>> a = numpy.array([1, 2, 3])\n    >>> t = torch.as_tensor(a, device=torch.device('cuda'))\n    >>> t\n    tensor([ 1,  2,  3])\n    >>> t[0] = -1\n    >>> a\n    array([1,  2,  3])\n".format(**factory_data_common_args))
add_docstr(torch.asin, '\nasin(input, out=None) -> Tensor\n\nReturns a new tensor with the arcsine  of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\sin^{-1}(\\text{input}_{i})\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-0.5962,  1.4985, -0.4396,  1.4525])\n    >>> torch.asin(a)\n    tensor([-0.6387,     nan, -0.4552,     nan])\n'.format(**common_args))
add_docstr(torch.atan, '\natan(input, out=None) -> Tensor\n\nReturns a new tensor with the arctangent  of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\tan^{-1}(\\text{input}_{i})\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.2341,  0.2539, -0.6256, -0.6448])\n    >>> torch.atan(a)\n    tensor([ 0.2299,  0.2487, -0.5591, -0.5727])\n'.format(**common_args))
add_docstr(torch.atan2, '\natan2(input, other, out=None) -> Tensor\n\nElement-wise arctangent of :math:`\\text{{input}}_{{i}} / \\text{{other}}_{{i}}`\nwith consideration of the quadrant. Returns a new tensor with the signed angles\nin radians between vector :math:`(\\text{{other}}_{{i}}, \\text{{input}}_{{i}})`\nand vector :math:`(1, 0)`. (Note that :math:`\\text{{other}}_{{i}}`, the second\nparameter, is the x-coordinate, while :math:`\\text{{input}}_{{i}}`, the first\nparameter, is the y-coordinate.)\n\nThe shapes of ``input`` and ``other`` must be\n:ref:`broadcastable <broadcasting-semantics>`.\n\nArgs:\n    input (Tensor): the first input tensor\n    other (Tensor): the second input tensor\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.9041,  0.0196, -0.3108, -2.4423])\n    >>> torch.atan2(a, torch.randn(4))\n    tensor([ 0.9833,  0.0811, -1.9743, -1.4151])\n'.format(**common_args))
add_docstr(torch.baddbmm, '\nbaddbmm(input, batch1, batch2, *, beta=1, alpha=1, out=None) -> Tensor\n\nPerforms a batch matrix-matrix product of matrices in :attr:`batch1`\nand :attr:`batch2`.\n:attr:`input` is added to the final result.\n\n:attr:`batch1` and :attr:`batch2` must be 3-D tensors each containing the same\nnumber of matrices.\n\nIf :attr:`batch1` is a :math:`(b \\times n \\times m)` tensor, :attr:`batch2` is a\n:math:`(b \\times m \\times p)` tensor, then :attr:`input` must be\n:ref:`broadcastable <broadcasting-semantics>` with a\n:math:`(b \\times n \\times p)` tensor and :attr:`out` will be a\n:math:`(b \\times n \\times p)` tensor. Both :attr:`alpha` and :attr:`beta` mean the\nsame as the scaling factors used in :meth:`torch.addbmm`.\n\n.. math::\n    \\text{out}_i = \\beta\\ \\text{input}_i + \\alpha\\ (\\text{batch1}_i \\mathbin{@} \\text{batch2}_i)\n' + '\nFor inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and\n:attr:`alpha` must be real numbers, otherwise they should be integers.\n\nArgs:\n    input (Tensor): the tensor to be added\n    batch1 (Tensor): the first batch of matrices to be multiplied\n    batch2 (Tensor): the second batch of matrices to be multiplied\n    beta (Number, optional): multiplier for :attr:`input` (:math:`\\beta`)\n    alpha (Number, optional): multiplier for :math:`\\text{{batch1}} \\mathbin{{@}} \\text{{batch2}}` (:math:`\\alpha`)\n    {out}\n\nExample::\n\n    >>> M = torch.randn(10, 3, 5)\n    >>> batch1 = torch.randn(10, 3, 4)\n    >>> batch2 = torch.randn(10, 4, 5)\n    >>> torch.baddbmm(M, batch1, batch2).size()\n    torch.Size([10, 3, 5])\n'.format(**common_args))
add_docstr(torch.bernoulli, '\nbernoulli(input, *, generator=None, out=None) -> Tensor\n\nDraws binary random numbers (0 or 1) from a Bernoulli distribution.\n\nThe :attr:`input` tensor should be a tensor containing probabilities\nto be used for drawing the binary random number.\nHence, all values in :attr:`input` have to be in the range:\n:math:`0 \\leq \\text{input}_i \\leq 1`.\n\nThe :math:`\\text{i}^{th}` element of the output tensor will draw a\nvalue :math:`1` according to the :math:`\\text{i}^{th}` probability value given\nin :attr:`input`.\n\n.. math::\n    \\text{out}_{i} \\sim \\mathrm{Bernoulli}(p = \\text{input}_{i})\n' + '\nThe returned :attr:`out` tensor only has values 0 or 1 and is of the same\nshape as :attr:`input`.\n\n:attr:`out` can have integral ``dtype``, but :attr:`input` must have floating\npoint ``dtype``.\n\nArgs:\n    input (Tensor): the input tensor of probability values for the Bernoulli distribution\n    {generator}\n    {out}\n\nExample::\n\n    >>> a = torch.empty(3, 3).uniform_(0, 1)  # generate a uniform random matrix with range [0, 1]\n    >>> a\n    tensor([[ 0.1737,  0.0950,  0.3609],\n            [ 0.7148,  0.0289,  0.2676],\n            [ 0.9456,  0.8937,  0.7202]])\n    >>> torch.bernoulli(a)\n    tensor([[ 1.,  0.,  0.],\n            [ 0.,  0.,  0.],\n            [ 1.,  1.,  1.]])\n\n    >>> a = torch.ones(3, 3) # probability of drawing "1" is 1\n    >>> torch.bernoulli(a)\n    tensor([[ 1.,  1.,  1.],\n            [ 1.,  1.,  1.],\n            [ 1.,  1.,  1.]])\n    >>> a = torch.zeros(3, 3) # probability of drawing "1" is 0\n    >>> torch.bernoulli(a)\n    tensor([[ 0.,  0.,  0.],\n            [ 0.,  0.,  0.],\n            [ 0.,  0.,  0.]])\n'.format(**common_args))
add_docstr(torch.bincount, '\nbincount(input, weights=None, minlength=0) -> Tensor\n\nCount the frequency of each value in an array of non-negative ints.\n\nThe number of bins (size 1) is one larger than the largest value in\n:attr:`input` unless :attr:`input` is empty, in which case the result is a\ntensor of size 0. If :attr:`minlength` is specified, the number of bins is at least\n:attr:`minlength` and if :attr:`input` is empty, then the result is tensor of size\n:attr:`minlength` filled with zeros. If ``n`` is the value at position ``i``,\n``out[n] += weights[i]`` if :attr:`weights` is specified else\n``out[n] += 1``.\n\n.. include:: cuda_deterministic.rst\n\nArguments:\n    input (Tensor): 1-d int tensor\n    weights (Tensor): optional, weight for each value in the input tensor.\n        Should be of same size as input tensor.\n    minlength (int): optional, minimum number of bins. Should be non-negative.\n\nReturns:\n    output (Tensor): a tensor of shape ``Size([max(input) + 1])`` if\n    :attr:`input` is non-empty, else ``Size(0)``\n\nExample::\n\n    >>> input = torch.randint(0, 8, (5,), dtype=torch.int64)\n    >>> weights = torch.linspace(0, 1, steps=5)\n    >>> input, weights\n    (tensor([4, 3, 6, 3, 4]),\n     tensor([ 0.0000,  0.2500,  0.5000,  0.7500,  1.0000])\n\n    >>> torch.bincount(input)\n    tensor([0, 0, 0, 2, 2, 0, 1])\n\n    >>> input.bincount(weights)\n    tensor([0.0000, 0.0000, 0.0000, 1.0000, 1.0000, 0.0000, 0.5000])\n')
add_docstr(torch.bitwise_not, '\nbitwise_not(input, out=None) -> Tensor\n\nComputes the bitwise NOT of the given input tensor. The input tensor must be of\nintegral or Boolean types. For bool tensors, it computes the logical NOT.\n\nArgs:\n    {input}\n    {out}\n\nExample:\n\n    >>> torch.bitwise_not(torch.tensor([-1, -2, 3], dtype=torch.int8))\n    tensor([ 0,  1, -4], dtype=torch.int8)\n'.format(**common_args))
add_docstr(torch.bmm, '\nbmm(input, mat2, out=None) -> Tensor\n\nPerforms a batch matrix-matrix product of matrices stored in :attr:`input`\nand :attr:`mat2`.\n\n:attr:`input` and :attr:`mat2` must be 3-D tensors each containing\nthe same number of matrices.\n\nIf :attr:`input` is a :math:`(b \\times n \\times m)` tensor, :attr:`mat2` is a\n:math:`(b \\times m \\times p)` tensor, :attr:`out` will be a\n:math:`(b \\times n \\times p)` tensor.\n\n.. math::\n    \\text{out}_i = \\text{input}_i \\mathbin{@} \\text{mat2}_i\n' + '\n.. note:: This function does not :ref:`broadcast <broadcasting-semantics>`.\n          For broadcasting matrix products, see :func:`torch.matmul`.\n\nArgs:\n    input (Tensor): the first batch of matrices to be multiplied\n    mat2 (Tensor): the second batch of matrices to be multiplied\n    {out}\n\nExample::\n\n    >>> input = torch.randn(10, 3, 4)\n    >>> mat2 = torch.randn(10, 4, 5)\n    >>> res = torch.bmm(input, mat2)\n    >>> res.size()\n    torch.Size([10, 3, 5])\n'.format(**common_args))
add_docstr(torch.bitwise_and, '\nbitwise_and(input, other, out=None) -> Tensor\n\nComputes the bitwise AND of :attr:`input` and :attr:`other`. The input tensor must be of\nintegral or Boolean types. For bool tensors, it computes the logical AND.\n\nArgs:\n    input: the first input tensor\n    other: the second input tensor\n    {out}\n\nExample:\n\n    >>> torch.bitwise_and(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))\n    tensor([1, 0,  3], dtype=torch.int8)\n    >>> torch.bitwise_and(torch.tensor([True, True, False]), torch.tensor([False, True, False]))\n    tensor([ False, True, False])\n'.format(**common_args))
add_docstr(torch.bitwise_or, '\nbitwise_or(input, other, out=None) -> Tensor\n\nComputes the bitwise OR of :attr:`input` and :attr:`other`. The input tensor must be of\nintegral or Boolean types. For bool tensors, it computes the logical OR.\n\nArgs:\n    input: the first input tensor\n    other: the second input tensor\n    {out}\n\nExample:\n\n    >>> torch.bitwise_or(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))\n    tensor([-1, -2,  3], dtype=torch.int8)\n    >>> torch.bitwise_or(torch.tensor([True, True, False]), torch.tensor([False, True, False]))\n    tensor([ True, True, False])\n'.format(**common_args))
add_docstr(torch.bitwise_xor, '\nbitwise_xor(input, other, out=None) -> Tensor\n\nComputes the bitwise XOR of :attr:`input` and :attr:`other`. The input tensor must be of\nintegral or Boolean types. For bool tensors, it computes the logical XOR.\n\nArgs:\n    input: the first input tensor\n    other: the second input tensor\n    {out}\n\nExample:\n\n    >>> torch.bitwise_xor(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))\n    tensor([-2, -2,  0], dtype=torch.int8)\n    >>> torch.bitwise_xor(torch.tensor([True, True, False]), torch.tensor([False, True, False]))\n    tensor([ True, False, False])\n'.format(**common_args))
add_docstr(torch.stack, '\nstack(tensors, dim=0, out=None) -> Tensor\n\nConcatenates sequence of tensors along a new dimension.\n\nAll tensors need to be of the same size.\n\nArguments:\n    tensors (sequence of Tensors): sequence of tensors to concatenate\n    dim (int): dimension to insert. Has to be between 0 and the number\n        of dimensions of concatenated tensors (inclusive)\n    {out}\n'.format(**common_args))
add_docstr(torch.chunk, '\nchunk(input, chunks, dim=0) -> List of Tensors\n\nSplits a tensor into a specific number of chunks. Each chunk is a view of\nthe input tensor.\n\nLast chunk will be smaller if the tensor size along the given dimension\n:attr:`dim` is not divisible by :attr:`chunks`.\n\nArguments:\n    input (Tensor): the tensor to split\n    chunks (int): number of chunks to return\n    dim (int): dimension along which to split the tensor\n')
add_docstr(torch.can_cast, '\ncan_cast(from, to) -> bool\n\nDetermines if a type conversion is allowed under PyTorch casting rules\ndescribed in the type promotion :ref:`documentation <type-promotion-doc>`.\n\nArgs:\n    from (dtype): The original :class:`torch.dtype`.\n    to (dtype): The target :class:`torch.dtype`.\n\nExample::\n\n    >>> torch.can_cast(torch.double, torch.float)\n    True\n    >>> torch.can_cast(torch.float, torch.int)\n    False\n')
add_docstr(torch.cat, '\ncat(tensors, dim=0, out=None) -> Tensor\n\nConcatenates the given sequence of :attr:`seq` tensors in the given dimension.\nAll tensors must either have the same shape (except in the concatenating\ndimension) or be empty.\n\n:func:`torch.cat` can be seen as an inverse operation for :func:`torch.split`\nand :func:`torch.chunk`.\n\n:func:`torch.cat` can be best understood via examples.\n\nArgs:\n    tensors (sequence of Tensors): any python sequence of tensors of the same type.\n        Non-empty tensors provided must have the same shape, except in the\n        cat dimension.\n    dim (int, optional): the dimension over which the tensors are concatenated\n    {out}\n\nExample::\n\n    >>> x = torch.randn(2, 3)\n    >>> x\n    tensor([[ 0.6580, -1.0969, -0.4614],\n            [-0.1034, -0.5790,  0.1497]])\n    >>> torch.cat((x, x, x), 0)\n    tensor([[ 0.6580, -1.0969, -0.4614],\n            [-0.1034, -0.5790,  0.1497],\n            [ 0.6580, -1.0969, -0.4614],\n            [-0.1034, -0.5790,  0.1497],\n            [ 0.6580, -1.0969, -0.4614],\n            [-0.1034, -0.5790,  0.1497]])\n    >>> torch.cat((x, x, x), 1)\n    tensor([[ 0.6580, -1.0969, -0.4614,  0.6580, -1.0969, -0.4614,  0.6580,\n             -1.0969, -0.4614],\n            [-0.1034, -0.5790,  0.1497, -0.1034, -0.5790,  0.1497, -0.1034,\n             -0.5790,  0.1497]])\n'.format(**common_args))
add_docstr(torch.ceil, '\nceil(input, out=None) -> Tensor\n\nReturns a new tensor with the ceil of the elements of :attr:`input`,\nthe smallest integer greater than or equal to each element.\n\n.. math::\n    \\text{out}_{i} = \\left\\lceil \\text{input}_{i} \\right\\rceil = \\left\\lfloor \\text{input}_{i} \\right\\rfloor + 1\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-0.6341, -1.4208, -1.0900,  0.5826])\n    >>> torch.ceil(a)\n    tensor([-0., -1., -1.,  1.])\n'.format(**common_args))
add_docstr(torch.real, '\nreal(input, out=None) -> Tensor\n\nReturns the real part of the :attr:`input` tensor. If\n:attr:`input` is a real (non-complex) tensor, this function just\nreturns it.\n\n.. warning::\n    Not yet implemented for complex tensors.\n\n.. math::\n    \\text{out}_{i} = real(\\text{input}_{i})\n' + '\nArgs:\n    {input}\n    {out}\n'.format(**common_args))
add_docstr(torch.reciprocal, '\nreciprocal(input, out=None) -> Tensor\n\nReturns a new tensor with the reciprocal of the elements of :attr:`input`\n\n.. math::\n    \\text{out}_{i} = \\frac{1}{\\text{input}_{i}}\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-0.4595, -2.1219, -1.4314,  0.7298])\n    >>> torch.reciprocal(a)\n    tensor([-2.1763, -0.4713, -0.6986,  1.3702])\n'.format(**common_args))
add_docstr(torch.cholesky, '\ncholesky(input, upper=False, out=None) -> Tensor\n\nComputes the Cholesky decomposition of a symmetric positive-definite\nmatrix :math:`A` or for batches of symmetric positive-definite matrices.\n\nIf :attr:`upper` is ``True``, the returned matrix ``U`` is upper-triangular, and\nthe decomposition has the form:\n\n.. math::\n\n  A = U^TU\n\nIf :attr:`upper` is ``False``, the returned matrix ``L`` is lower-triangular, and\nthe decomposition has the form:\n\n.. math::\n\n    A = LL^T\n\nIf :attr:`upper` is ``True``, and :math:`A` is a batch of symmetric positive-definite\nmatrices, then the returned tensor will be composed of upper-triangular Cholesky factors\nof each of the individual matrices. Similarly, when :attr:`upper` is ``False``, the returned\ntensor will be composed of lower-triangular Cholesky factors of each of the individual\nmatrices.\n\nArgs:\n    input (Tensor): the input tensor :math:`A` of size :math:`(*, n, n)` where `*` is zero or more\n                batch dimensions consisting of symmetric positive-definite matrices.\n    upper (bool, optional): flag that indicates whether to return a\n                            upper or lower triangular matrix. Default: ``False``\n    out (Tensor, optional): the output matrix\n\nExample::\n\n    >>> a = torch.randn(3, 3)\n    >>> a = torch.mm(a, a.t()) # make symmetric positive-definite\n    >>> l = torch.cholesky(a)\n    >>> a\n    tensor([[ 2.4112, -0.7486,  1.4551],\n            [-0.7486,  1.3544,  0.1294],\n            [ 1.4551,  0.1294,  1.6724]])\n    >>> l\n    tensor([[ 1.5528,  0.0000,  0.0000],\n            [-0.4821,  1.0592,  0.0000],\n            [ 0.9371,  0.5487,  0.7023]])\n    >>> torch.mm(l, l.t())\n    tensor([[ 2.4112, -0.7486,  1.4551],\n            [-0.7486,  1.3544,  0.1294],\n            [ 1.4551,  0.1294,  1.6724]])\n    >>> a = torch.randn(3, 2, 2)\n    >>> a = torch.matmul(a, a.transpose(-1, -2)) + 1e-03 # make symmetric positive-definite\n    >>> l = torch.cholesky(a)\n    >>> z = torch.matmul(l, l.transpose(-1, -2))\n    >>> torch.max(torch.abs(z - a)) # Max non-zero\n    tensor(2.3842e-07)\n')
add_docstr(torch.cholesky_solve, '\ncholesky_solve(input, input2, upper=False, out=None) -> Tensor\n\nSolves a linear system of equations with a positive semidefinite\nmatrix to be inverted given its Cholesky factor matrix :math:`u`.\n\nIf :attr:`upper` is ``False``, :math:`u` is and lower triangular and `c` is\nreturned such that:\n\n.. math::\n    c = (u u^T)^{{-1}} b\n\nIf :attr:`upper` is ``True`` or not provided, :math:`u` is upper triangular\nand `c` is returned such that:\n\n.. math::\n    c = (u^T u)^{{-1}} b\n\n`torch.cholesky_solve(b, u)` can take in 2D inputs `b, u` or inputs that are\nbatches of 2D matrices. If the inputs are batches, then returns\nbatched outputs `c`\n\nArgs:\n    input (Tensor): input matrix :math:`b` of size :math:`(*, m, k)`,\n                where :math:`*` is zero or more batch dimensions\n    input2 (Tensor): input matrix :math:`u` of size :math:`(*, m, m)`,\n                where :math:`*` is zero of more batch dimensions composed of\n                upper or lower triangular Cholesky factor\n    upper (bool, optional): whether to consider the Cholesky factor as a\n                            lower or upper triangular matrix. Default: ``False``.\n    out (Tensor, optional): the output tensor for `c`\n\nExample::\n\n    >>> a = torch.randn(3, 3)\n    >>> a = torch.mm(a, a.t()) # make symmetric positive definite\n    >>> u = torch.cholesky(a)\n    >>> a\n    tensor([[ 0.7747, -1.9549,  1.3086],\n            [-1.9549,  6.7546, -5.4114],\n            [ 1.3086, -5.4114,  4.8733]])\n    >>> b = torch.randn(3, 2)\n    >>> b\n    tensor([[-0.6355,  0.9891],\n            [ 0.1974,  1.4706],\n            [-0.4115, -0.6225]])\n    >>> torch.cholesky_solve(b, u)\n    tensor([[ -8.1625,  19.6097],\n            [ -5.8398,  14.2387],\n            [ -4.3771,  10.4173]])\n    >>> torch.mm(a.inverse(), b)\n    tensor([[ -8.1626,  19.6097],\n            [ -5.8398,  14.2387],\n            [ -4.3771,  10.4173]])\n')
add_docstr(torch.cholesky_inverse, '\ncholesky_inverse(input, upper=False, out=None) -> Tensor\n\nComputes the inverse of a symmetric positive-definite matrix :math:`A` using its\nCholesky factor :math:`u`: returns matrix ``inv``. The inverse is computed using\nLAPACK routines ``dpotri`` and ``spotri`` (and the corresponding MAGMA routines).\n\nIf :attr:`upper` is ``False``, :math:`u` is lower triangular\nsuch that the returned tensor is\n\n.. math::\n    inv = (uu^{{T}})^{{-1}}\n\nIf :attr:`upper` is ``True`` or not provided, :math:`u` is upper\ntriangular such that the returned tensor is\n\n.. math::\n    inv = (u^T u)^{{-1}}\n\nArgs:\n    input (Tensor): the input 2-D tensor :math:`u`, a upper or lower triangular\n           Cholesky factor\n    upper (bool, optional): whether to return a lower (default) or upper triangular matrix\n    out (Tensor, optional): the output tensor for `inv`\n\nExample::\n\n    >>> a = torch.randn(3, 3)\n    >>> a = torch.mm(a, a.t()) + 1e-05 * torch.eye(3) # make symmetric positive definite\n    >>> u = torch.cholesky(a)\n    >>> a\n    tensor([[  0.9935,  -0.6353,   1.5806],\n            [ -0.6353,   0.8769,  -1.7183],\n            [  1.5806,  -1.7183,  10.6618]])\n    >>> torch.cholesky_inverse(u)\n    tensor([[ 1.9314,  1.2251, -0.0889],\n            [ 1.2251,  2.4439,  0.2122],\n            [-0.0889,  0.2122,  0.1412]])\n    >>> a.inverse()\n    tensor([[ 1.9314,  1.2251, -0.0889],\n            [ 1.2251,  2.4439,  0.2122],\n            [-0.0889,  0.2122,  0.1412]])\n')
add_docstr(torch.clamp, '\nclamp(input, min, max, out=None) -> Tensor\n\nClamp all elements in :attr:`input` into the range `[` :attr:`min`, :attr:`max` `]` and return\na resulting tensor:\n\n.. math::\n    y_i = \\begin{cases}\n        \\text{min} & \\text{if } x_i < \\text{min} \\\\\n        x_i & \\text{if } \\text{min} \\leq x_i \\leq \\text{max} \\\\\n        \\text{max} & \\text{if } x_i > \\text{max}\n    \\end{cases}\n' + '\nIf :attr:`input` is of type `FloatTensor` or `DoubleTensor`, args :attr:`min`\nand :attr:`max` must be real numbers, otherwise they should be integers.\n\nArgs:\n    {input}\n    min (Number): lower-bound of the range to be clamped to\n    max (Number): upper-bound of the range to be clamped to\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-1.7120,  0.1734, -0.0478, -0.0922])\n    >>> torch.clamp(a, min=-0.5, max=0.5)\n    tensor([-0.5000,  0.1734, -0.0478, -0.0922])\n\n.. function:: clamp(input, *, min, out=None) -> Tensor\n\nClamps all elements in :attr:`input` to be larger or equal :attr:`min`.\n\nIf :attr:`input` is of type `FloatTensor` or `DoubleTensor`, :attr:`value`\nshould be a real number, otherwise it should be an integer.\n\nArgs:\n    {input}\n    value (Number): minimal value of each element in the output\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-0.0299, -2.3184,  2.1593, -0.8883])\n    >>> torch.clamp(a, min=0.5)\n    tensor([ 0.5000,  0.5000,  2.1593,  0.5000])\n\n.. function:: clamp(input, *, max, out=None) -> Tensor\n\nClamps all elements in :attr:`input` to be smaller or equal :attr:`max`.\n\nIf :attr:`input` is of type `FloatTensor` or `DoubleTensor`, :attr:`value`\nshould be a real number, otherwise it should be an integer.\n\nArgs:\n    {input}\n    value (Number): maximal value of each element in the output\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.7753, -0.4702, -0.4599,  1.1899])\n    >>> torch.clamp(a, max=0.5)\n    tensor([ 0.5000, -0.4702, -0.4599,  0.5000])\n'.format(**common_args))
add_docstr(torch.conj, '\nconj(input, out=None) -> Tensor\n\nComputes the element-wise conjugate of the given :attr:`input` tensor.\n\n.. math::\n    \\text{out}_{i} = conj(\\text{input}_{i})\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> torch.conj(torch.tensor([-1 + 1j, -2 + 2j, 3 - 3j]))\n    tensor([-1 - 1j, -2 - 2j, 3 + 3j])\n'.format(**common_args))
add_docstr(torch.cos, '\ncos(input, out=None) -> Tensor\n\nReturns a new tensor with the cosine  of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\cos(\\text{input}_{i})\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 1.4309,  1.2706, -0.8562,  0.9796])\n    >>> torch.cos(a)\n    tensor([ 0.1395,  0.2957,  0.6553,  0.5574])\n'.format(**common_args))
add_docstr(torch.cosh, '\ncosh(input, out=None) -> Tensor\n\nReturns a new tensor with the hyperbolic cosine  of the elements of\n:attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\cosh(\\text{input}_{i})\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.1632,  1.1835, -0.6979, -0.7325])\n    >>> torch.cosh(a)\n    tensor([ 1.0133,  1.7860,  1.2536,  1.2805])\n'.format(**common_args))
add_docstr(torch.cross, '\ncross(input, other, dim=-1, out=None) -> Tensor\n\n\nReturns the cross product of vectors in dimension :attr:`dim` of :attr:`input`\nand :attr:`other`.\n\n:attr:`input` and :attr:`other` must have the same size, and the size of their\n:attr:`dim` dimension should be 3.\n\nIf :attr:`dim` is not given, it defaults to the first dimension found with the\nsize 3.\n\nArgs:\n    {input}\n    other (Tensor): the second input tensor\n    dim  (int, optional): the dimension to take the cross-product in.\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4, 3)\n    >>> a\n    tensor([[-0.3956,  1.1455,  1.6895],\n            [-0.5849,  1.3672,  0.3599],\n            [-1.1626,  0.7180, -0.0521],\n            [-0.1339,  0.9902, -2.0225]])\n    >>> b = torch.randn(4, 3)\n    >>> b\n    tensor([[-0.0257, -1.4725, -1.2251],\n            [-1.1479, -0.7005, -1.9757],\n            [-1.3904,  0.3726, -1.1836],\n            [-0.9688, -0.7153,  0.2159]])\n    >>> torch.cross(a, b, dim=1)\n    tensor([[ 1.0844, -0.5281,  0.6120],\n            [-2.4490, -1.5687,  1.9792],\n            [-0.8304, -1.3037,  0.5650],\n            [-1.2329,  1.9883,  1.0551]])\n    >>> torch.cross(a, b)\n    tensor([[ 1.0844, -0.5281,  0.6120],\n            [-2.4490, -1.5687,  1.9792],\n            [-0.8304, -1.3037,  0.5650],\n            [-1.2329,  1.9883,  1.0551]])\n'.format(**common_args))
add_docstr(torch.cummax, '\ncummax(input, dim, out=None) -> (Tensor, LongTensor)\nReturns a namedtuple ``(values, indices)`` where ``values`` is the cumulative maximum of\nelements of :attr:`input` in the dimension :attr:`dim`. And ``indices`` is the index\nlocation of each maximum value found in the dimension :attr:`dim`.\n\n.. math::\n    y_i = max(x_1, x_2, x_3, \\dots, x_i)\n\nArgs:\n    {input}\n    dim  (int): the dimension to do the operation over\n    out (tuple, optional): the result tuple of two output tensors (values, indices)\n\nExample::\n\n    >>> a = torch.randn(10)\n    >>> a\n    tensor([-0.3449, -1.5447,  0.0685, -1.5104, -1.1706,  0.2259,  1.4696, -1.3284,\n         1.9946, -0.8209])\n    >>> torch.cummax(a, dim=0)\n    torch.return_types.cummax(\n        values=tensor([-0.3449, -0.3449,  0.0685,  0.0685,  0.0685,  0.2259,  1.4696,  1.4696,\n         1.9946,  1.9946]),\n        indices=tensor([0, 0, 2, 2, 2, 5, 6, 6, 8, 8]))\n'.format(**reduceops_common_args))
add_docstr(torch.cummin, '\ncummin(input, dim, out=None) -> (Tensor, LongTensor)\nReturns a namedtuple ``(values, indices)`` where ``values`` is the cumulative minimum of\nelements of :attr:`input` in the dimension :attr:`dim`. And ``indices`` is the index\nlocation of each maximum value found in the dimension :attr:`dim`.\n\n.. math::\n    y_i = min(x_1, x_2, x_3, \\dots, x_i)\n\nArgs:\n    {input}\n    dim  (int): the dimension to do the operation over\n    out (tuple, optional): the result tuple of two output tensors (values, indices)\n\nExample::\n\n    >>> a = torch.randn(10)\n    >>> a\n    tensor([-0.2284, -0.6628,  0.0975,  0.2680, -1.3298, -0.4220, -0.3885,  1.1762,\n         0.9165,  1.6684])\n    >>> torch.cummin(a, dim=0)\n    torch.return_types.cummin(\n        values=tensor([-0.2284, -0.6628, -0.6628, -0.6628, -1.3298, -1.3298, -1.3298, -1.3298,\n        -1.3298, -1.3298]),\n        indices=tensor([0, 1, 1, 1, 4, 4, 4, 4, 4, 4]))\n'.format(**reduceops_common_args))
add_docstr(torch.cumprod, '\ncumprod(input, dim, out=None, dtype=None) -> Tensor\n\nReturns the cumulative product of elements of :attr:`input` in the dimension\n:attr:`dim`.\n\nFor example, if :attr:`input` is a vector of size N, the result will also be\na vector of size N, with elements.\n\n.. math::\n    y_i = x_1 \\times x_2\\times x_3\\times \\dots \\times x_i\n\nArgs:\n    {input}\n    dim  (int): the dimension to do the operation over\n    {dtype}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(10)\n    >>> a\n    tensor([ 0.6001,  0.2069, -0.1919,  0.9792,  0.6727,  1.0062,  0.4126,\n            -0.2129, -0.4206,  0.1968])\n    >>> torch.cumprod(a, dim=0)\n    tensor([ 0.6001,  0.1241, -0.0238, -0.0233, -0.0157, -0.0158, -0.0065,\n             0.0014, -0.0006, -0.0001])\n\n    >>> a[5] = 0.0\n    >>> torch.cumprod(a, dim=0)\n    tensor([ 0.6001,  0.1241, -0.0238, -0.0233, -0.0157, -0.0000, -0.0000,\n             0.0000, -0.0000, -0.0000])\n'.format(**reduceops_common_args))
add_docstr(torch.cumsum, '\ncumsum(input, dim, out=None, dtype=None) -> Tensor\n\nReturns the cumulative sum of elements of :attr:`input` in the dimension\n:attr:`dim`.\n\nFor example, if :attr:`input` is a vector of size N, the result will also be\na vector of size N, with elements.\n\n.. math::\n    y_i = x_1 + x_2 + x_3 + \\dots + x_i\n\nArgs:\n    {input}\n    dim  (int): the dimension to do the operation over\n    {dtype}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(10)\n    >>> a\n    tensor([-0.8286, -0.4890,  0.5155,  0.8443,  0.1865, -0.1752, -2.0595,\n             0.1850, -1.1571, -0.4243])\n    >>> torch.cumsum(a, dim=0)\n    tensor([-0.8286, -1.3175, -0.8020,  0.0423,  0.2289,  0.0537, -2.0058,\n            -1.8209, -2.9780, -3.4022])\n'.format(**reduceops_common_args))
add_docstr(torch.diag, '\ndiag(input, diagonal=0, out=None) -> Tensor\n\n- If :attr:`input` is a vector (1-D tensor), then returns a 2-D square tensor\n  with the elements of :attr:`input` as the diagonal.\n- If :attr:`input` is a matrix (2-D tensor), then returns a 1-D tensor with\n  the diagonal elements of :attr:`input`.\n\nThe argument :attr:`diagonal` controls which diagonal to consider:\n\n- If :attr:`diagonal` = 0, it is the main diagonal.\n- If :attr:`diagonal` > 0, it is above the main diagonal.\n- If :attr:`diagonal` < 0, it is below the main diagonal.\n\nArgs:\n    {input}\n    diagonal (int, optional): the diagonal to consider\n    {out}\n\n.. seealso::\n\n        :func:`torch.diagonal` always returns the diagonal of its input.\n\n        :func:`torch.diagflat` always constructs a tensor with diagonal elements\n        specified by the input.\n\nExamples:\n\nGet the square matrix where the input vector is the diagonal::\n\n    >>> a = torch.randn(3)\n    >>> a\n    tensor([ 0.5950,-0.0872, 2.3298])\n    >>> torch.diag(a)\n    tensor([[ 0.5950, 0.0000, 0.0000],\n            [ 0.0000,-0.0872, 0.0000],\n            [ 0.0000, 0.0000, 2.3298]])\n    >>> torch.diag(a, 1)\n    tensor([[ 0.0000, 0.5950, 0.0000, 0.0000],\n            [ 0.0000, 0.0000,-0.0872, 0.0000],\n            [ 0.0000, 0.0000, 0.0000, 2.3298],\n            [ 0.0000, 0.0000, 0.0000, 0.0000]])\n\nGet the k-th diagonal of a given matrix::\n\n    >>> a = torch.randn(3, 3)\n    >>> a\n    tensor([[-0.4264, 0.0255,-0.1064],\n            [ 0.8795,-0.2429, 0.1374],\n            [ 0.1029,-0.6482,-1.6300]])\n    >>> torch.diag(a, 0)\n    tensor([-0.4264,-0.2429,-1.6300])\n    >>> torch.diag(a, 1)\n    tensor([ 0.0255, 0.1374])\n'.format(**common_args))
add_docstr(torch.diag_embed, '\ndiag_embed(input, offset=0, dim1=-2, dim2=-1) -> Tensor\n\nCreates a tensor whose diagonals of certain 2D planes (specified by\n:attr:`dim1` and :attr:`dim2`) are filled by :attr:`input`.\nTo facilitate creating batched diagonal matrices, the 2D planes formed by\nthe last two dimensions of the returned tensor are chosen by default.\n\nThe argument :attr:`offset` controls which diagonal to consider:\n\n- If :attr:`offset` = 0, it is the main diagonal.\n- If :attr:`offset` > 0, it is above the main diagonal.\n- If :attr:`offset` < 0, it is below the main diagonal.\n\nThe size of the new matrix will be calculated to make the specified diagonal\nof the size of the last input dimension.\nNote that for :attr:`offset` other than :math:`0`, the order of :attr:`dim1`\nand :attr:`dim2` matters. Exchanging them is equivalent to changing the\nsign of :attr:`offset`.\n\nApplying :meth:`torch.diagonal` to the output of this function with\nthe same arguments yields a matrix identical to input. However,\n:meth:`torch.diagonal` has different default dimensions, so those\nneed to be explicitly specified.\n\nArgs:\n    {input} Must be at least 1-dimensional.\n    offset (int, optional): which diagonal to consider. Default: 0\n        (main diagonal).\n    dim1 (int, optional): first dimension with respect to which to\n        take diagonal. Default: -2.\n    dim2 (int, optional): second dimension with respect to which to\n        take diagonal. Default: -1.\n\nExample::\n\n    >>> a = torch.randn(2, 3)\n    >>> torch.diag_embed(a)\n    tensor([[[ 1.5410,  0.0000,  0.0000],\n             [ 0.0000, -0.2934,  0.0000],\n             [ 0.0000,  0.0000, -2.1788]],\n\n            [[ 0.5684,  0.0000,  0.0000],\n             [ 0.0000, -1.0845,  0.0000],\n             [ 0.0000,  0.0000, -1.3986]]])\n\n    >>> torch.diag_embed(a, offset=1, dim1=0, dim2=2)\n    tensor([[[ 0.0000,  1.5410,  0.0000,  0.0000],\n             [ 0.0000,  0.5684,  0.0000,  0.0000]],\n\n            [[ 0.0000,  0.0000, -0.2934,  0.0000],\n             [ 0.0000,  0.0000, -1.0845,  0.0000]],\n\n            [[ 0.0000,  0.0000,  0.0000, -2.1788],\n             [ 0.0000,  0.0000,  0.0000, -1.3986]],\n\n            [[ 0.0000,  0.0000,  0.0000,  0.0000],\n             [ 0.0000,  0.0000,  0.0000,  0.0000]]])\n'.format(**common_args))
add_docstr(torch.diagflat, '\ndiagflat(input, offset=0) -> Tensor\n\n- If :attr:`input` is a vector (1-D tensor), then returns a 2-D square tensor\n  with the elements of :attr:`input` as the diagonal.\n- If :attr:`input` is a tensor with more than one dimension, then returns a\n  2-D tensor with diagonal elements equal to a flattened :attr:`input`.\n\nThe argument :attr:`offset` controls which diagonal to consider:\n\n- If :attr:`offset` = 0, it is the main diagonal.\n- If :attr:`offset` > 0, it is above the main diagonal.\n- If :attr:`offset` < 0, it is below the main diagonal.\n\nArgs:\n    {input}\n    offset (int, optional): the diagonal to consider. Default: 0 (main\n        diagonal).\n\nExamples::\n\n    >>> a = torch.randn(3)\n    >>> a\n    tensor([-0.2956, -0.9068,  0.1695])\n    >>> torch.diagflat(a)\n    tensor([[-0.2956,  0.0000,  0.0000],\n            [ 0.0000, -0.9068,  0.0000],\n            [ 0.0000,  0.0000,  0.1695]])\n    >>> torch.diagflat(a, 1)\n    tensor([[ 0.0000, -0.2956,  0.0000,  0.0000],\n            [ 0.0000,  0.0000, -0.9068,  0.0000],\n            [ 0.0000,  0.0000,  0.0000,  0.1695],\n            [ 0.0000,  0.0000,  0.0000,  0.0000]])\n\n    >>> a = torch.randn(2, 2)\n    >>> a\n    tensor([[ 0.2094, -0.3018],\n            [-0.1516,  1.9342]])\n    >>> torch.diagflat(a)\n    tensor([[ 0.2094,  0.0000,  0.0000,  0.0000],\n            [ 0.0000, -0.3018,  0.0000,  0.0000],\n            [ 0.0000,  0.0000, -0.1516,  0.0000],\n            [ 0.0000,  0.0000,  0.0000,  1.9342]])\n'.format(**common_args))
add_docstr(torch.diagonal, '\ndiagonal(input, offset=0, dim1=0, dim2=1) -> Tensor\n\nReturns a partial view of :attr:`input` with the its diagonal elements\nwith respect to :attr:`dim1` and :attr:`dim2` appended as a dimension\nat the end of the shape.\n\nThe argument :attr:`offset` controls which diagonal to consider:\n\n- If :attr:`offset` = 0, it is the main diagonal.\n- If :attr:`offset` > 0, it is above the main diagonal.\n- If :attr:`offset` < 0, it is below the main diagonal.\n\nApplying :meth:`torch.diag_embed` to the output of this function with\nthe same arguments yields a diagonal matrix with the diagonal entries\nof the input. However, :meth:`torch.diag_embed` has different default\ndimensions, so those need to be explicitly specified.\n\nArgs:\n    {input} Must be at least 2-dimensional.\n    offset (int, optional): which diagonal to consider. Default: 0\n        (main diagonal).\n    dim1 (int, optional): first dimension with respect to which to\n        take diagonal. Default: 0.\n    dim2 (int, optional): second dimension with respect to which to\n        take diagonal. Default: 1.\n\n.. note::  To take a batch diagonal, pass in dim1=-2, dim2=-1.\n\nExamples::\n\n    >>> a = torch.randn(3, 3)\n    >>> a\n    tensor([[-1.0854,  1.1431, -0.1752],\n            [ 0.8536, -0.0905,  0.0360],\n            [ 0.6927, -0.3735, -0.4945]])\n\n\n    >>> torch.diagonal(a, 0)\n    tensor([-1.0854, -0.0905, -0.4945])\n\n\n    >>> torch.diagonal(a, 1)\n    tensor([ 1.1431,  0.0360])\n\n\n    >>> x = torch.randn(2, 5, 4, 2)\n    >>> torch.diagonal(x, offset=-1, dim1=1, dim2=2)\n    tensor([[[-1.2631,  0.3755, -1.5977, -1.8172],\n             [-1.1065,  1.0401, -0.2235, -0.7938]],\n\n            [[-1.7325, -0.3081,  0.6166,  0.2335],\n             [ 1.0500,  0.7336, -0.3836, -1.1015]]])\n'.format(**common_args))
add_docstr(torch.digamma, "\ndigamma(input, out=None) -> Tensor\n\nComputes the logarithmic derivative of the gamma function on `input`.\n\n.. math::\n    \\psi(x) = \\frac{d}{dx} \\ln\\left(\\Gamma\\left(x\\right)\\right) = \\frac{\\Gamma'(x)}{\\Gamma(x)}\n\nArgs:\n    input (Tensor): the tensor to compute the digamma function on\n\nExample::\n\n    >>> a = torch.tensor([1, 0.5])\n    >>> torch.digamma(a)\n    tensor([-0.5772, -1.9635])\n")
add_docstr(torch.dist, '\ndist(input, other, p=2) -> Tensor\n\nReturns the p-norm of (:attr:`input` - :attr:`other`)\n\nThe shapes of :attr:`input` and :attr:`other` must be\n:ref:`broadcastable <broadcasting-semantics>`.\n\nArgs:\n    {input}\n    other (Tensor): the Right-hand-side input tensor\n    p (float, optional): the norm to be computed\n\nExample::\n\n    >>> x = torch.randn(4)\n    >>> x\n    tensor([-1.5393, -0.8675,  0.5916,  1.6321])\n    >>> y = torch.randn(4)\n    >>> y\n    tensor([ 0.0967, -1.0511,  0.6295,  0.8360])\n    >>> torch.dist(x, y, 3.5)\n    tensor(1.6727)\n    >>> torch.dist(x, y, 3)\n    tensor(1.6973)\n    >>> torch.dist(x, y, 0)\n    tensor(inf)\n    >>> torch.dist(x, y, 1)\n    tensor(2.6537)\n'.format(**common_args))
add_docstr(torch.div, '\n.. function:: div(input, other, out=None) -> Tensor\n\nDivides each element of the input ``input`` with the scalar ``other`` and\nreturns a new resulting tensor.\n\n.. warning::\n    Integer division using div is deprecated, and in a future release div will\n    perform true division like :func:`torch.true_divide`.\n    Use :func:`torch.floor_divide` (// in Python) to perform integer division,\n    instead.\n\n.. math::\n    \\text{{out}}_i = \\frac{{\\text{{input}}_i}}{{\\text{{other}}}}\n\nIf the :class:`torch.dtype` of ``input`` and ``other`` differ, the\n:class:`torch.dtype` of the result tensor is determined following rules\ndescribed in the type promotion :ref:`documentation <type-promotion-doc>`. If\n``out`` is specified, the result must be :ref:`castable <type-promotion-doc>`\nto the :class:`torch.dtype` of the specified output tensor. Integral division\nby zero leads to undefined behavior.\n\nArgs:\n    {input}\n    other (Number): the number to be divided to each element of ``input``\n\nKeyword args:\n    {out}\n\nExample::\n\n    >>> a = torch.randn(5)\n    >>> a\n    tensor([ 0.3810,  1.2774, -0.2972, -0.3719,  0.4637])\n    >>> torch.div(a, 0.5)\n    tensor([ 0.7620,  2.5548, -0.5944, -0.7439,  0.9275])\n\n.. function:: div(input, other, out=None) -> Tensor\n\nEach element of the tensor ``input`` is divided by each element of the tensor\n``other``. The resulting tensor is returned.\n\n.. math::\n    \\text{{out}}_i = \\frac{{\\text{{input}}_i}}{{\\text{{other}}_i}}\n\nThe shapes of ``input`` and ``other`` must be :ref:`broadcastable\n<broadcasting-semantics>`. If the :class:`torch.dtype` of ``input`` and\n``other`` differ, the :class:`torch.dtype` of the result tensor is determined\nfollowing rules described in the type promotion :ref:`documentation\n<type-promotion-doc>`. If ``out`` is specified, the result must be\n:ref:`castable <type-promotion-doc>` to the :class:`torch.dtype` of the\nspecified output tensor. Integral division by zero leads to undefined behavior.\n\nArgs:\n    input (Tensor): the numerator tensor\n    other (Tensor): the denominator tensor\n\nKeyword args:\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[-0.3711, -1.9353, -0.4605, -0.2917],\n            [ 0.1815, -1.0111,  0.9805, -1.5923],\n            [ 0.1062,  1.4581,  0.7759, -1.2344],\n            [-0.1830, -0.0313,  1.1908, -1.4757]])\n    >>> b = torch.randn(4)\n    >>> b\n    tensor([ 0.8032,  0.2930, -0.8113, -0.2308])\n    >>> torch.div(a, b)\n    tensor([[-0.4620, -6.6051,  0.5676,  1.2637],\n            [ 0.2260, -3.4507, -1.2086,  6.8988],\n            [ 0.1322,  4.9764, -0.9564,  5.3480],\n            [-0.2278, -0.1068, -1.4678,  6.3936]])\n'.format(**common_args))
add_docstr(torch.dot, '\ndot(input, tensor) -> Tensor\n\nComputes the dot product (inner product) of two tensors.\n\n.. note:: This function does not :ref:`broadcast <broadcasting-semantics>`.\n\nExample::\n\n    >>> torch.dot(torch.tensor([2, 3]), torch.tensor([2, 1]))\n    tensor(7)\n')
add_docstr(torch.eig, "\neig(input, eigenvectors=False, out=None) -> (Tensor, Tensor)\n\nComputes the eigenvalues and eigenvectors of a real square matrix.\n\n.. note::\n    Since eigenvalues and eigenvectors might be complex, backward pass is supported only\n    for :func:`torch.symeig`\n\nArgs:\n    input (Tensor): the square matrix of shape :math:`(n \\times n)` for which the eigenvalues and eigenvectors\n        will be computed\n    eigenvectors (bool): ``True`` to compute both eigenvalues and eigenvectors;\n        otherwise, only eigenvalues will be computed\n    out (tuple, optional): the output tensors\n\nReturns:\n    (Tensor, Tensor): A namedtuple (eigenvalues, eigenvectors) containing\n\n        - **eigenvalues** (*Tensor*): Shape :math:`(n \\times 2)`. Each row is an eigenvalue of ``input``,\n          where the first element is the real part and the second element is the imaginary part.\n          The eigenvalues are not necessarily ordered.\n        - **eigenvectors** (*Tensor*): If ``eigenvectors=False``, it's an empty tensor.\n          Otherwise, this tensor of shape :math:`(n \\times n)` can be used to compute normalized (unit length)\n          eigenvectors of corresponding eigenvalues as follows.\n          If the corresponding `eigenvalues[j]` is a real number, column `eigenvectors[:, j]` is the eigenvector\n          corresponding to `eigenvalues[j]`.\n          If the corresponding `eigenvalues[j]` and `eigenvalues[j + 1]` form a complex conjugate pair, then the\n          true eigenvectors can be computed as\n          :math:`\\text{true eigenvector}[j] = eigenvectors[:, j] + i \\times eigenvectors[:, j + 1]`,\n          :math:`\\text{true eigenvector}[j + 1] = eigenvectors[:, j] - i \\times eigenvectors[:, j + 1]`.\n")
add_docstr(torch.eq, '\neq(input, other, out=None) -> Tensor\n\nComputes element-wise equality\n\nThe second argument can be a number or a tensor whose shape is\n:ref:`broadcastable <broadcasting-semantics>` with the first argument.\n\nArgs:\n    input (Tensor): the tensor to compare\n    other (Tensor or float): the tensor or value to compare\n    {out} Must be a `ByteTensor`\n\nReturns:\n    Tensor: A ``torch.BoolTensor`` containing a True at each location where comparison is true\n\nExample::\n\n    >>> torch.eq(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))\n    tensor([[ True, False],\n            [False, True]])\n'.format(**common_args))
add_docstr(torch.equal, '\nequal(input, other) -> bool\n\n``True`` if two tensors have the same size and elements, ``False`` otherwise.\n\nExample::\n\n    >>> torch.equal(torch.tensor([1, 2]), torch.tensor([1, 2]))\n    True\n')
add_docstr(torch.erf, '\nerf(input, out=None) -> Tensor\n\nComputes the error function of each element. The error function is defined as follows:\n\n.. math::\n    \\mathrm{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{x} e^{-t^2} dt\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> torch.erf(torch.tensor([0, -1., 10.]))\n    tensor([ 0.0000, -0.8427,  1.0000])\n'.format(**common_args))
add_docstr(torch.erfc, '\nerfc(input, out=None) -> Tensor\n\nComputes the complementary error function of each element of :attr:`input`.\nThe complementary error function is defined as follows:\n\n.. math::\n    \\mathrm{erfc}(x) = 1 - \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{x} e^{-t^2} dt\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> torch.erfc(torch.tensor([0, -1., 10.]))\n    tensor([ 1.0000, 1.8427,  0.0000])\n'.format(**common_args))
add_docstr(torch.erfinv, '\nerfinv(input, out=None) -> Tensor\n\nComputes the inverse error function of each element of :attr:`input`.\nThe inverse error function is defined in the range :math:`(-1, 1)` as:\n\n.. math::\n    \\mathrm{erfinv}(\\mathrm{erf}(x)) = x\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> torch.erfinv(torch.tensor([0, 0.5, -1.]))\n    tensor([ 0.0000,  0.4769,    -inf])\n'.format(**common_args))
add_docstr(torch.exp, '\nexp(input, out=None) -> Tensor\n\nReturns a new tensor with the exponential of the elements\nof the input tensor :attr:`input`.\n\n.. math::\n    y_{i} = e^{x_{i}}\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> torch.exp(torch.tensor([0, math.log(2.)]))\n    tensor([ 1.,  2.])\n'.format(**common_args))
add_docstr(torch.expm1, '\nexpm1(input, out=None) -> Tensor\n\nReturns a new tensor with the exponential of the elements minus 1\nof :attr:`input`.\n\n.. math::\n    y_{i} = e^{x_{i}} - 1\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> torch.expm1(torch.tensor([0, math.log(2.)]))\n    tensor([ 0.,  1.])\n'.format(**common_args))
add_docstr(torch.eye, '\neye(n, m=None, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nReturns a 2-D tensor with ones on the diagonal and zeros elsewhere.\n\nArgs:\n    n (int): the number of rows\n    m (int, optional): the number of columns with default being :attr:`n`\n    {out}\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n\nReturns:\n    Tensor: A 2-D tensor with ones on the diagonal and zeros elsewhere\n\nExample::\n\n    >>> torch.eye(3)\n    tensor([[ 1.,  0.,  0.],\n            [ 0.,  1.,  0.],\n            [ 0.,  0.,  1.]])\n'.format(**factory_common_args))
add_docstr(torch.floor, '\nfloor(input, out=None) -> Tensor\n\nReturns a new tensor with the floor of the elements of :attr:`input`,\nthe largest integer less than or equal to each element.\n\n.. math::\n    \\text{out}_{i} = \\left\\lfloor \\text{input}_{i} \\right\\rfloor\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-0.8166,  1.5308, -0.2530, -0.2091])\n    >>> torch.floor(a)\n    tensor([-1.,  1., -1., -1.])\n'.format(**common_args))
add_docstr(torch.floor_divide, '\nfloor_divide(input, other, out=None) -> Tensor\n\nReturn the division of the inputs rounded down to the nearest integer. See :func:`torch.div`\nfor type promotion and broadcasting rules.\n\n.. math::\n    \\text{{out}}_i = \\left\\lfloor \\frac{{\\text{{input}}_i}}{{\\text{{other}}_i}} \\right\\rfloor\n\n' + '\nArgs:\n    input (Tensor): the numerator tensor\n    other (Tensor or Scalar): the denominator\n\nKeyword args:\n    {out}\n\nExample::\n\n    >>> a = torch.tensor([4.0, 3.0])\n    >>> b = torch.tensor([2.0, 2.0])\n    >>> torch.floor_divide(a, b)\n    tensor([2.0, 1.0])\n    >>> torch.floor_divide(a, 1.4)\n    tensor([2.0, 2.0])\n'.format(**common_args))
add_docstr(torch.fmod, '\nfmod(input, other, out=None) -> Tensor\n\nComputes the element-wise remainder of division.\n\nThe dividend and divisor may contain both for integer and floating point\nnumbers. The remainder has the same sign as the dividend :attr:`input`.\n\nWhen :attr:`other` is a tensor, the shapes of :attr:`input` and\n:attr:`other` must be :ref:`broadcastable <broadcasting-semantics>`.\n\nArgs:\n    input (Tensor): the dividend\n    other (Tensor or float): the divisor, which may be either a number or a tensor of the same shape as the dividend\n    {out}\n\nExample::\n\n    >>> torch.fmod(torch.tensor([-3., -2, -1, 1, 2, 3]), 2)\n    tensor([-1., -0., -1.,  1.,  0.,  1.])\n    >>> torch.fmod(torch.tensor([1., 2, 3, 4, 5]), 1.5)\n    tensor([ 1.0000,  0.5000,  0.0000,  1.0000,  0.5000])\n\n\n'.format(**common_args))
add_docstr(torch.frac, '\nfrac(input, out=None) -> Tensor\n\nComputes the fractional portion of each element in :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\text{input}_{i} - \\left\\lfloor |\\text{input}_{i}| \\right\\rfloor * \\operatorname{sgn}(\\text{input}_{i})\n\nExample::\n\n    >>> torch.frac(torch.tensor([1, 2.5, -3.2]))\n    tensor([ 0.0000,  0.5000, -0.2000])\n')
add_docstr(torch.from_numpy, '\nfrom_numpy(ndarray) -> Tensor\n\nCreates a :class:`Tensor` from a :class:`numpy.ndarray`.\n\nThe returned tensor and :attr:`ndarray` share the same memory. Modifications to\nthe tensor will be reflected in the :attr:`ndarray` and vice versa. The returned\ntensor is not resizable.\n\nIt currently accepts :attr:`ndarray` with dtypes of ``numpy.float64``,\n``numpy.float32``, ``numpy.float16``, ``numpy.int64``, ``numpy.int32``,\n``numpy.int16``, ``numpy.int8``, ``numpy.uint8``, and ``numpy.bool``.\n\nExample::\n\n    >>> a = numpy.array([1, 2, 3])\n    >>> t = torch.from_numpy(a)\n    >>> t\n    tensor([ 1,  2,  3])\n    >>> t[0] = -1\n    >>> a\n    array([-1,  2,  3])\n')
add_docstr(torch.flatten, '\nflatten(input, start_dim=0, end_dim=-1) -> Tensor\n\nFlattens a contiguous range of dims in a tensor.\n\nArgs:\n    {input}\n    start_dim (int): the first dim to flatten\n    end_dim (int): the last dim to flatten\n\nExample::\n\n    >>> t = torch.tensor([[[1, 2],\n                           [3, 4]],\n                          [[5, 6],\n                           [7, 8]]])\n    >>> torch.flatten(t)\n    tensor([1, 2, 3, 4, 5, 6, 7, 8])\n    >>> torch.flatten(t, start_dim=1)\n    tensor([[1, 2, 3, 4],\n            [5, 6, 7, 8]])\n'.format(**common_args))
add_docstr(torch.gather, '\ngather(input, dim, index, out=None, sparse_grad=False) -> Tensor\n\nGathers values along an axis specified by `dim`.\n\nFor a 3-D tensor the output is specified by::\n\n    out[i][j][k] = input[index[i][j][k]][j][k]  # if dim == 0\n    out[i][j][k] = input[i][index[i][j][k]][k]  # if dim == 1\n    out[i][j][k] = input[i][j][index[i][j][k]]  # if dim == 2\n\nIf :attr:`input` is an n-dimensional tensor with size\n:math:`(x_0, x_1..., x_{i-1}, x_i, x_{i+1}, ..., x_{n-1})`\nand ``dim = i``, then :attr:`index` must be an :math:`n`-dimensional tensor with\nsize :math:`(x_0, x_1, ..., x_{i-1}, y, x_{i+1}, ..., x_{n-1})` where :math:`y \\geq 1`\nand :attr:`out` will have the same size as :attr:`index`.\n' + '\nArgs:\n    input (Tensor): the source tensor\n    dim (int): the axis along which to index\n    index (LongTensor): the indices of elements to gather\n    out (Tensor, optional): the destination tensor\n    sparse_grad(bool,optional): If ``True``, gradient w.r.t. :attr:`input` will be a sparse tensor.\n\nExample::\n\n    >>> t = torch.tensor([[1,2],[3,4]])\n    >>> torch.gather(t, 1, torch.tensor([[0,0],[1,0]]))\n    tensor([[ 1,  1],\n            [ 4,  3]])\n')
add_docstr(torch.ge, '\nge(input, other, out=None) -> Tensor\n\nComputes :math:`\\text{input} \\geq \\text{other}` element-wise.\n\nThe second argument can be a number or a tensor whose shape is\n:ref:`broadcastable <broadcasting-semantics>` with the first argument.\n\nArgs:\n    input (Tensor): the tensor to compare\n    other (Tensor or float): the tensor or value to compare\n    out (Tensor, optional): the output tensor that must be a `BoolTensor`\n\nReturns:\n    Tensor: A ``torch.BoolTensor`` containing a True at each location where comparison is true\n\nExample::\n\n    >>> torch.ge(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))\n    tensor([[True, True], [False, True]])\n')
add_docstr(torch.geqrf, "\ngeqrf(input, out=None) -> (Tensor, Tensor)\n\nThis is a low-level function for calling LAPACK directly. This function\nreturns a namedtuple (a, tau) as defined in `LAPACK documentation for geqrf`_ .\n\nYou'll generally want to use :func:`torch.qr` instead.\n\nComputes a QR decomposition of :attr:`input`, but without constructing\n:math:`Q` and :math:`R` as explicit separate matrices.\n\nRather, this directly calls the underlying LAPACK function `?geqrf`\nwhich produces a sequence of 'elementary reflectors'.\n\nSee `LAPACK documentation for geqrf`_ for further details.\n\nArgs:\n    input (Tensor): the input matrix\n    out (tuple, optional): the output tuple of (Tensor, Tensor)\n\n.. _LAPACK documentation for geqrf:\n    https://software.intel.com/en-us/node/521004\n\n")
add_docstr(torch.ger, '\nger(input, vec2, out=None) -> Tensor\n\nOuter product of :attr:`input` and :attr:`vec2`.\nIf :attr:`input` is a vector of size :math:`n` and :attr:`vec2` is a vector of\nsize :math:`m`, then :attr:`out` must be a matrix of size :math:`(n \\times m)`.\n\n.. note:: This function does not :ref:`broadcast <broadcasting-semantics>`.\n\nArgs:\n    input (Tensor): 1-D input vector\n    vec2 (Tensor): 1-D input vector\n    out (Tensor, optional): optional output matrix\n\nExample::\n\n    >>> v1 = torch.arange(1., 5.)\n    >>> v2 = torch.arange(1., 4.)\n    >>> torch.ger(v1, v2)\n    tensor([[  1.,   2.,   3.],\n            [  2.,   4.,   6.],\n            [  3.,   6.,   9.],\n            [  4.,   8.,  12.]])\n')
add_docstr(torch.solve, '\ntorch.solve(input, A, out=None) -> (Tensor, Tensor)\n\nThis function returns the solution to the system of linear\nequations represented by :math:`AX = B` and the LU factorization of\nA, in order as a namedtuple `solution, LU`.\n\n`LU` contains `L` and `U` factors for LU factorization of `A`.\n\n`torch.solve(B, A)` can take in 2D inputs `B, A` or inputs that are\nbatches of 2D matrices. If the inputs are batches, then returns\nbatched outputs `solution, LU`.\n\n.. note::\n\n    Irrespective of the original strides, the returned matrices\n    `solution` and `LU` will be transposed, i.e. with strides like\n    `B.contiguous().transpose(-1, -2).stride()` and\n    `A.contiguous().transpose(-1, -2).stride()` respectively.\n\nArgs:\n    input (Tensor): input matrix :math:`B` of size :math:`(*, m, k)` , where :math:`*`\n                is zero or more batch dimensions.\n    A (Tensor): input square matrix of size :math:`(*, m, m)`, where\n                :math:`*` is zero or more batch dimensions.\n    out ((Tensor, Tensor), optional): optional output tuple.\n\nExample::\n\n    >>> A = torch.tensor([[6.80, -2.11,  5.66,  5.97,  8.23],\n                          [-6.05, -3.30,  5.36, -4.44,  1.08],\n                          [-0.45,  2.58, -2.70,  0.27,  9.04],\n                          [8.32,  2.71,  4.35,  -7.17,  2.14],\n                          [-9.67, -5.14, -7.26,  6.08, -6.87]]).t()\n    >>> B = torch.tensor([[4.02,  6.19, -8.22, -7.57, -3.03],\n                          [-1.56,  4.00, -8.67,  1.75,  2.86],\n                          [9.81, -4.09, -4.57, -8.61,  8.99]]).t()\n    >>> X, LU = torch.solve(B, A)\n    >>> torch.dist(B, torch.mm(A, X))\n    tensor(1.00000e-06 *\n           7.0977)\n\n    >>> # Batched solver example\n    >>> A = torch.randn(2, 3, 1, 4, 4)\n    >>> B = torch.randn(2, 3, 1, 4, 6)\n    >>> X, LU = torch.solve(B, A)\n    >>> torch.dist(B, A.matmul(X))\n    tensor(1.00000e-06 *\n       3.6386)\n\n')
add_docstr(torch.get_default_dtype, '\nget_default_dtype() -> torch.dtype\n\nGet the current default floating point :class:`torch.dtype`.\n\nExample::\n\n    >>> torch.get_default_dtype()  # initial default for floating point is torch.float32\n    torch.float32\n    >>> torch.set_default_dtype(torch.float64)\n    >>> torch.get_default_dtype()  # default is now changed to torch.float64\n    torch.float64\n    >>> torch.set_default_tensor_type(torch.FloatTensor)  # setting tensor type also affects this\n    >>> torch.get_default_dtype()  # changed to torch.float32, the dtype for torch.FloatTensor\n    torch.float32\n\n')
add_docstr(torch.get_num_threads, '\nget_num_threads() -> int\n\nReturns the number of threads used for parallelizing CPU operations\n')
add_docstr(torch.get_num_interop_threads, '\nget_num_interop_threads() -> int\n\nReturns the number of threads used for inter-op parallelism on CPU\n(e.g. in JIT interpreter)\n')
add_docstr(torch.gt, '\ngt(input, other, out=None) -> Tensor\n\nComputes :math:`\\text{input} > \\text{other}` element-wise.\n\nThe second argument can be a number or a tensor whose shape is\n:ref:`broadcastable <broadcasting-semantics>` with the first argument.\n\nArgs:\n    input (Tensor): the tensor to compare\n    other (Tensor or float): the tensor or value to compare\n    out (Tensor, optional): the output tensor that must be a `BoolTensor`\n\nReturns:\n    Tensor: A ``torch.BoolTensor`` containing a True at each location where comparison is true\n\nExample::\n\n    >>> torch.gt(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))\n    tensor([[False, True], [False, False]])\n')
add_docstr(torch.histc, '\nhistc(input, bins=100, min=0, max=0, out=None) -> Tensor\n\nComputes the histogram of a tensor.\n\nThe elements are sorted into equal width bins between :attr:`min` and\n:attr:`max`. If :attr:`min` and :attr:`max` are both zero, the minimum and\nmaximum values of the data are used.\n\nArgs:\n    {input}\n    bins (int): number of histogram bins\n    min (int): lower end of the range (inclusive)\n    max (int): upper end of the range (inclusive)\n    {out}\n\nReturns:\n    Tensor: Histogram represented as a tensor\n\nExample::\n\n    >>> torch.histc(torch.tensor([1., 2, 1]), bins=4, min=0, max=3)\n    tensor([ 0.,  2.,  1.,  0.])\n'.format(**common_args))
add_docstr(torch.imag, '\nimag(input, out=None) -> Tensor\n\nReturns the imaginary part of the :attr:`input` tensor.\n\n.. warning::\n    Not yet implemented.\n\n.. math::\n    \\text{out}_{i} = imag(\\text{input}_{i})\n' + '\nArgs:\n    {input}\n    {out}\n'.format(**common_args))
add_docstr(torch.index_select, '\nindex_select(input, dim, index, out=None) -> Tensor\n\nReturns a new tensor which indexes the :attr:`input` tensor along dimension\n:attr:`dim` using the entries in :attr:`index` which is a `LongTensor`.\n\nThe returned tensor has the same number of dimensions as the original tensor\n(:attr:`input`).  The :attr:`dim`\\ th dimension has the same size as the length\nof :attr:`index`; other dimensions have the same size as in the original tensor.\n\n.. note:: The returned tensor does **not** use the same storage as the original\n          tensor.  If :attr:`out` has a different shape than expected, we\n          silently change it to the correct shape, reallocating the underlying\n          storage if necessary.\n\nArgs:\n    {input}\n    dim (int): the dimension in which we index\n    index (LongTensor): the 1-D tensor containing the indices to index\n    {out}\n\nExample::\n\n    >>> x = torch.randn(3, 4)\n    >>> x\n    tensor([[ 0.1427,  0.0231, -0.5414, -1.0009],\n            [-0.4664,  0.2647, -0.1228, -1.1068],\n            [-1.1734, -0.6571,  0.7230, -0.6004]])\n    >>> indices = torch.tensor([0, 2])\n    >>> torch.index_select(x, 0, indices)\n    tensor([[ 0.1427,  0.0231, -0.5414, -1.0009],\n            [-1.1734, -0.6571,  0.7230, -0.6004]])\n    >>> torch.index_select(x, 1, indices)\n    tensor([[ 0.1427, -0.5414],\n            [-0.4664, -0.1228],\n            [-1.1734,  0.7230]])\n'.format(**common_args))
add_docstr(torch.inverse, '\ninverse(input, out=None) -> Tensor\n\nTakes the inverse of the square matrix :attr:`input`. :attr:`input` can be batches\nof 2D square tensors, in which case this function would return a tensor composed of\nindividual inverses.\n\n.. note::\n\n    Irrespective of the original strides, the returned tensors will be\n    transposed, i.e. with strides like `input.contiguous().transpose(-2, -1).stride()`\n\nArgs:\n    input (Tensor): the input tensor of size :math:`(*, n, n)` where `*` is zero or more\n                    batch dimensions\n    {out}\n\nExample::\n\n    >>> x = torch.rand(4, 4)\n    >>> y = torch.inverse(x)\n    >>> z = torch.mm(x, y)\n    >>> z\n    tensor([[ 1.0000, -0.0000, -0.0000,  0.0000],\n            [ 0.0000,  1.0000,  0.0000,  0.0000],\n            [ 0.0000,  0.0000,  1.0000,  0.0000],\n            [ 0.0000, -0.0000, -0.0000,  1.0000]])\n    >>> torch.max(torch.abs(z - torch.eye(4))) # Max non-zero\n    tensor(1.1921e-07)\n    >>> # Batched inverse example\n    >>> x = torch.randn(2, 3, 4, 4)\n    >>> y = torch.inverse(x)\n    >>> z = torch.matmul(x, y)\n    >>> torch.max(torch.abs(z - torch.eye(4).expand_as(x))) # Max non-zero\n    tensor(1.9073e-06)\n'.format(**common_args))
add_docstr(torch.isinf, "\nReturns a new tensor with boolean elements representing if each element is `+/-INF` or not.\n\n    Arguments:\n        tensor (Tensor): A tensor to check\n\n    Returns:\n        Tensor: ``A torch.Tensor with dtype torch.bool`` containing a True at each location of `+/-INF` elements and False otherwise\n\n    Example::\n\n        >>> torch.isinf(torch.tensor([1, float('inf'), 2, float('-inf'), float('nan')]))\n        tensor([False,  True,  False,  True,  False])\n")
add_docstr(torch.isfinite, "\nReturns a new tensor with boolean elements representing if each element is `Finite` or not.\n\n    Arguments:\n        tensor (Tensor): A tensor to check\n\n    Returns:\n        Tensor: ``A torch.Tensor with dtype torch.bool`` containing a True at each location of finite elements and False otherwise\n\n    Example::\n\n        >>> torch.isfinite(torch.tensor([1, float('inf'), 2, float('-inf'), float('nan')]))\n        tensor([True,  False,  True,  False,  False])\n")
add_docstr(torch.isnan, "\nReturns a new tensor with boolean elements representing if each element is `NaN` or not.\n\nArguments:\n    input (Tensor): A tensor to check\n\nReturns:\n    Tensor: A ``torch.BoolTensor`` containing a True at each location of `NaN` elements.\n\nExample::\n\n    >>> torch.isnan(torch.tensor([1, float('nan'), 2]))\n    tensor([False, True, False])\n")
add_docstr(torch.is_floating_point, '\nis_floating_point(input) -> (bool)\n\nReturns True if the data type of :attr:`input` is a floating point data type i.e.,\none of ``torch.float64``, ``torch.float32`` and ``torch.float16``.\n\nArgs:\n    input (Tensor): the PyTorch tensor to test\n')
add_docstr(torch.is_complex, '\nis_complex(input) -> (bool)\n\nReturns True if the data type of :attr:`input` is a complex data type i.e.,\none of ``torch.complex64``, and ``torch.complex128``.\n\nArgs:\n    input (Tensor): the PyTorch tensor to test\n')
add_docstr(torch.kthvalue, '\nkthvalue(input, k, dim=None, keepdim=False, out=None) -> (Tensor, LongTensor)\n\nReturns a namedtuple ``(values, indices)`` where ``values`` is the :attr:`k` th\nsmallest element of each row of the :attr:`input` tensor in the given dimension\n:attr:`dim`. And ``indices`` is the index location of each element found.\n\nIf :attr:`dim` is not given, the last dimension of the `input` is chosen.\n\nIf :attr:`keepdim` is ``True``, both the :attr:`values` and :attr:`indices` tensors\nare the same size as :attr:`input`, except in the dimension :attr:`dim` where\nthey are of size 1. Otherwise, :attr:`dim` is squeezed\n(see :func:`torch.squeeze`), resulting in both the :attr:`values` and\n:attr:`indices` tensors having 1 fewer dimension than the :attr:`input` tensor.\n\nArgs:\n    {input}\n    k (int): k for the k-th smallest element\n    dim (int, optional): the dimension to find the kth value along\n    {keepdim}\n    out (tuple, optional): the output tuple of (Tensor, LongTensor)\n                           can be optionally given to be used as output buffers\n\nExample::\n\n    >>> x = torch.arange(1., 6.)\n    >>> x\n    tensor([ 1.,  2.,  3.,  4.,  5.])\n    >>> torch.kthvalue(x, 4)\n    torch.return_types.kthvalue(values=tensor(4.), indices=tensor(3))\n\n    >>> x=torch.arange(1.,7.).resize_(2,3)\n    >>> x\n    tensor([[ 1.,  2.,  3.],\n            [ 4.,  5.,  6.]])\n    >>> torch.kthvalue(x, 2, 0, True)\n    torch.return_types.kthvalue(values=tensor([[4., 5., 6.]]), indices=tensor([[1, 1, 1]]))\n'.format(**single_dim_common))
add_docstr(torch.le, '\nle(input, other, out=None) -> Tensor\n\nComputes :math:`\\text{input} \\leq \\text{other}` element-wise.\n\nThe second argument can be a number or a tensor whose shape is\n:ref:`broadcastable <broadcasting-semantics>` with the first argument.\n\nArgs:\n    input (Tensor): the tensor to compare\n    other (Tensor or float): the tensor or value to compare\n    out (Tensor, optional): the output tensor that must be a `BoolTensor`\n\nReturns:\n    Tensor: A ``torch.BoolTensor`` containing a True at each location where comparison is true\n\nExample::\n\n    >>> torch.le(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))\n    tensor([[True, False], [True, True]])\n')
add_docstr(torch.lerp, '\nlerp(input, end, weight, out=None)\n\nDoes a linear interpolation of two tensors :attr:`start` (given by :attr:`input`) and :attr:`end` based\non a scalar or tensor :attr:`weight` and returns the resulting :attr:`out` tensor.\n\n.. math::\n    \\text{out}_i = \\text{start}_i + \\text{weight}_i \\times (\\text{end}_i - \\text{start}_i)\n' + '\nThe shapes of :attr:`start` and :attr:`end` must be\n:ref:`broadcastable <broadcasting-semantics>`. If :attr:`weight` is a tensor, then\nthe shapes of :attr:`weight`, :attr:`start`, and :attr:`end` must be :ref:`broadcastable <broadcasting-semantics>`.\n\nArgs:\n    input (Tensor): the tensor with the starting points\n    end (Tensor): the tensor with the ending points\n    weight (float or tensor): the weight for the interpolation formula\n    {out}\n\nExample::\n\n    >>> start = torch.arange(1., 5.)\n    >>> end = torch.empty(4).fill_(10)\n    >>> start\n    tensor([ 1.,  2.,  3.,  4.])\n    >>> end\n    tensor([ 10.,  10.,  10.,  10.])\n    >>> torch.lerp(start, end, 0.5)\n    tensor([ 5.5000,  6.0000,  6.5000,  7.0000])\n    >>> torch.lerp(start, end, torch.full_like(start, 0.5))\n    tensor([ 5.5000,  6.0000,  6.5000,  7.0000])\n'.format(**common_args))
add_docstr(torch.lgamma, '\nlgamma(input, out=None) -> Tensor\n\nComputes the logarithm of the gamma function on :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\log \\Gamma(\\text{input}_{i})\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.arange(0.5, 2, 0.5)\n    >>> torch.lgamma(a)\n    tensor([ 0.5724,  0.0000, -0.1208])\n'.format(**common_args))
add_docstr(torch.linspace, '\nlinspace(start, end, steps=100, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nReturns a one-dimensional tensor of :attr:`steps`\nequally spaced points between :attr:`start` and :attr:`end`.\n\nThe output tensor is 1-D of size :attr:`steps`.\n\nArgs:\n    start (float): the starting value for the set of points\n    end (float): the ending value for the set of points\n    steps (int): number of points to sample between :attr:`start`\n        and :attr:`end`. Default: ``100``.\n    {out}\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n\n\nExample::\n\n    >>> torch.linspace(3, 10, steps=5)\n    tensor([  3.0000,   4.7500,   6.5000,   8.2500,  10.0000])\n    >>> torch.linspace(-10, 10, steps=5)\n    tensor([-10.,  -5.,   0.,   5.,  10.])\n    >>> torch.linspace(start=-10, end=10, steps=5)\n    tensor([-10.,  -5.,   0.,   5.,  10.])\n    >>> torch.linspace(start=-10, end=10, steps=1)\n    tensor([-10.])\n'.format(**factory_common_args))
add_docstr(torch.log, '\nlog(input, out=None) -> Tensor\n\nReturns a new tensor with the natural logarithm of the elements\nof :attr:`input`.\n\n.. math::\n    y_{i} = \\log_{e} (x_{i})\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(5)\n    >>> a\n    tensor([-0.7168, -0.5471, -0.8933, -1.4428, -0.1190])\n    >>> torch.log(a)\n    tensor([ nan,  nan,  nan,  nan,  nan])\n'.format(**common_args))
add_docstr(torch.log10, '\nlog10(input, out=None) -> Tensor\n\nReturns a new tensor with the logarithm to the base 10 of the elements\nof :attr:`input`.\n\n.. math::\n    y_{i} = \\log_{10} (x_{i})\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.rand(5)\n    >>> a\n    tensor([ 0.5224,  0.9354,  0.7257,  0.1301,  0.2251])\n\n\n    >>> torch.log10(a)\n    tensor([-0.2820, -0.0290, -0.1392, -0.8857, -0.6476])\n\n'.format(**common_args))
add_docstr(torch.log1p, '\nlog1p(input, out=None) -> Tensor\n\nReturns a new tensor with the natural logarithm of (1 + :attr:`input`).\n\n.. math::\n    y_i = \\log_{e} (x_i + 1)\n' + '\n.. note:: This function is more accurate than :func:`torch.log` for small\n          values of :attr:`input`\n\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(5)\n    >>> a\n    tensor([-1.0090, -0.9923,  1.0249, -0.5372,  0.2492])\n    >>> torch.log1p(a)\n    tensor([    nan, -4.8653,  0.7055, -0.7705,  0.2225])\n'.format(**common_args))
add_docstr(torch.log2, '\nlog2(input, out=None) -> Tensor\n\nReturns a new tensor with the logarithm to the base 2 of the elements\nof :attr:`input`.\n\n.. math::\n    y_{i} = \\log_{2} (x_{i})\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.rand(5)\n    >>> a\n    tensor([ 0.8419,  0.8003,  0.9971,  0.5287,  0.0490])\n\n\n    >>> torch.log2(a)\n    tensor([-0.2483, -0.3213, -0.0042, -0.9196, -4.3504])\n\n'.format(**common_args))
add_docstr(torch.logical_and, '\nlogical_and(input, other, out=None) -> Tensor\n\nComputes the element-wise logical AND of the given input tensors. Zeros are treated as ``False`` and nonzeros are\ntreated as ``True``.\n\nArgs:\n    {input}\n    other (Tensor): the tensor to compute AND with\n    {out}\n\nExample::\n\n    >>> torch.logical_and(torch.tensor([True, False, True]), torch.tensor([True, False, False]))\n    tensor([ True, False, False])\n    >>> a = torch.tensor([0, 1, 10, 0], dtype=torch.int8)\n    >>> b = torch.tensor([4, 0, 1, 0], dtype=torch.int8)\n    >>> torch.logical_and(a, b)\n    tensor([False, False,  True, False])\n    >>> torch.logical_and(a.double(), b.double())\n    tensor([False, False,  True, False])\n    >>> torch.logical_and(a.double(), b)\n    tensor([False, False,  True, False])\n    >>> torch.logical_and(a, b, out=torch.empty(4, dtype=torch.bool))\n    tensor([False, False,  True, False])\n'.format(**common_args))
add_docstr(torch.logical_not, '\nlogical_not(input, out=None) -> Tensor\n\nComputes the element-wise logical NOT of the given input tensor. If not specified, the output tensor will have the bool\ndtype. If the input tensor is not a bool tensor, zeros are treated as ``False`` and non-zeros are treated as ``True``.\n\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> torch.logical_not(torch.tensor([True, False]))\n    tensor([False,  True])\n    >>> torch.logical_not(torch.tensor([0, 1, -10], dtype=torch.int8))\n    tensor([ True, False, False])\n    >>> torch.logical_not(torch.tensor([0., 1.5, -10.], dtype=torch.double))\n    tensor([ True, False, False])\n    >>> torch.logical_not(torch.tensor([0., 1., -10.], dtype=torch.double), out=torch.empty(3, dtype=torch.int16))\n    tensor([1, 0, 0], dtype=torch.int16)\n'.format(**common_args))
add_docstr(torch.logical_or, '\nlogical_or(input, other, out=None) -> Tensor\n\nComputes the element-wise logical OR of the given input tensors. Zeros are treated as ``False`` and nonzeros are\ntreated as ``True``.\n\nArgs:\n    {input}\n    other (Tensor): the tensor to compute OR with\n    {out}\n\nExample::\n\n    >>> torch.logical_or(torch.tensor([True, False, True]), torch.tensor([True, False, False]))\n    tensor([ True, False,  True])\n    >>> a = torch.tensor([0, 1, 10, 0], dtype=torch.int8)\n    >>> b = torch.tensor([4, 0, 1, 0], dtype=torch.int8)\n    >>> torch.logical_or(a, b)\n    tensor([ True,  True,  True, False])\n    >>> torch.logical_or(a.double(), b.double())\n    tensor([ True,  True,  True, False])\n    >>> torch.logical_or(a.double(), b)\n    tensor([ True,  True,  True, False])\n    >>> torch.logical_or(a, b, out=torch.empty(4, dtype=torch.bool))\n    tensor([ True,  True,  True, False])\n'.format(**common_args))
add_docstr(torch.logical_xor, '\nlogical_xor(input, other, out=None) -> Tensor\n\nComputes the element-wise logical XOR of the given input tensors. Zeros are treated as ``False`` and nonzeros are\ntreated as ``True``.\n\nArgs:\n    {input}\n    other (Tensor): the tensor to compute XOR with\n    {out}\n\nExample::\n\n    >>> torch.logical_xor(torch.tensor([True, False, True]), torch.tensor([True, False, False]))\n    tensor([False, False,  True])\n    >>> a = torch.tensor([0, 1, 10, 0], dtype=torch.int8)\n    >>> b = torch.tensor([4, 0, 1, 0], dtype=torch.int8)\n    >>> torch.logical_xor(a, b)\n    tensor([ True,  True, False, False])\n    >>> torch.logical_xor(a.double(), b.double())\n    tensor([ True,  True, False, False])\n    >>> torch.logical_xor(a.double(), b)\n    tensor([ True,  True, False, False])\n    >>> torch.logical_xor(a, b, out=torch.empty(4, dtype=torch.bool))\n    tensor([ True,  True, False, False])\n'.format(**common_args))
add_docstr(torch.logspace, '\nlogspace(start, end, steps=100, base=10.0, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nReturns a one-dimensional tensor of :attr:`steps` points\nlogarithmically spaced with base :attr:`base` between\n:math:`{{\\text{{base}}}}^{{\\text{{start}}}}` and :math:`{{\\text{{base}}}}^{{\\text{{end}}}}`.\n\nThe output tensor is 1-D of size :attr:`steps`.\n\nArgs:\n    start (float): the starting value for the set of points\n    end (float): the ending value for the set of points\n    steps (int): number of points to sample between :attr:`start`\n        and :attr:`end`. Default: ``100``.\n    base (float): base of the logarithm function. Default: ``10.0``.\n    {out}\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n\nExample::\n\n    >>> torch.logspace(start=-10, end=10, steps=5)\n    tensor([ 1.0000e-10,  1.0000e-05,  1.0000e+00,  1.0000e+05,  1.0000e+10])\n    >>> torch.logspace(start=0.1, end=1.0, steps=5)\n    tensor([  1.2589,   2.1135,   3.5481,   5.9566,  10.0000])\n    >>> torch.logspace(start=0.1, end=1.0, steps=1)\n    tensor([1.2589])\n    >>> torch.logspace(start=2, end=2, steps=1, base=2)\n    tensor([4.0])\n'.format(**factory_common_args))
add_docstr(torch.logsumexp, '\nlogsumexp(input, dim, keepdim=False, out=None)\n\nReturns the log of summed exponentials of each row of the :attr:`input`\ntensor in the given dimension :attr:`dim`. The computation is numerically\nstabilized.\n\nFor summation index :math:`j` given by `dim` and other indices :math:`i`, the result is\n\n    .. math::\n        \\text{{logsumexp}}(x)_{{i}} = \\log \\sum_j \\exp(x_{{ij}})\n\n{keepdim_details}\n\nArgs:\n    {input}\n    {dim}\n    {keepdim}\n    {out}\n\n\nExample::\n    >>> a = torch.randn(3, 3)\n    >>> torch.logsumexp(a, 1)\n    tensor([ 0.8442,  1.4322,  0.8711])\n'.format(**multi_dim_common))
add_docstr(torch.lstsq, '\nlstsq(input, A, out=None) -> Tensor\n\nComputes the solution to the least squares and least norm problems for a full\nrank matrix :math:`A` of size :math:`(m \\times n)` and a matrix :math:`B` of\nsize :math:`(m \\times k)`.\n\nIf :math:`m \\geq n`, :func:`lstsq` solves the least-squares problem:\n\n.. math::\n\n   \\begin{array}{ll}\n   \\min_X & \\|AX-B\\|_2.\n   \\end{array}\n\nIf :math:`m < n`, :func:`lstsq` solves the least-norm problem:\n\n.. math::\n\n   \\begin{array}{ll}\n   \\min_X & \\|X\\|_2 & \\text{subject to} & AX = B.\n   \\end{array}\n\nReturned tensor :math:`X` has shape :math:`(\\max(m, n) \\times k)`. The first :math:`n`\nrows of :math:`X` contains the solution. If :math:`m \\geq n`, the residual sum of squares\nfor the solution in each column is given by the sum of squares of elements in the\nremaining :math:`m - n` rows of that column.\n\n.. note::\n    The case when :math:`m < n` is not supported on the GPU.\n\nArgs:\n    input (Tensor): the matrix :math:`B`\n    A (Tensor): the :math:`m` by :math:`n` matrix :math:`A`\n    out (tuple, optional): the optional destination tensor\n\nReturns:\n    (Tensor, Tensor): A namedtuple (solution, QR) containing:\n\n        - **solution** (*Tensor*): the least squares solution\n        - **QR** (*Tensor*): the details of the QR factorization\n\n.. note::\n\n    The returned matrices will always be transposed, irrespective of the strides\n    of the input matrices. That is, they will have stride `(1, m)` instead of\n    `(m, 1)`.\n\nExample::\n\n    >>> A = torch.tensor([[1., 1, 1],\n                          [2, 3, 4],\n                          [3, 5, 2],\n                          [4, 2, 5],\n                          [5, 4, 3]])\n    >>> B = torch.tensor([[-10., -3],\n                          [ 12, 14],\n                          [ 14, 12],\n                          [ 16, 16],\n                          [ 18, 16]])\n    >>> X, _ = torch.lstsq(B, A)\n    >>> X\n    tensor([[  2.0000,   1.0000],\n            [  1.0000,   1.0000],\n            [  1.0000,   2.0000],\n            [ 10.9635,   4.8501],\n            [  8.9332,   5.2418]])\n')
add_docstr(torch.lt, '\nlt(input, other, out=None) -> Tensor\n\nComputes :math:`\\text{input} < \\text{other}` element-wise.\n\nThe second argument can be a number or a tensor whose shape is\n:ref:`broadcastable <broadcasting-semantics>` with the first argument.\n\nArgs:\n    input (Tensor): the tensor to compare\n    other (Tensor or float): the tensor or value to compare\n    out (Tensor, optional): the output tensor that must be a `BoolTensor`\n\nReturns:\n    Tensor: A `torch.BoolTensor` containing a True at each location where comparison is true\n\nExample::\n\n    >>> torch.lt(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))\n    tensor([[False, False], [True, False]])\n')
add_docstr(torch.lu_solve, '\nlu_solve(input, LU_data, LU_pivots, out=None) -> Tensor\n\nReturns the LU solve of the linear system :math:`Ax = b` using the partially pivoted\nLU factorization of A from :meth:`torch.lu`.\n\nArguments:\n    b (Tensor): the RHS tensor of size :math:`(*, m, k)`, where :math:`*`\n                is zero or more batch dimensions.\n    LU_data (Tensor): the pivoted LU factorization of A from :meth:`torch.lu` of size :math:`(*, m, m)`,\n                       where :math:`*` is zero or more batch dimensions.\n    LU_pivots (IntTensor): the pivots of the LU factorization from :meth:`torch.lu` of size :math:`(*, m)`,\n                           where :math:`*` is zero or more batch dimensions.\n                           The batch dimensions of :attr:`LU_pivots` must be equal to the batch dimensions of\n                           :attr:`LU_data`.\n    {out}\n\nExample::\n\n    >>> A = torch.randn(2, 3, 3)\n    >>> b = torch.randn(2, 3, 1)\n    >>> A_LU = torch.lu(A)\n    >>> x = torch.lu_solve(b, *A_LU)\n    >>> torch.norm(torch.bmm(A, x) - b)\n    tensor(1.00000e-07 *\n           2.8312)\n'.format(**common_args))
add_docstr(torch.masked_select, "\nmasked_select(input, mask, out=None) -> Tensor\n\nReturns a new 1-D tensor which indexes the :attr:`input` tensor according to\nthe boolean mask :attr:`mask` which is a `BoolTensor`.\n\nThe shapes of the :attr:`mask` tensor and the :attr:`input` tensor don't need\nto match, but they must be :ref:`broadcastable <broadcasting-semantics>`.\n\n.. note:: The returned tensor does **not** use the same storage\n          as the original tensor\n\nArgs:\n    {input}\n    mask  (BoolTensor): the tensor containing the binary mask to index with\n    {out}\n\nExample::\n\n    >>> x = torch.randn(3, 4)\n    >>> x\n    tensor([[ 0.3552, -2.3825, -0.8297,  0.3477],\n            [-1.2035,  1.2252,  0.5002,  0.6248],\n            [ 0.1307, -2.0608,  0.1244,  2.0139]])\n    >>> mask = x.ge(0.5)\n    >>> mask\n    tensor([[False, False, False, False],\n            [False, True, True, True],\n            [False, False, False, True]])\n    >>> torch.masked_select(x, mask)\n    tensor([ 1.2252,  0.5002,  0.6248,  2.0139])\n".format(**common_args))
add_docstr(torch.matrix_rank, '\nmatrix_rank(input, tol=None, symmetric=False) -> Tensor\n\nReturns the numerical rank of a 2-D tensor. The method to compute the\nmatrix rank is done using SVD by default. If :attr:`symmetric` is ``True``,\nthen :attr:`input` is assumed to be symmetric, and the computation of the\nrank is done by obtaining the eigenvalues.\n\n:attr:`tol` is the threshold below which the singular values (or the eigenvalues\nwhen :attr:`symmetric` is ``True``) are considered to be 0. If :attr:`tol` is not\nspecified, :attr:`tol` is set to ``S.max() * max(S.size()) * eps`` where `S` is the\nsingular values (or the eigenvalues when :attr:`symmetric` is ``True``), and ``eps``\nis the epsilon value for the datatype of :attr:`input`.\n\nArgs:\n    input (Tensor): the input 2-D tensor\n    tol (float, optional): the tolerance value. Default: ``None``\n    symmetric(bool, optional): indicates whether :attr:`input` is symmetric.\n                               Default: ``False``\n\nExample::\n\n    >>> a = torch.eye(10)\n    >>> torch.matrix_rank(a)\n    tensor(10)\n    >>> b = torch.eye(10)\n    >>> b[0, 0] = 0\n    >>> torch.matrix_rank(b)\n    tensor(9)\n')
add_docstr(torch.matrix_power, '\nmatrix_power(input, n) -> Tensor\n\nReturns the matrix raised to the power :attr:`n` for square matrices.\nFor batch of matrices, each individual matrix is raised to the power :attr:`n`.\n\nIf :attr:`n` is negative, then the inverse of the matrix (if invertible) is\nraised to the power :attr:`n`.  For a batch of matrices, the batched inverse\n(if invertible) is raised to the power :attr:`n`. If :attr:`n` is 0, then an identity matrix\nis returned.\n\nArgs:\n    {input}\n    n (int): the power to raise the matrix to\n\nExample::\n\n    >>> a = torch.randn(2, 2, 2)\n    >>> a\n    tensor([[[-1.9975, -1.9610],\n             [ 0.9592, -2.3364]],\n\n            [[-1.2534, -1.3429],\n             [ 0.4153, -1.4664]]])\n    >>> torch.matrix_power(a, 3)\n    tensor([[[  3.9392, -23.9916],\n             [ 11.7357,  -0.2070]],\n\n            [[  0.2468,  -6.7168],\n             [  2.0774,  -0.8187]]])\n'.format(**common_args))
add_docstr(torch.max, "\n.. function:: max(input) -> Tensor\n\nReturns the maximum value of all elements in the ``input`` tensor.\n\nArgs:\n    {input}\n\nExample::\n\n    >>> a = torch.randn(1, 3)\n    >>> a\n    tensor([[ 0.6763,  0.7445, -2.2369]])\n    >>> torch.max(a)\n    tensor(0.7445)\n\n.. function:: max(input, dim, keepdim=False, out=None) -> (Tensor, LongTensor)\n\nReturns a namedtuple ``(values, indices)`` where ``values`` is the maximum\nvalue of each row of the :attr:`input` tensor in the given dimension\n:attr:`dim`. And ``indices`` is the index location of each maximum value found\n(argmax).\n\n.. warning::\n    ``indices`` does not necessarily contain the first occurrence of each\n    maximal value found, unless it is unique.\n    The exact implementation details are device-specific.\n    Do not expect the same result when run on CPU and GPU in general.\n\nIf ``keepdim`` is ``True``, the output tensors are of the same size\nas ``input`` except in the dimension ``dim`` where they are of size 1.\nOtherwise, ``dim`` is squeezed (see :func:`torch.squeeze`), resulting\nin the output tensors having 1 fewer dimension than ``input``.\n\nArgs:\n    {input}\n    {dim}\n    {keepdim} Default: ``False``.\n    out (tuple, optional): the result tuple of two output tensors (max, max_indices)\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[-1.2360, -0.2942, -0.1222,  0.8475],\n            [ 1.1949, -1.1127, -2.2379, -0.6702],\n            [ 1.5717, -0.9207,  0.1297, -1.8768],\n            [-0.6172,  1.0036, -0.6060, -0.2432]])\n    >>> torch.max(a, 1)\n    torch.return_types.max(values=tensor([0.8475, 1.1949, 1.5717, 1.0036]), indices=tensor([3, 0, 0, 1]))\n\n.. function:: max(input, other, out=None) -> Tensor\n\nEach element of the tensor ``input`` is compared with the corresponding\nelement of the tensor ``other`` and an element-wise maximum is taken.\n\nThe shapes of ``input`` and ``other`` don't need to match,\nbut they must be :ref:`broadcastable <broadcasting-semantics>`.\n\n.. math::\n    \\text{{out}}_i = \\max(\\text{{tensor}}_i, \\text{{other}}_i)\n\n.. note:: When the shapes do not match, the shape of the returned output tensor\n          follows the :ref:`broadcasting rules <broadcasting-semantics>`.\n\nArgs:\n    {input}\n    other (Tensor): the second input tensor\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.2942, -0.7416,  0.2653, -0.1584])\n    >>> b = torch.randn(4)\n    >>> b\n    tensor([ 0.8722, -1.7421, -0.4141, -0.5055])\n    >>> torch.max(a, b)\n    tensor([ 0.8722, -0.7416,  0.2653, -0.1584])\n".format(**single_dim_common))
add_docstr(torch.argmax, '\n.. function:: argmax(input) -> LongTensor\n\nReturns the indices of the maximum value of all elements in the :attr:`input` tensor.\n\nThis is the second value returned by :meth:`torch.max`. See its\ndocumentation for the exact semantics of this method.\n\nArgs:\n    {input}\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[ 1.3398,  0.2663, -0.2686,  0.2450],\n            [-0.7401, -0.8805, -0.3402, -1.1936],\n            [ 0.4907, -1.3948, -1.0691, -0.3132],\n            [-1.6092,  0.5419, -0.2993,  0.3195]])\n    >>> torch.argmax(a)\n    tensor(0)\n\n.. function:: argmax(input, dim, keepdim=False) -> LongTensor\n\nReturns the indices of the maximum values of a tensor across a dimension.\n\nThis is the second value returned by :meth:`torch.max`. See its\ndocumentation for the exact semantics of this method.\n\nArgs:\n    {input}\n    {dim} If ``None``, the argmax of the flattened input is returned.\n    {keepdim} Ignored if ``dim=None``.\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[ 1.3398,  0.2663, -0.2686,  0.2450],\n            [-0.7401, -0.8805, -0.3402, -1.1936],\n            [ 0.4907, -1.3948, -1.0691, -0.3132],\n            [-1.6092,  0.5419, -0.2993,  0.3195]])\n    >>> torch.argmax(a, dim=1)\n    tensor([ 0,  2,  0,  1])\n'.format(**single_dim_common))
add_docstr(torch.mean, '\n.. function:: mean(input) -> Tensor\n\nReturns the mean value of all elements in the :attr:`input` tensor.\n\nArgs:\n    {input}\n\nExample::\n\n    >>> a = torch.randn(1, 3)\n    >>> a\n    tensor([[ 0.2294, -0.5481,  1.3288]])\n    >>> torch.mean(a)\n    tensor(0.3367)\n\n.. function:: mean(input, dim, keepdim=False, out=None) -> Tensor\n\nReturns the mean value of each row of the :attr:`input` tensor in the given\ndimension :attr:`dim`. If :attr:`dim` is a list of dimensions,\nreduce over all of them.\n\n{keepdim_details}\n\nArgs:\n    {input}\n    {dim}\n    {keepdim}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[-0.3841,  0.6320,  0.4254, -0.7384],\n            [-0.9644,  1.0131, -0.6549, -1.4279],\n            [-0.2951, -1.3350, -0.7694,  0.5600],\n            [ 1.0842, -0.9580,  0.3623,  0.2343]])\n    >>> torch.mean(a, 1)\n    tensor([-0.0163, -0.5085, -0.4599,  0.1807])\n    >>> torch.mean(a, 1, True)\n    tensor([[-0.0163],\n            [-0.5085],\n            [-0.4599],\n            [ 0.1807]])\n'.format(**multi_dim_common))
add_docstr(torch.median, '\n.. function:: median(input) -> Tensor\n\nReturns the median value of all elements in the :attr:`input` tensor.\n\nArgs:\n    {input}\n\nExample::\n\n    >>> a = torch.randn(1, 3)\n    >>> a\n    tensor([[ 1.5219, -1.5212,  0.2202]])\n    >>> torch.median(a)\n    tensor(0.2202)\n\n.. function:: median(input, dim=-1, keepdim=False, out=None) -> (Tensor, LongTensor)\n\nReturns a namedtuple ``(values, indices)`` where ``values`` is the median\nvalue of each row of the :attr:`input` tensor in the given dimension\n:attr:`dim`. And ``indices`` is the index location of each median value found.\n\nBy default, :attr:`dim` is the last dimension of the :attr:`input` tensor.\n\nIf :attr:`keepdim` is ``True``, the output tensors are of the same size\nas :attr:`input` except in the dimension :attr:`dim` where they are of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in\nthe outputs tensor having 1 fewer dimension than :attr:`input`.\n\nArgs:\n    {input}\n    {dim}\n    {keepdim}\n    out (tuple, optional): the result tuple of two output tensors (max, max_indices)\n\nExample::\n\n    >>> a = torch.randn(4, 5)\n    >>> a\n    tensor([[ 0.2505, -0.3982, -0.9948,  0.3518, -1.3131],\n            [ 0.3180, -0.6993,  1.0436,  0.0438,  0.2270],\n            [-0.2751,  0.7303,  0.2192,  0.3321,  0.2488],\n            [ 1.0778, -1.9510,  0.7048,  0.4742, -0.7125]])\n    >>> torch.median(a, 1)\n    torch.return_types.median(values=tensor([-0.3982,  0.2270,  0.2488,  0.4742]), indices=tensor([1, 4, 4, 3]))\n'.format(**single_dim_common))
add_docstr(torch.min, "\n.. function:: min(input) -> Tensor\n\nReturns the minimum value of all elements in the :attr:`input` tensor.\n\nArgs:\n    {input}\n\nExample::\n\n    >>> a = torch.randn(1, 3)\n    >>> a\n    tensor([[ 0.6750,  1.0857,  1.7197]])\n    >>> torch.min(a)\n    tensor(0.6750)\n\n.. function:: min(input, dim, keepdim=False, out=None) -> (Tensor, LongTensor)\n\nReturns a namedtuple ``(values, indices)`` where ``values`` is the minimum\nvalue of each row of the :attr:`input` tensor in the given dimension\n:attr:`dim`. And ``indices`` is the index location of each minimum value found\n(argmin).\n\n.. warning::\n    ``indices`` does not necessarily contain the first occurrence of each\n    minimal value found, unless it is unique.\n    The exact implementation details are device-specific.\n    Do not expect the same result when run on CPU and GPU in general.\n\nIf :attr:`keepdim` is ``True``, the output tensors are of the same size as\n:attr:`input` except in the dimension :attr:`dim` where they are of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in\nthe output tensors having 1 fewer dimension than :attr:`input`.\n\nArgs:\n    {input}\n    {dim}\n    {keepdim}\n    out (tuple, optional): the tuple of two output tensors (min, min_indices)\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[-0.6248,  1.1334, -1.1899, -0.2803],\n            [-1.4644, -0.2635, -0.3651,  0.6134],\n            [ 0.2457,  0.0384,  1.0128,  0.7015],\n            [-0.1153,  2.9849,  2.1458,  0.5788]])\n    >>> torch.min(a, 1)\n    torch.return_types.min(values=tensor([-1.1899, -1.4644,  0.0384, -0.1153]), indices=tensor([2, 0, 1, 0]))\n\n.. function:: min(input, other, out=None) -> Tensor\n\nEach element of the tensor :attr:`input` is compared with the corresponding\nelement of the tensor :attr:`other` and an element-wise minimum is taken.\nThe resulting tensor is returned.\n\nThe shapes of :attr:`input` and :attr:`other` don't need to match,\nbut they must be :ref:`broadcastable <broadcasting-semantics>`.\n\n.. math::\n    \\text{{out}}_i = \\min(\\text{{tensor}}_i, \\text{{other}}_i)\n\n.. note:: When the shapes do not match, the shape of the returned output tensor\n          follows the :ref:`broadcasting rules <broadcasting-semantics>`.\n\nArgs:\n    {input}\n    other (Tensor): the second input tensor\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.8137, -1.1740, -0.6460,  0.6308])\n    >>> b = torch.randn(4)\n    >>> b\n    tensor([-0.1369,  0.1555,  0.4019, -0.1929])\n    >>> torch.min(a, b)\n    tensor([-0.1369, -1.1740, -0.6460, -0.1929])\n".format(**single_dim_common))
add_docstr(torch.argmin, '\n.. function:: argmin(input) -> LongTensor\n\nReturns the indices of the minimum value of all elements in the :attr:`input` tensor.\n\nThis is the second value returned by :meth:`torch.min`. See its\ndocumentation for the exact semantics of this method.\n\nArgs:\n    {input}\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[ 0.1139,  0.2254, -0.1381,  0.3687],\n            [ 1.0100, -1.1975, -0.0102, -0.4732],\n            [-0.9240,  0.1207, -0.7506, -1.0213],\n            [ 1.7809, -1.2960,  0.9384,  0.1438]])\n    >>> torch.argmin(a)\n    tensor(13)\n\n.. function:: argmin(input, dim, keepdim=False, out=None) -> LongTensor\n\nReturns the indices of the minimum values of a tensor across a dimension.\n\nThis is the second value returned by :meth:`torch.min`. See its\ndocumentation for the exact semantics of this method.\n\nArgs:\n    {input}\n    {dim} If ``None``, the argmin of the flattened input is returned.\n    {keepdim} Ignored if ``dim=None``.\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[ 0.1139,  0.2254, -0.1381,  0.3687],\n            [ 1.0100, -1.1975, -0.0102, -0.4732],\n            [-0.9240,  0.1207, -0.7506, -1.0213],\n            [ 1.7809, -1.2960,  0.9384,  0.1438]])\n    >>> torch.argmin(a, dim=1)\n    tensor([ 2,  1,  3,  1])\n'.format(**single_dim_common))
add_docstr(torch.mm, '\nmm(input, mat2, out=None) -> Tensor\n\nPerforms a matrix multiplication of the matrices :attr:`input` and :attr:`mat2`.\n\nIf :attr:`input` is a :math:`(n \\times m)` tensor, :attr:`mat2` is a\n:math:`(m \\times p)` tensor, :attr:`out` will be a :math:`(n \\times p)` tensor.\n\n.. note:: This function does not :ref:`broadcast <broadcasting-semantics>`.\n          For broadcasting matrix products, see :func:`torch.matmul`.\n\nArgs:\n    input (Tensor): the first matrix to be multiplied\n    mat2 (Tensor): the second matrix to be multiplied\n    {out}\n\nExample::\n\n    >>> mat1 = torch.randn(2, 3)\n    >>> mat2 = torch.randn(3, 3)\n    >>> torch.mm(mat1, mat2)\n    tensor([[ 0.4851,  0.5037, -0.3633],\n            [-0.0760, -3.6705,  2.4784]])\n'.format(**common_args))
add_docstr(torch.matmul, '\nmatmul(input, other, out=None) -> Tensor\n\nMatrix product of two tensors.\n\nThe behavior depends on the dimensionality of the tensors as follows:\n\n- If both tensors are 1-dimensional, the dot product (scalar) is returned.\n- If both arguments are 2-dimensional, the matrix-matrix product is returned.\n- If the first argument is 1-dimensional and the second argument is 2-dimensional,\n  a 1 is prepended to its dimension for the purpose of the matrix multiply.\n  After the matrix multiply, the prepended dimension is removed.\n- If the first argument is 2-dimensional and the second argument is 1-dimensional,\n  the matrix-vector product is returned.\n- If both arguments are at least 1-dimensional and at least one argument is\n  N-dimensional (where N > 2), then a batched matrix multiply is returned.  If the first\n  argument is 1-dimensional, a 1 is prepended to its dimension for the purpose of the\n  batched matrix multiply and removed after.  If the second argument is 1-dimensional, a\n  1 is appended to its dimension for the purpose of the batched matrix multiple and removed after.\n  The non-matrix (i.e. batch) dimensions are :ref:`broadcasted <broadcasting-semantics>` (and thus\n  must be broadcastable).  For example, if :attr:`input` is a\n  :math:`(j \\times 1 \\times n \\times m)` tensor and :attr:`other` is a :math:`(k \\times m \\times p)`\n  tensor, :attr:`out` will be an :math:`(j \\times k \\times n \\times p)` tensor.\n\n.. note::\n\n    The 1-dimensional dot product version of this function does not support an :attr:`out` parameter.\n\nArguments:\n    input (Tensor): the first tensor to be multiplied\n    other (Tensor): the second tensor to be multiplied\n    {out}\n\nExample::\n\n    >>> # vector x vector\n    >>> tensor1 = torch.randn(3)\n    >>> tensor2 = torch.randn(3)\n    >>> torch.matmul(tensor1, tensor2).size()\n    torch.Size([])\n    >>> # matrix x vector\n    >>> tensor1 = torch.randn(3, 4)\n    >>> tensor2 = torch.randn(4)\n    >>> torch.matmul(tensor1, tensor2).size()\n    torch.Size([3])\n    >>> # batched matrix x broadcasted vector\n    >>> tensor1 = torch.randn(10, 3, 4)\n    >>> tensor2 = torch.randn(4)\n    >>> torch.matmul(tensor1, tensor2).size()\n    torch.Size([10, 3])\n    >>> # batched matrix x batched matrix\n    >>> tensor1 = torch.randn(10, 3, 4)\n    >>> tensor2 = torch.randn(10, 4, 5)\n    >>> torch.matmul(tensor1, tensor2).size()\n    torch.Size([10, 3, 5])\n    >>> # batched matrix x broadcasted matrix\n    >>> tensor1 = torch.randn(10, 3, 4)\n    >>> tensor2 = torch.randn(4, 5)\n    >>> torch.matmul(tensor1, tensor2).size()\n    torch.Size([10, 3, 5])\n\n'.format(**common_args))
add_docstr(torch.mode, '\nmode(input, dim=-1, keepdim=False, out=None) -> (Tensor, LongTensor)\n\nReturns a namedtuple ``(values, indices)`` where ``values`` is the mode\nvalue of each row of the :attr:`input` tensor in the given dimension\n:attr:`dim`, i.e. a value which appears most often\nin that row, and ``indices`` is the index location of each mode value found.\n\nBy default, :attr:`dim` is the last dimension of the :attr:`input` tensor.\n\nIf :attr:`keepdim` is ``True``, the output tensors are of the same size as\n:attr:`input` except in the dimension :attr:`dim` where they are of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting\nin the output tensors having 1 fewer dimension than :attr:`input`.\n\n.. note:: This function is not defined for ``torch.cuda.Tensor`` yet.\n\nArgs:\n    {input}\n    {dim}\n    {keepdim}\n    out (tuple, optional): the result tuple of two output tensors (values, indices)\n\nExample::\n\n    >>> a = torch.randint(10, (5,))\n    >>> a\n    tensor([6, 5, 1, 0, 2])\n    >>> b = a + (torch.randn(50, 1) * 5).long()\n    >>> torch.mode(b, 0)\n    torch.return_types.mode(values=tensor([6, 5, 1, 0, 2]), indices=tensor([2, 2, 2, 2, 2]))\n'.format(**single_dim_common))
add_docstr(torch.mul, '\n.. function:: mul(input, other, out=None)\n\nMultiplies each element of the input :attr:`input` with the scalar\n:attr:`other` and returns a new resulting tensor.\n\n.. math::\n    \\text{out}_i = \\text{other} \\times \\text{input}_i\n' + '\nIf :attr:`input` is of type `FloatTensor` or `DoubleTensor`, :attr:`other`\nshould be a real number, otherwise it should be an integer\n\nArgs:\n    {input}\n    value (Number): the number to be multiplied to each element of :attr:`input`\n    {out}\n\nExample::\n\n    >>> a = torch.randn(3)\n    >>> a\n    tensor([ 0.2015, -0.4255,  2.6087])\n    >>> torch.mul(a, 100)\n    tensor([  20.1494,  -42.5491,  260.8663])\n\n.. function:: mul(input, other, out=None)\n\nEach element of the tensor :attr:`input` is multiplied by the corresponding\nelement of the Tensor :attr:`other`. The resulting tensor is returned.\n\nThe shapes of :attr:`input` and :attr:`other` must be\n:ref:`broadcastable <broadcasting-semantics>`.\n\n.. math::\n    \\text{out}_i = \\text{input}_i \\times \\text{other}_i\n' + '\nArgs:\n    input (Tensor): the first multiplicand tensor\n    other (Tensor): the second multiplicand tensor\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4, 1)\n    >>> a\n    tensor([[ 1.1207],\n            [-0.3137],\n            [ 0.0700],\n            [ 0.8378]])\n    >>> b = torch.randn(1, 4)\n    >>> b\n    tensor([[ 0.5146,  0.1216, -0.5244,  2.2382]])\n    >>> torch.mul(a, b)\n    tensor([[ 0.5767,  0.1363, -0.5877,  2.5083],\n            [-0.1614, -0.0382,  0.1645, -0.7021],\n            [ 0.0360,  0.0085, -0.0367,  0.1567],\n            [ 0.4312,  0.1019, -0.4394,  1.8753]])\n'.format(**common_args))
add_docstr(torch.multinomial, '\nmultinomial(input, num_samples, replacement=False, *, generator=None, out=None) -> LongTensor\n\nReturns a tensor where each row contains :attr:`num_samples` indices sampled\nfrom the multinomial probability distribution located in the corresponding row\nof tensor :attr:`input`.\n\n.. note::\n    The rows of :attr:`input` do not need to sum to one (in which case we use\n    the values as weights), but must be non-negative, finite and have\n    a non-zero sum.\n\nIndices are ordered from left to right according to when each was sampled\n(first samples are placed in first column).\n\nIf :attr:`input` is a vector, :attr:`out` is a vector of size :attr:`num_samples`.\n\nIf :attr:`input` is a matrix with `m` rows, :attr:`out` is an matrix of shape\n:math:`(m \\times \\text{{num\\_samples}})`.\n\nIf replacement is ``True``, samples are drawn with replacement.\n\nIf not, they are drawn without replacement, which means that when a\nsample index is drawn for a row, it cannot be drawn again for that row.\n\n.. note::\n    When drawn without replacement, :attr:`num_samples` must be lower than\n    number of non-zero elements in :attr:`input` (or the min number of non-zero\n    elements in each row of :attr:`input` if it is a matrix).\n\nArgs:\n    input (Tensor): the input tensor containing probabilities\n    num_samples (int): number of samples to draw\n    replacement (bool, optional): whether to draw with replacement or not\n    {generator}\n    {out}\n\nExample::\n\n    >>> weights = torch.tensor([0, 10, 3, 0], dtype=torch.float) # create a tensor of weights\n    >>> torch.multinomial(weights, 2)\n    tensor([1, 2])\n    >>> torch.multinomial(weights, 4) # ERROR!\n    RuntimeError: invalid argument 2: invalid multinomial distribution (with replacement=False,\n    not enough non-negative category to sample) at ../aten/src/TH/generic/THTensorRandom.cpp:320\n    >>> torch.multinomial(weights, 4, replacement=True)\n    tensor([ 2,  1,  1,  1])\n'.format(**common_args))
add_docstr(torch.mv, '\nmv(input, vec, out=None) -> Tensor\n\nPerforms a matrix-vector product of the matrix :attr:`input` and the vector\n:attr:`vec`.\n\nIf :attr:`input` is a :math:`(n \\times m)` tensor, :attr:`vec` is a 1-D tensor of\nsize :math:`m`, :attr:`out` will be 1-D of size :math:`n`.\n\n.. note:: This function does not :ref:`broadcast <broadcasting-semantics>`.\n\nArgs:\n    input (Tensor): matrix to be multiplied\n    vec (Tensor): vector to be multiplied\n    {out}\n\nExample::\n\n    >>> mat = torch.randn(2, 3)\n    >>> vec = torch.randn(3)\n    >>> torch.mv(mat, vec)\n    tensor([ 1.0404, -0.6361])\n'.format(**common_args))
add_docstr(torch.mvlgamma, '\nmvlgamma(input, p) -> Tensor\n\nComputes the `multivariate log-gamma function\n<https://en.wikipedia.org/wiki/Multivariate_gamma_function>`_) with dimension\n:math:`p` element-wise, given by\n\n.. math::\n    \\log(\\Gamma_{p}(a)) = C + \\displaystyle \\sum_{i=1}^{p} \\log\\left(\\Gamma\\left(a - \\frac{i - 1}{2}\\right)\\right)\n\nwhere :math:`C = \\log(\\pi) \\times \\frac{p (p - 1)}{4}` and :math:`\\Gamma(\\cdot)` is the Gamma function.\n\nAll elements must be greater than :math:`\\frac{p - 1}{2}`, otherwise an error would be thrown.\n\nArgs:\n    input (Tensor): the tensor to compute the multivariate log-gamma function\n    p (int): the number of dimensions\n\nExample::\n\n    >>> a = torch.empty(2, 3).uniform_(1, 2)\n    >>> a\n    tensor([[1.6835, 1.8474, 1.1929],\n            [1.0475, 1.7162, 1.4180]])\n    >>> torch.mvlgamma(a, 2)\n    tensor([[0.3928, 0.4007, 0.7586],\n            [1.0311, 0.3901, 0.5049]])\n')
add_docstr(torch.narrow, '\nnarrow(input, dim, start, length) -> Tensor\n\nReturns a new tensor that is a narrowed version of :attr:`input` tensor. The\ndimension :attr:`dim` is input from :attr:`start` to :attr:`start + length`. The\nreturned tensor and :attr:`input` tensor share the same underlying storage.\n\nArgs:\n    input (Tensor): the tensor to narrow\n    dim (int): the dimension along which to narrow\n    start (int): the starting dimension\n    length (int): the distance to the ending dimension\n\nExample::\n\n    >>> x = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> torch.narrow(x, 0, 0, 2)\n    tensor([[ 1,  2,  3],\n            [ 4,  5,  6]])\n    >>> torch.narrow(x, 1, 1, 2)\n    tensor([[ 2,  3],\n            [ 5,  6],\n            [ 8,  9]])\n')
add_docstr(torch.ne, '\nne(input, other, out=None) -> Tensor\n\nComputes :math:`input \\neq other` element-wise.\n\nThe second argument can be a number or a tensor whose shape is\n:ref:`broadcastable <broadcasting-semantics>` with the first argument.\n\nArgs:\n    input (Tensor): the tensor to compare\n    other (Tensor or float): the tensor or value to compare\n    out (Tensor, optional): the output tensor that must be a `BoolTensor`\n\nReturns:\n    Tensor: A ``torch.BoolTensor`` containing a True at each location where comparison is true.\n\nExample::\n\n    >>> torch.ne(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))\n    tensor([[False, True], [True, False]])\n')
add_docstr(torch.neg, '\nneg(input, out=None) -> Tensor\n\nReturns a new tensor with the negative of the elements of :attr:`input`.\n\n.. math::\n    \\text{out} = -1 \\times \\text{input}\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(5)\n    >>> a\n    tensor([ 0.0090, -0.2262, -0.0682, -0.2866,  0.3940])\n    >>> torch.neg(a)\n    tensor([-0.0090,  0.2262,  0.0682,  0.2866, -0.3940])\n'.format(**common_args))
add_docstr(torch.nonzero, '\nnonzero(input, *, out=None, as_tuple=False) -> LongTensor or tuple of LongTensors\n\n.. note::\n    :func:`torch.nonzero(..., as_tuple=False) <torch.nonzero>` (default) returns a\n    2-D tensor where each row is the index for a nonzero value.\n\n    :func:`torch.nonzero(..., as_tuple=True) <torch.nonzero>` returns a tuple of 1-D\n    index tensors, allowing for advanced indexing, so ``x[x.nonzero(as_tuple=True)]``\n    gives all nonzero values of tensor ``x``. Of the returned tuple, each index tensor\n    contains nonzero indices for a certain dimension.\n\n    See below for more details on the two behaviors.\n\n\n**When** :attr:`as_tuple` **is ``False`` (default)**:\n\nReturns a tensor containing the indices of all non-zero elements of\n:attr:`input`.  Each row in the result contains the indices of a non-zero\nelement in :attr:`input`. The result is sorted lexicographically, with\nthe last index changing the fastest (C-style).\n\nIf :attr:`input` has :math:`n` dimensions, then the resulting indices tensor\n:attr:`out` is of size :math:`(z \\times n)`, where :math:`z` is the total number of\nnon-zero elements in the :attr:`input` tensor.\n\n**When** :attr:`as_tuple` **is ``True``**:\n\nReturns a tuple of 1-D tensors, one for each dimension in :attr:`input`,\neach containing the indices (in that dimension) of all non-zero elements of\n:attr:`input` .\n\nIf :attr:`input` has :math:`n` dimensions, then the resulting tuple contains :math:`n`\ntensors of size :math:`z`, where :math:`z` is the total number of\nnon-zero elements in the :attr:`input` tensor.\n\nAs a special case, when :attr:`input` has zero dimensions and a nonzero scalar\nvalue, it is treated as a one-dimensional tensor with one element.\n\nArgs:\n    {input}\n    out (LongTensor, optional): the output tensor containing indices\n\nReturns:\n    LongTensor or tuple of LongTensor: If :attr:`as_tuple` is ``False``, the output\n    tensor containing indices. If :attr:`as_tuple` is ``True``, one 1-D tensor for\n    each dimension, containing the indices of each nonzero element along that\n    dimension.\n\nExample::\n\n    >>> torch.nonzero(torch.tensor([1, 1, 1, 0, 1]))\n    tensor([[ 0],\n            [ 1],\n            [ 2],\n            [ 4]])\n    >>> torch.nonzero(torch.tensor([[0.6, 0.0, 0.0, 0.0],\n                                    [0.0, 0.4, 0.0, 0.0],\n                                    [0.0, 0.0, 1.2, 0.0],\n                                    [0.0, 0.0, 0.0,-0.4]]))\n    tensor([[ 0,  0],\n            [ 1,  1],\n            [ 2,  2],\n            [ 3,  3]])\n    >>> torch.nonzero(torch.tensor([1, 1, 1, 0, 1]), as_tuple=True)\n    (tensor([0, 1, 2, 4]),)\n    >>> torch.nonzero(torch.tensor([[0.6, 0.0, 0.0, 0.0],\n                                    [0.0, 0.4, 0.0, 0.0],\n                                    [0.0, 0.0, 1.2, 0.0],\n                                    [0.0, 0.0, 0.0,-0.4]]), as_tuple=True)\n    (tensor([0, 1, 2, 3]), tensor([0, 1, 2, 3]))\n    >>> torch.nonzero(torch.tensor(5), as_tuple=True)\n    (tensor([0]),)\n'.format(**common_args))
add_docstr(torch.normal, "\n.. function:: normal(mean, std, *, generator=None, out=None) -> Tensor\n\nReturns a tensor of random numbers drawn from separate normal distributions\nwhose mean and standard deviation are given.\n\nThe :attr:`mean` is a tensor with the mean of\neach output element's normal distribution\n\nThe :attr:`std` is a tensor with the standard deviation of\neach output element's normal distribution\n\nThe shapes of :attr:`mean` and :attr:`std` don't need to match, but the\ntotal number of elements in each tensor need to be the same.\n\n.. note:: When the shapes do not match, the shape of :attr:`mean`\n          is used as the shape for the returned output tensor\n\nArgs:\n    mean (Tensor): the tensor of per-element means\n    std (Tensor): the tensor of per-element standard deviations\n    {generator}\n    {out}\n\nExample::\n\n    >>> torch.normal(mean=torch.arange(1., 11.), std=torch.arange(1, 0, -0.1))\n    tensor([  1.0425,   3.5672,   2.7969,   4.2925,   4.7229,   6.2134,\n              8.0505,   8.1408,   9.0563,  10.0566])\n\n.. function:: normal(mean=0.0, std, out=None) -> Tensor\n\nSimilar to the function above, but the means are shared among all drawn\nelements.\n\nArgs:\n    mean (float, optional): the mean for all distributions\n    std (Tensor): the tensor of per-element standard deviations\n    {out}\n\nExample::\n\n    >>> torch.normal(mean=0.5, std=torch.arange(1., 6.))\n    tensor([-1.2793, -1.0732, -2.0687,  5.1177, -1.2303])\n\n.. function:: normal(mean, std=1.0, out=None) -> Tensor\n\nSimilar to the function above, but the standard-deviations are shared among\nall drawn elements.\n\nArgs:\n    mean (Tensor): the tensor of per-element means\n    std (float, optional): the standard deviation for all distributions\n    out (Tensor, optional): the output tensor\n\nExample::\n\n    >>> torch.normal(mean=torch.arange(1., 6.))\n    tensor([ 1.1552,  2.6148,  2.6535,  5.8318,  4.2361])\n\n.. function:: normal(mean, std, size, *, out=None) -> Tensor\n\nSimilar to the function above, but the means and standard deviations are shared\namong all drawn elements. The resulting tensor has size given by :attr:`size`.\n\nArgs:\n    mean (float): the mean for all distributions\n    std (float): the standard deviation for all distributions\n    size (int...): a sequence of integers defining the shape of the output tensor.\n    {out}\n\nExample::\n\n    >>> torch.normal(2, 3, size=(1, 4))\n    tensor([[-1.3987, -1.9544,  3.6048,  0.7909]])\n".format(**common_args))
add_docstr(torch.numel, '\nnumel(input) -> int\n\nReturns the total number of elements in the :attr:`input` tensor.\n\nArgs:\n    {input}\n\nExample::\n\n    >>> a = torch.randn(1, 2, 3, 4, 5)\n    >>> torch.numel(a)\n    120\n    >>> a = torch.zeros(4,4)\n    >>> torch.numel(a)\n    16\n\n'.format(**common_args))
add_docstr(torch.ones, '\nones(*size, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nReturns a tensor filled with the scalar value `1`, with the shape defined\nby the variable argument :attr:`size`.\n\nArgs:\n    size (int...): a sequence of integers defining the shape of the output tensor.\n        Can be a variable number of arguments or a collection like a list or tuple.\n    {out}\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n\nExample::\n\n    >>> torch.ones(2, 3)\n    tensor([[ 1.,  1.,  1.],\n            [ 1.,  1.,  1.]])\n\n    >>> torch.ones(5)\n    tensor([ 1.,  1.,  1.,  1.,  1.])\n\n'.format(**factory_common_args))
add_docstr(torch.ones_like, '\nones_like(input, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns a tensor filled with the scalar value `1`, with the same size as\n:attr:`input`. ``torch.ones_like(input)`` is equivalent to\n``torch.ones(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.\n\n.. warning::\n    As of 0.4, this function does not support an :attr:`out` keyword. As an alternative,\n    the old ``torch.ones_like(input, out=output)`` is equivalent to\n    ``torch.ones(input.size(), out=output)``.\n\nArgs:\n    {input}\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n    {memory_format}\n\nExample::\n\n    >>> input = torch.empty(2, 3)\n    >>> torch.ones_like(input)\n    tensor([[ 1.,  1.,  1.],\n            [ 1.,  1.,  1.]])\n'.format(**factory_like_common_args))
add_docstr(torch.orgqr, '\norgqr(input, input2) -> Tensor\n\nComputes the orthogonal matrix `Q` of a QR factorization, from the `(input, input2)`\ntuple returned by :func:`torch.geqrf`.\n\nThis directly calls the underlying LAPACK function `?orgqr`.\nSee `LAPACK documentation for orgqr`_ for further details.\n\nArgs:\n    input (Tensor): the `a` from :func:`torch.geqrf`.\n    input2 (Tensor): the `tau` from :func:`torch.geqrf`.\n\n.. _LAPACK documentation for orgqr:\n    https://software.intel.com/en-us/mkl-developer-reference-c-orgqr\n\n')
add_docstr(torch.ormqr, '\normqr(input, input2, input3, left=True, transpose=False) -> Tensor\n\nMultiplies `mat` (given by :attr:`input3`) by the orthogonal `Q` matrix of the QR factorization\nformed by :func:`torch.geqrf` that is represented by `(a, tau)` (given by (:attr:`input`, :attr:`input2`)).\n\nThis directly calls the underlying LAPACK function `?ormqr`.\nSee `LAPACK documentation for ormqr`_ for further details.\n\nArgs:\n    input (Tensor): the `a` from :func:`torch.geqrf`.\n    input2 (Tensor): the `tau` from :func:`torch.geqrf`.\n    input3 (Tensor): the matrix to be multiplied.\n\n.. _LAPACK documentation for ormqr:\n    https://software.intel.com/en-us/mkl-developer-reference-c-ormqr\n\n')
add_docstr(torch.poisson, '\npoisson(input *, generator=None) -> Tensor\n\nReturns a tensor of the same size as :attr:`input` with each element\nsampled from a Poisson distribution with rate parameter given by the corresponding\nelement in :attr:`input` i.e.,\n\n.. math::\n    \\text{{out}}_i \\sim \\text{{Poisson}}(\\text{{input}}_i)\n\nArgs:\n    input (Tensor): the input tensor containing the rates of the Poisson distribution\n    {generator}\n\nExample::\n\n    >>> rates = torch.rand(4, 4) * 5  # rate parameter between 0 and 5\n    >>> torch.poisson(rates)\n    tensor([[9., 1., 3., 5.],\n            [8., 6., 6., 0.],\n            [0., 4., 5., 3.],\n            [2., 1., 4., 2.]])\n'.format(**common_args))
add_docstr(torch.polygamma, '\npolygamma(n, input, out=None) -> Tensor\n\nComputes the :math:`n^{th}` derivative of the digamma function on :attr:`input`.\n:math:`n \\geq 0` is called the order of the polygamma function.\n\n.. math::\n    \\psi^{(n)}(x) = \\frac{d^{(n)}}{dx^{(n)}} \\psi(x)\n\n.. note::\n    This function is not implemented for :math:`n \\geq 2`.\n' + '\nArgs:\n    n (int): the order of the polygamma function\n    {input}\n    {out}\n\nExample::\n    >>> a = torch.tensor([1, 0.5])\n    >>> torch.polygamma(1, a)\n    tensor([1.64493, 4.9348])\n'.format(**common_args))
add_docstr(torch.pow, '\n.. function:: pow(input, exponent, out=None) -> Tensor\n\nTakes the power of each element in :attr:`input` with :attr:`exponent` and\nreturns a tensor with the result.\n\n:attr:`exponent` can be either a single ``float`` number or a `Tensor`\nwith the same number of elements as :attr:`input`.\n\nWhen :attr:`exponent` is a scalar value, the operation applied is:\n\n.. math::\n    \\text{out}_i = x_i ^ \\text{exponent}\n\nWhen :attr:`exponent` is a tensor, the operation applied is:\n\n.. math::\n    \\text{out}_i = x_i ^ {\\text{exponent}_i}\n' + '\nWhen :attr:`exponent` is a tensor, the shapes of :attr:`input`\nand :attr:`exponent` must be :ref:`broadcastable <broadcasting-semantics>`.\n\nArgs:\n    {input}\n    exponent (float or tensor): the exponent value\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.4331,  1.2475,  0.6834, -0.2791])\n    >>> torch.pow(a, 2)\n    tensor([ 0.1875,  1.5561,  0.4670,  0.0779])\n    >>> exp = torch.arange(1., 5.)\n\n    >>> a = torch.arange(1., 5.)\n    >>> a\n    tensor([ 1.,  2.,  3.,  4.])\n    >>> exp\n    tensor([ 1.,  2.,  3.,  4.])\n    >>> torch.pow(a, exp)\n    tensor([   1.,    4.,   27.,  256.])\n\n.. function:: pow(self, exponent, out=None) -> Tensor\n\n:attr:`self` is a scalar ``float`` value, and :attr:`exponent` is a tensor.\nThe returned tensor :attr:`out` is of the same shape as :attr:`exponent`\n\nThe operation applied is:\n\n.. math::\n    \\text{{out}}_i = \\text{{self}} ^ {{\\text{{exponent}}_i}}\n\nArgs:\n    self (float): the scalar base value for the power operation\n    exponent (Tensor): the exponent tensor\n    {out}\n\nExample::\n\n    >>> exp = torch.arange(1., 5.)\n    >>> base = 2\n    >>> torch.pow(base, exp)\n    tensor([  2.,   4.,   8.,  16.])\n'.format(**common_args))
add_docstr(torch.prod, '\n.. function:: prod(input, dtype=None) -> Tensor\n\nReturns the product of all elements in the :attr:`input` tensor.\n\nArgs:\n    {input}\n    {dtype}\n\nExample::\n\n    >>> a = torch.randn(1, 3)\n    >>> a\n    tensor([[-0.8020,  0.5428, -1.5854]])\n    >>> torch.prod(a)\n    tensor(0.6902)\n\n.. function:: prod(input, dim, keepdim=False, dtype=None) -> Tensor\n\nReturns the product of each row of the :attr:`input` tensor in the given\ndimension :attr:`dim`.\n\n{keepdim_details}\n\nArgs:\n    {input}\n    {dim}\n    {keepdim}\n    {dtype}\n\nExample::\n\n    >>> a = torch.randn(4, 2)\n    >>> a\n    tensor([[ 0.5261, -0.3837],\n            [ 1.1857, -0.2498],\n            [-1.1646,  0.0705],\n            [ 1.1131, -1.0629]])\n    >>> torch.prod(a, 1)\n    tensor([-0.2018, -0.2962, -0.0821, -1.1831])\n'.format(**single_dim_common))
add_docstr(torch.promote_types, '\npromote_types(type1, type2) -> dtype\n\nReturns the :class:`torch.dtype` with the smallest size and scalar kind that is\nnot smaller nor of lower kind than either `type1` or `type2`. See type promotion\n:ref:`documentation <type-promotion-doc>` for more information on the type\npromotion logic.\n\nArgs:\n    type1 (:class:`torch.dtype`)\n    type2 (:class:`torch.dtype`)\n\nExample::\n\n    >>> torch.promote_types(torch.int32, torch.float32))\n    torch.float32\n    >>> torch.promote_types(torch.uint8, torch.long)\n    torch.long\n')
add_docstr(torch.qr, '\nqr(input, some=True, out=None) -> (Tensor, Tensor)\n\nComputes the QR decomposition of a matrix or a batch of matrices :attr:`input`,\nand returns a namedtuple (Q, R) of tensors such that :math:`\\text{input} = Q R`\nwith :math:`Q` being an orthogonal matrix or batch of orthogonal matrices and\n:math:`R` being an upper triangular matrix or batch of upper triangular matrices.\n\nIf :attr:`some` is ``True``, then this function returns the thin (reduced) QR factorization.\nOtherwise, if :attr:`some` is ``False``, this function returns the complete QR factorization.\n\n.. note:: precision may be lost if the magnitudes of the elements of :attr:`input`\n          are large\n\n.. note:: While it should always give you a valid decomposition, it may not\n          give you the same one across platforms - it will depend on your\n          LAPACK implementation.\n\nArgs:\n    input (Tensor): the input tensor of size :math:`(*, m, n)` where `*` is zero or more\n                batch dimensions consisting of matrices of dimension :math:`m \\times n`.\n    some (bool, optional): Set to ``True`` for reduced QR decomposition and ``False`` for\n                complete QR decomposition.\n    out (tuple, optional): tuple of `Q` and `R` tensors\n                satisfying :code:`input = torch.matmul(Q, R)`.\n                The dimensions of `Q` and `R` are :math:`(*, m, k)` and :math:`(*, k, n)`\n                respectively, where :math:`k = \\min(m, n)` if :attr:`some:` is ``True`` and\n                :math:`k = m` otherwise.\n\nExample::\n\n    >>> a = torch.tensor([[12., -51, 4], [6, 167, -68], [-4, 24, -41]])\n    >>> q, r = torch.qr(a)\n    >>> q\n    tensor([[-0.8571,  0.3943,  0.3314],\n            [-0.4286, -0.9029, -0.0343],\n            [ 0.2857, -0.1714,  0.9429]])\n    >>> r\n    tensor([[ -14.0000,  -21.0000,   14.0000],\n            [   0.0000, -175.0000,   70.0000],\n            [   0.0000,    0.0000,  -35.0000]])\n    >>> torch.mm(q, r).round()\n    tensor([[  12.,  -51.,    4.],\n            [   6.,  167.,  -68.],\n            [  -4.,   24.,  -41.]])\n    >>> torch.mm(q.t(), q).round()\n    tensor([[ 1.,  0.,  0.],\n            [ 0.,  1., -0.],\n            [ 0., -0.,  1.]])\n    >>> a = torch.randn(3, 4, 5)\n    >>> q, r = torch.qr(a, some=False)\n    >>> torch.allclose(torch.matmul(q, r), a)\n    True\n    >>> torch.allclose(torch.matmul(q.transpose(-2, -1), q), torch.eye(5))\n    True\n')
add_docstr(torch.rand, '\nrand(*size, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nReturns a tensor filled with random numbers from a uniform distribution\non the interval :math:`[0, 1)`\n\nThe shape of the tensor is defined by the variable argument :attr:`size`.\n\nArgs:\n    size (int...): a sequence of integers defining the shape of the output tensor.\n        Can be a variable number of arguments or a collection like a list or tuple.\n    {out}\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n\nExample::\n\n    >>> torch.rand(4)\n    tensor([ 0.5204,  0.2503,  0.3525,  0.5673])\n    >>> torch.rand(2, 3)\n    tensor([[ 0.8237,  0.5781,  0.6879],\n            [ 0.3816,  0.7249,  0.0998]])\n'.format(**factory_common_args))
add_docstr(torch.rand_like, '\nrand_like(input, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns a tensor with the same size as :attr:`input` that is filled with\nrandom numbers from a uniform distribution on the interval :math:`[0, 1)`.\n``torch.rand_like(input)`` is equivalent to\n``torch.rand(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.\n\nArgs:\n    {input}\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n    {memory_format}\n\n'.format(**factory_like_common_args))
add_docstr(torch.randint, '\nrandint(low=0, high, size, *, generator=None, out=None, \\\n        dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nReturns a tensor filled with random integers generated uniformly\nbetween :attr:`low` (inclusive) and :attr:`high` (exclusive).\n\nThe shape of the tensor is defined by the variable argument :attr:`size`.\n\n.. note:\n    With the global dtype default (``torch.float32``), this function returns\n    a tensor with dtype ``torch.int64``.\n\nArgs:\n    low (int, optional): Lowest integer to be drawn from the distribution. Default: 0.\n    high (int): One above the highest integer to be drawn from the distribution.\n    size (tuple): a tuple defining the shape of the output tensor.\n    {generator}\n    {out}\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n\nExample::\n\n    >>> torch.randint(3, 5, (3,))\n    tensor([4, 3, 4])\n\n\n    >>> torch.randint(10, (2, 2))\n    tensor([[0, 2],\n            [5, 5]])\n\n\n    >>> torch.randint(3, 10, (2, 2))\n    tensor([[4, 5],\n            [6, 7]])\n\n\n'.format(**factory_common_args))
add_docstr(torch.randint_like, '\nrandint_like(input, low=0, high, dtype=None, layout=torch.strided, device=None, requires_grad=False,\nmemory_format=torch.preserve_format) -> Tensor\n\nReturns a tensor with the same shape as Tensor :attr:`input` filled with\nrandom integers generated uniformly between :attr:`low` (inclusive) and\n:attr:`high` (exclusive).\n\n.. note:\n    With the global dtype default (``torch.float32``), this function returns\n    a tensor with dtype ``torch.int64``.\n\nArgs:\n    {input}\n    low (int, optional): Lowest integer to be drawn from the distribution. Default: 0.\n    high (int): One above the highest integer to be drawn from the distribution.\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n    {memory_format}\n\n'.format(**factory_like_common_args))
add_docstr(torch.randn, '\nrandn(*size, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nReturns a tensor filled with random numbers from a normal distribution\nwith mean `0` and variance `1` (also called the standard normal\ndistribution).\n\n.. math::\n    \\text{{out}}_{{i}} \\sim \\mathcal{{N}}(0, 1)\n\nThe shape of the tensor is defined by the variable argument :attr:`size`.\n\nArgs:\n    size (int...): a sequence of integers defining the shape of the output tensor.\n        Can be a variable number of arguments or a collection like a list or tuple.\n    {out}\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n\nExample::\n\n    >>> torch.randn(4)\n    tensor([-2.1436,  0.9966,  2.3426, -0.6366])\n    >>> torch.randn(2, 3)\n    tensor([[ 1.5954,  2.8929, -1.0923],\n            [ 1.1719, -0.4709, -0.1996]])\n'.format(**factory_common_args))
add_docstr(torch.randn_like, '\nrandn_like(input, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns a tensor with the same size as :attr:`input` that is filled with\nrandom numbers from a normal distribution with mean 0 and variance 1.\n``torch.randn_like(input)`` is equivalent to\n``torch.randn(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.\n\nArgs:\n    {input}\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n    {memory_format}\n\n'.format(**factory_like_common_args))
add_docstr(torch.randperm, '\nrandperm(n, out=None, dtype=torch.int64, layout=torch.strided, device=None, requires_grad=False) -> LongTensor\n\nReturns a random permutation of integers from ``0`` to ``n - 1``.\n\nArgs:\n    n (int): the upper bound (exclusive)\n    {out}\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: ``torch.int64``.\n    {layout}\n    {device}\n    {requires_grad}\n\nExample::\n\n    >>> torch.randperm(4)\n    tensor([2, 1, 0, 3])\n'.format(**factory_common_args))
add_docstr(torch.tensor, "\ntensor(data, dtype=None, device=None, requires_grad=False, pin_memory=False) -> Tensor\n\nConstructs a tensor with :attr:`data`.\n\n.. warning::\n\n    :func:`torch.tensor` always copies :attr:`data`. If you have a Tensor\n    ``data`` and want to avoid a copy, use :func:`torch.Tensor.requires_grad_`\n    or :func:`torch.Tensor.detach`.\n    If you have a NumPy ``ndarray`` and want to avoid a copy, use\n    :func:`torch.as_tensor`.\n\n.. warning::\n\n    When data is a tensor `x`, :func:`torch.tensor` reads out 'the data' from whatever it is passed,\n    and constructs a leaf variable. Therefore ``torch.tensor(x)`` is equivalent to ``x.clone().detach()``\n    and ``torch.tensor(x, requires_grad=True)`` is equivalent to ``x.clone().detach().requires_grad_(True)``.\n    The equivalents using ``clone()`` and ``detach()`` are recommended.\n\nArgs:\n    {data}\n    {dtype}\n    {device}\n    {requires_grad}\n    {pin_memory}\n\n\nExample::\n\n    >>> torch.tensor([[0.1, 1.2], [2.2, 3.1], [4.9, 5.2]])\n    tensor([[ 0.1000,  1.2000],\n            [ 2.2000,  3.1000],\n            [ 4.9000,  5.2000]])\n\n    >>> torch.tensor([0, 1])  # Type inference on data\n    tensor([ 0,  1])\n\n    >>> torch.tensor([[0.11111, 0.222222, 0.3333333]],\n                     dtype=torch.float64,\n                     device=torch.device('cuda:0'))  # creates a torch.cuda.DoubleTensor\n    tensor([[ 0.1111,  0.2222,  0.3333]], dtype=torch.float64, device='cuda:0')\n\n    >>> torch.tensor(3.14159)  # Create a scalar (zero-dimensional tensor)\n    tensor(3.1416)\n\n    >>> torch.tensor([])  # Create an empty tensor (of size (0,))\n    tensor([])\n".format(**factory_data_common_args))
add_docstr(torch.range, '\nrange(start=0, end, step=1, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nReturns a 1-D tensor of size :math:`\\left\\lfloor \\frac{\\text{end} - \\text{start}}{\\text{step}} \\right\\rfloor + 1`\nwith values from :attr:`start` to :attr:`end` with step :attr:`step`. Step is\nthe gap between two values in the tensor.\n\n.. math::\n    \\text{out}_{i+1} = \\text{out}_i + \\text{step}.\n' + '\n.. warning::\n    This function is deprecated in favor of :func:`torch.arange`.\n\nArgs:\n    start (float): the starting value for the set of points. Default: ``0``.\n    end (float): the ending value for the set of points\n    step (float): the gap between each pair of adjacent points. Default: ``1``.\n    {out}\n    {dtype} If `dtype` is not given, infer the data type from the other input\n        arguments. If any of `start`, `end`, or `stop` are floating-point, the\n        `dtype` is inferred to be the default dtype, see\n        :meth:`~torch.get_default_dtype`. Otherwise, the `dtype` is inferred to\n        be `torch.int64`.\n    {layout}\n    {device}\n    {requires_grad}\n\nExample::\n\n    >>> torch.range(1, 4)\n    tensor([ 1.,  2.,  3.,  4.])\n    >>> torch.range(1, 4, 0.5)\n    tensor([ 1.0000,  1.5000,  2.0000,  2.5000,  3.0000,  3.5000,  4.0000])\n'.format(**factory_common_args))
add_docstr(torch.arange, '\narange(start=0, end, step=1, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nReturns a 1-D tensor of size :math:`\\left\\lceil \\frac{\\text{end} - \\text{start}}{\\text{step}} \\right\\rceil`\nwith values from the interval ``[start, end)`` taken with common difference\n:attr:`step` beginning from `start`.\n\nNote that non-integer :attr:`step` is subject to floating point rounding errors when\ncomparing against :attr:`end`; to avoid inconsistency, we advise adding a small epsilon to :attr:`end`\nin such cases.\n\n.. math::\n    \\text{out}_{{i+1}} = \\text{out}_{i} + \\text{step}\n' + '\nArgs:\n    start (Number): the starting value for the set of points. Default: ``0``.\n    end (Number): the ending value for the set of points\n    step (Number): the gap between each pair of adjacent points. Default: ``1``.\n    {out}\n    {dtype} If `dtype` is not given, infer the data type from the other input\n        arguments. If any of `start`, `end`, or `stop` are floating-point, the\n        `dtype` is inferred to be the default dtype, see\n        :meth:`~torch.get_default_dtype`. Otherwise, the `dtype` is inferred to\n        be `torch.int64`.\n    {layout}\n    {device}\n    {requires_grad}\n\nExample::\n\n    >>> torch.arange(5)\n    tensor([ 0,  1,  2,  3,  4])\n    >>> torch.arange(1, 4)\n    tensor([ 1,  2,  3])\n    >>> torch.arange(1, 2.5, 0.5)\n    tensor([ 1.0000,  1.5000,  2.0000])\n'.format(**factory_common_args))
add_docstr(torch.remainder, '\nremainder(input, other, out=None) -> Tensor\n\nComputes the element-wise remainder of division.\n\nThe divisor and dividend may contain both for integer and floating point\nnumbers. The remainder has the same sign as the divisor.\n\nWhen :attr:`other` is a tensor, the shapes of :attr:`input` and\n:attr:`other` must be :ref:`broadcastable <broadcasting-semantics>`.\n\nArgs:\n    input (Tensor): the dividend\n    other (Tensor or float): the divisor that may be either a number or a\n                               Tensor of the same shape as the dividend\n    {out}\n\nExample::\n\n    >>> torch.remainder(torch.tensor([-3., -2, -1, 1, 2, 3]), 2)\n    tensor([ 1.,  0.,  1.,  1.,  0.,  1.])\n    >>> torch.remainder(torch.tensor([1., 2, 3, 4, 5]), 1.5)\n    tensor([ 1.0000,  0.5000,  0.0000,  1.0000,  0.5000])\n\n.. seealso::\n\n        :func:`torch.fmod`, which computes the element-wise remainder of\n        division equivalently to the C library function ``fmod()``.\n'.format(**common_args))
add_docstr(torch.renorm, '\nrenorm(input, p, dim, maxnorm, out=None) -> Tensor\n\nReturns a tensor where each sub-tensor of :attr:`input` along dimension\n:attr:`dim` is normalized such that the `p`-norm of the sub-tensor is lower\nthan the value :attr:`maxnorm`\n\n.. note:: If the norm of a row is lower than `maxnorm`, the row is unchanged\n\nArgs:\n    {input}\n    p (float): the power for the norm computation\n    dim (int): the dimension to slice over to get the sub-tensors\n    maxnorm (float): the maximum norm to keep each sub-tensor under\n    {out}\n\nExample::\n\n    >>> x = torch.ones(3, 3)\n    >>> x[1].fill_(2)\n    tensor([ 2.,  2.,  2.])\n    >>> x[2].fill_(3)\n    tensor([ 3.,  3.,  3.])\n    >>> x\n    tensor([[ 1.,  1.,  1.],\n            [ 2.,  2.,  2.],\n            [ 3.,  3.,  3.]])\n    >>> torch.renorm(x, 1, 0, 5)\n    tensor([[ 1.0000,  1.0000,  1.0000],\n            [ 1.6667,  1.6667,  1.6667],\n            [ 1.6667,  1.6667,  1.6667]])\n'.format(**common_args))
add_docstr(torch.reshape, "\nreshape(input, shape) -> Tensor\n\nReturns a tensor with the same data and number of elements as :attr:`input`,\nbut with the specified shape. When possible, the returned tensor will be a view\nof :attr:`input`. Otherwise, it will be a copy. Contiguous inputs and inputs\nwith compatible strides can be reshaped without copying, but you should not\ndepend on the copying vs. viewing behavior.\n\nSee :meth:`torch.Tensor.view` on when it is possible to return a view.\n\nA single dimension may be -1, in which case it's inferred from the remaining\ndimensions and the number of elements in :attr:`input`.\n\nArgs:\n    input (Tensor): the tensor to be reshaped\n    shape (tuple of ints): the new shape\n\nExample::\n\n    >>> a = torch.arange(4.)\n    >>> torch.reshape(a, (2, 2))\n    tensor([[ 0.,  1.],\n            [ 2.,  3.]])\n    >>> b = torch.tensor([[0, 1], [2, 3]])\n    >>> torch.reshape(b, (-1,))\n    tensor([ 0,  1,  2,  3])\n")
add_docstr(torch.result_type, '\nresult_type(tensor1, tensor2) -> dtype\n\nReturns the :class:`torch.dtype` that would result from performing an arithmetic\noperation on the provided input tensors. See type promotion :ref:`documentation <type-promotion-doc>`\nfor more information on the type promotion logic.\n\nArgs:\n    tensor1 (Tensor or Number): an input tensor or number\n    tensor2 (Tensor or Number): an input tensor or number\n\nExample::\n\n    >>> torch.result_type(torch.tensor([1, 2], dtype=torch.int), 1.0)\n    torch.float32\n    >>> torch.result_type(torch.tensor([1, 2], dtype=torch.uint8), torch.tensor(1))\n    torch.uint8\n')
add_docstr(torch.round, '\nround(input, out=None) -> Tensor\n\nReturns a new tensor with each of the elements of :attr:`input` rounded\nto the closest integer.\n\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.9920,  0.6077,  0.9734, -1.0362])\n    >>> torch.round(a)\n    tensor([ 1.,  1.,  1., -1.])\n'.format(**common_args))
add_docstr(torch.rsqrt, '\nrsqrt(input, out=None) -> Tensor\n\nReturns a new tensor with the reciprocal of the square-root of each of\nthe elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\frac{1}{\\sqrt{\\text{input}_{i}}}\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-0.0370,  0.2970,  1.5420, -0.9105])\n    >>> torch.rsqrt(a)\n    tensor([    nan,  1.8351,  0.8053,     nan])\n'.format(**common_args))
add_docstr(torch.set_flush_denormal, '\nset_flush_denormal(mode) -> bool\n\nDisables denormal floating numbers on CPU.\n\nReturns ``True`` if your system supports flushing denormal numbers and it\nsuccessfully configures flush denormal mode.  :meth:`~torch.set_flush_denormal`\nis only supported on x86 architectures supporting SSE3.\n\nArgs:\n    mode (bool): Controls whether to enable flush denormal mode or not\n\nExample::\n\n    >>> torch.set_flush_denormal(True)\n    True\n    >>> torch.tensor([1e-323], dtype=torch.float64)\n    tensor([ 0.], dtype=torch.float64)\n    >>> torch.set_flush_denormal(False)\n    True\n    >>> torch.tensor([1e-323], dtype=torch.float64)\n    tensor(9.88131e-324 *\n           [ 1.0000], dtype=torch.float64)\n')
add_docstr(torch.set_num_threads, '\nset_num_threads(int)\n\nSets the number of threads used for intraop parallelism on CPU.\nWARNING:\nTo ensure that the correct number of threads is used, set_num_threads\nmust be called before running eager, JIT or autograd code.\n')
add_docstr(torch.set_num_interop_threads, '\nset_num_interop_threads(int)\n\nSets the number of threads used for interop parallelism\n(e.g. in JIT interpreter) on CPU.\nWARNING: Can only be called once and before any inter-op parallel work\nis started (e.g. JIT execution).\n')
add_docstr(torch.sigmoid, '\nsigmoid(input, out=None) -> Tensor\n\nReturns a new tensor with the sigmoid of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\frac{1}{1 + e^{-\\text{input}_{i}}}\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.9213,  1.0887, -0.8858, -1.7683])\n    >>> torch.sigmoid(a)\n    tensor([ 0.7153,  0.7481,  0.2920,  0.1458])\n'.format(**common_args))
add_docstr(torch.sign, '\nsign(input, out=None) -> Tensor\n\nReturns a new tensor with the signs of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\operatorname{sgn}(\\text{input}_{i})\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.tensor([0.7, -1.2, 0., 2.3])\n    >>> a\n    tensor([ 0.7000, -1.2000,  0.0000,  2.3000])\n    >>> torch.sign(a)\n    tensor([ 1., -1.,  0.,  1.])\n'.format(**common_args))
add_docstr(torch.sin, '\nsin(input, out=None) -> Tensor\n\nReturns a new tensor with the sine of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\sin(\\text{input}_{i})\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-0.5461,  0.1347, -2.7266, -0.2746])\n    >>> torch.sin(a)\n    tensor([-0.5194,  0.1343, -0.4032, -0.2711])\n'.format(**common_args))
add_docstr(torch.sinh, '\nsinh(input, out=None) -> Tensor\n\nReturns a new tensor with the hyperbolic sine of the elements of\n:attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\sinh(\\text{input}_{i})\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.5380, -0.8632, -0.1265,  0.9399])\n    >>> torch.sinh(a)\n    tensor([ 0.5644, -0.9744, -0.1268,  1.0845])\n'.format(**common_args))
add_docstr(torch.sort, '\nsort(input, dim=-1, descending=False, out=None) -> (Tensor, LongTensor)\n\nSorts the elements of the :attr:`input` tensor along a given dimension\nin ascending order by value.\n\nIf :attr:`dim` is not given, the last dimension of the `input` is chosen.\n\nIf :attr:`descending` is ``True`` then the elements are sorted in descending\norder by value.\n\nA namedtuple of (values, indices) is returned, where the `values` are the\nsorted values and `indices` are the indices of the elements in the original\n`input` tensor.\n\nArgs:\n    {input}\n    dim (int, optional): the dimension to sort along\n    descending (bool, optional): controls the sorting order (ascending or descending)\n    out (tuple, optional): the output tuple of (`Tensor`, `LongTensor`) that can\n        be optionally given to be used as output buffers\n\nExample::\n\n    >>> x = torch.randn(3, 4)\n    >>> sorted, indices = torch.sort(x)\n    >>> sorted\n    tensor([[-0.2162,  0.0608,  0.6719,  2.3332],\n            [-0.5793,  0.0061,  0.6058,  0.9497],\n            [-0.5071,  0.3343,  0.9553,  1.0960]])\n    >>> indices\n    tensor([[ 1,  0,  2,  3],\n            [ 3,  1,  0,  2],\n            [ 0,  3,  1,  2]])\n\n    >>> sorted, indices = torch.sort(x, 0)\n    >>> sorted\n    tensor([[-0.5071, -0.2162,  0.6719, -0.5793],\n            [ 0.0608,  0.0061,  0.9497,  0.3343],\n            [ 0.6058,  0.9553,  1.0960,  2.3332]])\n    >>> indices\n    tensor([[ 2,  0,  0,  1],\n            [ 0,  1,  1,  2],\n            [ 1,  2,  2,  0]])\n'.format(**common_args))
add_docstr(torch.argsort, '\nargsort(input, dim=-1, descending=False) -> LongTensor\n\nReturns the indices that sort a tensor along a given dimension in ascending\norder by value.\n\nThis is the second value returned by :meth:`torch.sort`.  See its documentation\nfor the exact semantics of this method.\n\nArgs:\n    {input}\n    dim (int, optional): the dimension to sort along\n    descending (bool, optional): controls the sorting order (ascending or descending)\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[ 0.0785,  1.5267, -0.8521,  0.4065],\n            [ 0.1598,  0.0788, -0.0745, -1.2700],\n            [ 1.2208,  1.0722, -0.7064,  1.2564],\n            [ 0.0669, -0.2318, -0.8229, -0.9280]])\n\n\n    >>> torch.argsort(a, dim=1)\n    tensor([[2, 0, 3, 1],\n            [3, 2, 1, 0],\n            [2, 1, 0, 3],\n            [3, 2, 1, 0]])\n'.format(**common_args))
add_docstr(torch.sparse_coo_tensor, "\nsparse_coo_tensor(indices, values, size=None, dtype=None, device=None, requires_grad=False) -> Tensor\n\nConstructs a sparse tensors in COO(rdinate) format with non-zero elements at the given :attr:`indices`\nwith the given :attr:`values`. A sparse tensor can be `uncoalesced`, in that case, there are duplicate\ncoordinates in the indices, and the value at that index is the sum of all duplicate value entries:\n`torch.sparse`_.\n\nArgs:\n    indices (array_like): Initial data for the tensor. Can be a list, tuple,\n        NumPy ``ndarray``, scalar, and other types. Will be cast to a :class:`torch.LongTensor`\n        internally. The indices are the coordinates of the non-zero values in the matrix, and thus\n        should be two-dimensional where the first dimension is the number of tensor dimensions and\n        the second dimension is the number of non-zero values.\n    values (array_like): Initial values for the tensor. Can be a list, tuple,\n        NumPy ``ndarray``, scalar, and other types.\n    size (list, tuple, or :class:`torch.Size`, optional): Size of the sparse tensor. If not\n        provided the size will be inferred as the minimum size big enough to hold all non-zero\n        elements.\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if None, infers data type from :attr:`values`.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if None, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    {requires_grad}\n\n\nExample::\n\n    >>> i = torch.tensor([[0, 1, 1],\n                          [2, 0, 2]])\n    >>> v = torch.tensor([3, 4, 5], dtype=torch.float32)\n    >>> torch.sparse_coo_tensor(i, v, [2, 4])\n    tensor(indices=tensor([[0, 1, 1],\n                           [2, 0, 2]]),\n           values=tensor([3., 4., 5.]),\n           size=(2, 4), nnz=3, layout=torch.sparse_coo)\n\n    >>> torch.sparse_coo_tensor(i, v)  # Shape inference\n    tensor(indices=tensor([[0, 1, 1],\n                           [2, 0, 2]]),\n           values=tensor([3., 4., 5.]),\n           size=(2, 3), nnz=3, layout=torch.sparse_coo)\n\n    >>> torch.sparse_coo_tensor(i, v, [2, 4],\n                                dtype=torch.float64,\n                                device=torch.device('cuda:0'))\n    tensor(indices=tensor([[0, 1, 1],\n                           [2, 0, 2]]),\n           values=tensor([3., 4., 5.]),\n           device='cuda:0', size=(2, 4), nnz=3, dtype=torch.float64,\n           layout=torch.sparse_coo)\n\n    # Create an empty sparse tensor with the following invariants:\n    #   1. sparse_dim + dense_dim = len(SparseTensor.shape)\n    #   2. SparseTensor._indices().shape = (sparse_dim, nnz)\n    #   3. SparseTensor._values().shape = (nnz, SparseTensor.shape[sparse_dim:])\n    #\n    # For instance, to create an empty sparse tensor with nnz = 0, dense_dim = 0 and\n    # sparse_dim = 1 (hence indices is a 2D tensor of shape = (1, 0))\n    >>> S = torch.sparse_coo_tensor(torch.empty([1, 0]), [], [1])\n    tensor(indices=tensor([], size=(1, 0)),\n           values=tensor([], size=(0,)),\n           size=(1,), nnz=0, layout=torch.sparse_coo)\n\n    # and to create an empty sparse tensor with nnz = 0, dense_dim = 1 and\n    # sparse_dim = 1\n    >>> S = torch.sparse_coo_tensor(torch.empty([1, 0]), torch.empty([0, 2]), [1, 2])\n    tensor(indices=tensor([], size=(1, 0)),\n           values=tensor([], size=(0, 2)),\n           size=(1, 2), nnz=0, layout=torch.sparse_coo)\n\n.. _torch.sparse: https://pytorch.org/docs/stable/sparse.html\n".format(**factory_common_args))
add_docstr(torch.sqrt, '\nsqrt(input, out=None) -> Tensor\n\nReturns a new tensor with the square-root of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\sqrt{\\text{input}_{i}}\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-2.0755,  1.0226,  0.0831,  0.4806])\n    >>> torch.sqrt(a)\n    tensor([    nan,  1.0112,  0.2883,  0.6933])\n'.format(**common_args))
add_docstr(torch.square, '\nsquare(input, out=None) -> Tensor\n\nReturns a new tensor with the square of the elements of :attr:`input`.\n\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-2.0755,  1.0226,  0.0831,  0.4806])\n    >>> torch.square(a)\n    tensor([ 4.3077,  1.0457,  0.0069,  0.2310])\n'.format(**common_args))
add_docstr(torch.squeeze, '\nsqueeze(input, dim=None, out=None) -> Tensor\n\nReturns a tensor with all the dimensions of :attr:`input` of size `1` removed.\n\nFor example, if `input` is of shape:\n:math:`(A \\times 1 \\times B \\times C \\times 1 \\times D)` then the `out` tensor\nwill be of shape: :math:`(A \\times B \\times C \\times D)`.\n\nWhen :attr:`dim` is given, a squeeze operation is done only in the given\ndimension. If `input` is of shape: :math:`(A \\times 1 \\times B)`,\n``squeeze(input, 0)`` leaves the tensor unchanged, but ``squeeze(input, 1)``\nwill squeeze the tensor to the shape :math:`(A \\times B)`.\n\n.. note:: The returned tensor shares the storage with the input tensor,\n          so changing the contents of one will change the contents of the other.\n\nArgs:\n    {input}\n    dim (int, optional): if given, the input will be squeezed only in\n           this dimension\n    {out}\n\nExample::\n\n    >>> x = torch.zeros(2, 1, 2, 1, 2)\n    >>> x.size()\n    torch.Size([2, 1, 2, 1, 2])\n    >>> y = torch.squeeze(x)\n    >>> y.size()\n    torch.Size([2, 2, 2])\n    >>> y = torch.squeeze(x, 0)\n    >>> y.size()\n    torch.Size([2, 1, 2, 1, 2])\n    >>> y = torch.squeeze(x, 1)\n    >>> y.size()\n    torch.Size([2, 2, 1, 2])\n'.format(**common_args))
add_docstr(torch.std, "\n.. function:: std(input, unbiased=True) -> Tensor\n\nReturns the standard-deviation of all elements in the :attr:`input` tensor.\n\nIf :attr:`unbiased` is ``False``, then the standard-deviation will be calculated\nvia the biased estimator. Otherwise, Bessel's correction will be used.\n\nArgs:\n    {input}\n    unbiased (bool): whether to use the unbiased estimation or not\n\nExample::\n\n    >>> a = torch.randn(1, 3)\n    >>> a\n    tensor([[-0.8166, -1.3802, -0.3560]])\n    >>> torch.std(a)\n    tensor(0.5130)\n\n.. function:: std(input, dim, unbiased=True, keepdim=False, out=None) -> Tensor\n\nReturns the standard-deviation of each row of the :attr:`input` tensor in the\ndimension :attr:`dim`. If :attr:`dim` is a list of dimensions,\nreduce over all of them.\n\n{keepdim_details}\n\nIf :attr:`unbiased` is ``False``, then the standard-deviation will be calculated\nvia the biased estimator. Otherwise, Bessel's correction will be used.\n\nArgs:\n    {input}\n    {dim}\n    unbiased (bool): whether to use the unbiased estimation or not\n    {keepdim}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[ 0.2035,  1.2959,  1.8101, -0.4644],\n            [ 1.5027, -0.3270,  0.5905,  0.6538],\n            [-1.5745,  1.3330, -0.5596, -0.6548],\n            [ 0.1264, -0.5080,  1.6420,  0.1992]])\n    >>> torch.std(a, dim=1)\n    tensor([ 1.0311,  0.7477,  1.2204,  0.9087])\n".format(**multi_dim_common))
add_docstr(torch.std_mean, "\n.. function:: std_mean(input, unbiased=True) -> (Tensor, Tensor)\n\nReturns the standard-deviation and mean of all elements in the :attr:`input` tensor.\n\nIf :attr:`unbiased` is ``False``, then the standard-deviation will be calculated\nvia the biased estimator. Otherwise, Bessel's correction will be used.\n\nArgs:\n    {input}\n    unbiased (bool): whether to use the unbiased estimation or not\n\nExample::\n\n    >>> a = torch.randn(1, 3)\n    >>> a\n    tensor([[0.3364, 0.3591, 0.9462]])\n    >>> torch.std_mean(a)\n    (tensor(0.3457), tensor(0.5472))\n\n.. function:: std_mean(input, dim, unbiased=True, keepdim=False) -> (Tensor, Tensor)\n\nReturns the standard-deviation and mean of each row of the :attr:`input` tensor in the\ndimension :attr:`dim`. If :attr:`dim` is a list of dimensions,\nreduce over all of them.\n\n{keepdim_details}\n\nIf :attr:`unbiased` is ``False``, then the standard-deviation will be calculated\nvia the biased estimator. Otherwise, Bessel's correction will be used.\n\nArgs:\n    {input}\n    {dim}\n    unbiased (bool): whether to use the unbiased estimation or not\n    {keepdim}\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[ 0.5648, -0.5984, -1.2676, -1.4471],\n            [ 0.9267,  1.0612,  1.1050, -0.6014],\n            [ 0.0154,  1.9301,  0.0125, -1.0904],\n            [-1.9711, -0.7748, -1.3840,  0.5067]])\n    >>> torch.std_mean(a, 1)\n    (tensor([0.9110, 0.8197, 1.2552, 1.0608]), tensor([-0.6871,  0.6229,  0.2169, -0.9058]))\n".format(**multi_dim_common))
add_docstr(torch.sum, '\n.. function:: sum(input, dtype=None) -> Tensor\n\nReturns the sum of all elements in the :attr:`input` tensor.\n\nArgs:\n    {input}\n    {dtype}\n\nExample::\n\n    >>> a = torch.randn(1, 3)\n    >>> a\n    tensor([[ 0.1133, -0.9567,  0.2958]])\n    >>> torch.sum(a)\n    tensor(-0.5475)\n\n.. function:: sum(input, dim, keepdim=False, dtype=None) -> Tensor\n\nReturns the sum of each row of the :attr:`input` tensor in the given\ndimension :attr:`dim`. If :attr:`dim` is a list of dimensions,\nreduce over all of them.\n\n{keepdim_details}\n\nArgs:\n    {input}\n    {dim}\n    {keepdim}\n    {dtype}\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[ 0.0569, -0.2475,  0.0737, -0.3429],\n            [-0.2993,  0.9138,  0.9337, -1.6864],\n            [ 0.1132,  0.7892, -0.1003,  0.5688],\n            [ 0.3637, -0.9906, -0.4752, -1.5197]])\n    >>> torch.sum(a, 1)\n    tensor([-0.4598, -0.1381,  1.3708, -2.6217])\n    >>> b = torch.arange(4 * 5 * 6).view(4, 5, 6)\n    >>> torch.sum(b, (2, 1))\n    tensor([  435.,  1335.,  2235.,  3135.])\n'.format(**multi_dim_common))
add_docstr(torch.svd, '\nsvd(input, some=True, compute_uv=True, out=None) -> (Tensor, Tensor, Tensor)\n\nThis function returns a namedtuple ``(U, S, V)`` which is the singular value\ndecomposition of a input real matrix or batches of real matrices :attr:`input` such that\n:math:`input = U \\times diag(S) \\times V^T`.\n\nIf :attr:`some` is ``True`` (default), the method returns the reduced singular value decomposition\ni.e., if the last two dimensions of :attr:`input` are ``m`` and ``n``, then the returned\n`U` and `V` matrices will contain only :math:`min(n, m)` orthonormal columns.\n\nIf :attr:`compute_uv` is ``False``, the returned `U` and `V` matrices will be zero matrices\nof shape :math:`(m \\times m)` and :math:`(n \\times n)` respectively. :attr:`some` will be ignored here.\n\n.. note:: The singular values are returned in descending order. If :attr:`input` is a batch of matrices,\n          then the singular values of each matrix in the batch is returned in descending order.\n\n.. note:: The implementation of SVD on CPU uses the LAPACK routine `?gesdd` (a divide-and-conquer\n          algorithm) instead of `?gesvd` for speed. Analogously, the SVD on GPU uses the MAGMA routine\n          `gesdd` as well.\n\n.. note:: Irrespective of the original strides, the returned matrix `U`\n          will be transposed, i.e. with strides :code:`U.contiguous().transpose(-2, -1).stride()`\n\n.. note:: Extra care needs to be taken when backward through `U` and `V`\n          outputs. Such operation is really only stable when :attr:`input` is\n          full rank with all distinct singular values. Otherwise, ``NaN`` can\n          appear as the gradients are not properly defined. Also, notice that\n          double backward will usually do an additional backward through `U` and\n          `V` even if the original backward is only on `S`.\n\n.. note:: When :attr:`some` = ``False``, the gradients on :code:`U[..., :, min(m, n):]`\n          and :code:`V[..., :, min(m, n):]` will be ignored in backward as those vectors\n          can be arbitrary bases of the subspaces.\n\n.. note:: When :attr:`compute_uv` = ``False``, backward cannot be performed since `U` and `V`\n          from the forward pass is required for the backward operation.\n\nArgs:\n    input (Tensor): the input tensor of size :math:`(*, m, n)` where `*` is zero or more\n                    batch dimensions consisting of :math:`m \\times n` matrices.\n    some (bool, optional): controls the shape of returned `U` and `V`\n    compute_uv (bool, optional): option whether to compute `U` and `V` or not\n    out (tuple, optional): the output tuple of tensors\n\nExample::\n\n    >>> a = torch.randn(5, 3)\n    >>> a\n    tensor([[ 0.2364, -0.7752,  0.6372],\n            [ 1.7201,  0.7394, -0.0504],\n            [-0.3371, -1.0584,  0.5296],\n            [ 0.3550, -0.4022,  1.5569],\n            [ 0.2445, -0.0158,  1.1414]])\n    >>> u, s, v = torch.svd(a)\n    >>> u\n    tensor([[ 0.4027,  0.0287,  0.5434],\n            [-0.1946,  0.8833,  0.3679],\n            [ 0.4296, -0.2890,  0.5261],\n            [ 0.6604,  0.2717, -0.2618],\n            [ 0.4234,  0.2481, -0.4733]])\n    >>> s\n    tensor([2.3289, 2.0315, 0.7806])\n    >>> v\n    tensor([[-0.0199,  0.8766,  0.4809],\n            [-0.5080,  0.4054, -0.7600],\n            [ 0.8611,  0.2594, -0.4373]])\n    >>> torch.dist(a, torch.mm(torch.mm(u, torch.diag(s)), v.t()))\n    tensor(8.6531e-07)\n    >>> a_big = torch.randn(7, 5, 3)\n    >>> u, s, v = torch.svd(a_big)\n    >>> torch.dist(a_big, torch.matmul(torch.matmul(u, torch.diag_embed(s)), v.transpose(-2, -1)))\n    tensor(2.6503e-06)\n')
add_docstr(torch.symeig, "\nsymeig(input, eigenvectors=False, upper=True, out=None) -> (Tensor, Tensor)\n\nThis function returns eigenvalues and eigenvectors\nof a real symmetric matrix :attr:`input` or a batch of real symmetric matrices,\nrepresented by a namedtuple (eigenvalues, eigenvectors).\n\nThis function calculates all eigenvalues (and vectors) of :attr:`input`\nsuch that :math:`\\text{input} = V \\text{diag}(e) V^T`.\n\nThe boolean argument :attr:`eigenvectors` defines computation of\nboth eigenvectors and eigenvalues or eigenvalues only.\n\nIf it is ``False``, only eigenvalues are computed. If it is ``True``,\nboth eigenvalues and eigenvectors are computed.\n\nSince the input matrix :attr:`input` is supposed to be symmetric,\nonly the upper triangular portion is used by default.\n\nIf :attr:`upper` is ``False``, then lower triangular portion is used.\n\n.. note:: The eigenvalues are returned in ascending order. If :attr:`input` is a batch of matrices,\n          then the eigenvalues of each matrix in the batch is returned in ascending order.\n\n.. note:: Irrespective of the original strides, the returned matrix `V` will\n          be transposed, i.e. with strides `V.contiguous().transpose(-1, -2).stride()`.\n\n.. note:: Extra care needs to be taken when backward through outputs. Such\n          operation is really only stable when all eigenvalues are distinct.\n          Otherwise, ``NaN`` can appear as the gradients are not properly defined.\n\nArgs:\n    input (Tensor): the input tensor of size :math:`(*, n, n)` where `*` is zero or more\n                    batch dimensions consisting of symmetric matrices.\n    eigenvectors(boolean, optional): controls whether eigenvectors have to be computed\n    upper(boolean, optional): controls whether to consider upper-triangular or lower-triangular region\n    out (tuple, optional): the output tuple of (Tensor, Tensor)\n\nReturns:\n    (Tensor, Tensor): A namedtuple (eigenvalues, eigenvectors) containing\n\n        - **eigenvalues** (*Tensor*): Shape :math:`(*, m)`. The eigenvalues in ascending order.\n        - **eigenvectors** (*Tensor*): Shape :math:`(*, m, m)`.\n          If ``eigenvectors=False``, it's an empty tensor.\n          Otherwise, this tensor contains the orthonormal eigenvectors of the ``input``.\n\nExamples::\n\n\n    >>> a = torch.randn(5, 5)\n    >>> a = a + a.t()  # To make a symmetric\n    >>> a\n    tensor([[-5.7827,  4.4559, -0.2344, -1.7123, -1.8330],\n            [ 4.4559,  1.4250, -2.8636, -3.2100, -0.1798],\n            [-0.2344, -2.8636,  1.7112, -5.5785,  7.1988],\n            [-1.7123, -3.2100, -5.5785, -2.6227,  3.1036],\n            [-1.8330, -0.1798,  7.1988,  3.1036, -5.1453]])\n    >>> e, v = torch.symeig(a, eigenvectors=True)\n    >>> e\n    tensor([-13.7012,  -7.7497,  -2.3163,   5.2477,   8.1050])\n    >>> v\n    tensor([[ 0.1643,  0.9034, -0.0291,  0.3508,  0.1817],\n            [-0.2417, -0.3071, -0.5081,  0.6534,  0.4026],\n            [-0.5176,  0.1223, -0.0220,  0.3295, -0.7798],\n            [-0.4850,  0.2695, -0.5773, -0.5840,  0.1337],\n            [ 0.6415, -0.0447, -0.6381, -0.0193, -0.4230]])\n    >>> a_big = torch.randn(5, 2, 2)\n    >>> a_big = a_big + a_big.transpose(-2, -1)  # To make a_big symmetric\n    >>> e, v = a_big.symeig(eigenvectors=True)\n    >>> torch.allclose(torch.matmul(v, torch.matmul(e.diag_embed(), v.transpose(-2, -1))), a_big)\n    True\n")
add_docstr(torch.t, '\nt(input) -> Tensor\n\nExpects :attr:`input` to be <= 2-D tensor and transposes dimensions 0\nand 1.\n\n0-D and 1-D tensors are returned as is. When input is a 2-D tensor this\nis equivalent to ``transpose(input, 0, 1)``.\n\nArgs:\n    {input}\n\nExample::\n\n    >>> x = torch.randn(())\n    >>> x\n    tensor(0.1995)\n    >>> torch.t(x)\n    tensor(0.1995)\n    >>> x = torch.randn(3)\n    >>> x\n    tensor([ 2.4320, -0.4608,  0.7702])\n    >>> torch.t(x)\n    tensor([ 2.4320, -0.4608,  0.7702])\n    >>> x = torch.randn(2, 3)\n    >>> x\n    tensor([[ 0.4875,  0.9158, -0.5872],\n            [ 0.3938, -0.6929,  0.6932]])\n    >>> torch.t(x)\n    tensor([[ 0.4875,  0.3938],\n            [ 0.9158, -0.6929],\n            [-0.5872,  0.6932]])\n'.format(**common_args))
add_docstr(torch.flip, '\nflip(input, dims) -> Tensor\n\nReverse the order of a n-D tensor along given axis in dims.\n\nArgs:\n    {input}\n    dims (a list or tuple): axis to flip on\n\nExample::\n\n    >>> x = torch.arange(8).view(2, 2, 2)\n    >>> x\n    tensor([[[ 0,  1],\n             [ 2,  3]],\n\n            [[ 4,  5],\n             [ 6,  7]]])\n    >>> torch.flip(x, [0, 1])\n    tensor([[[ 6,  7],\n             [ 4,  5]],\n\n            [[ 2,  3],\n             [ 0,  1]]])\n'.format(**common_args))
add_docstr(torch.roll, '\nroll(input, shifts, dims=None) -> Tensor\n\nRoll the tensor along the given dimension(s). Elements that are shifted beyond the\nlast position are re-introduced at the first position. If a dimension is not\nspecified, the tensor will be flattened before rolling and then restored\nto the original shape.\n\nArgs:\n    {input}\n    shifts (int or tuple of ints): The number of places by which the elements\n        of the tensor are shifted. If shifts is a tuple, dims must be a tuple of\n        the same size, and each dimension will be rolled by the corresponding\n        value\n    dims (int or tuple of ints): Axis along which to roll\n\nExample::\n\n    >>> x = torch.tensor([1, 2, 3, 4, 5, 6, 7, 8]).view(4, 2)\n    >>> x\n    tensor([[1, 2],\n            [3, 4],\n            [5, 6],\n            [7, 8]])\n    >>> torch.roll(x, 1, 0)\n    tensor([[7, 8],\n            [1, 2],\n            [3, 4],\n            [5, 6]])\n    >>> torch.roll(x, -1, 0)\n    tensor([[3, 4],\n            [5, 6],\n            [7, 8],\n            [1, 2]])\n    >>> torch.roll(x, shifts=(2, 1), dims=(0, 1))\n    tensor([[6, 5],\n            [8, 7],\n            [2, 1],\n            [4, 3]])\n'.format(**common_args))
add_docstr(torch.rot90, '\nrot90(input, k, dims) -> Tensor\n\nRotate a n-D tensor by 90 degrees in the plane specified by dims axis.\nRotation direction is from the first towards the second axis if k > 0, and from the second towards the first for k < 0.\n\nArgs:\n    {input}\n    k (int): number of times to rotate\n    dims (a list or tuple): axis to rotate\n\nExample::\n\n    >>> x = torch.arange(4).view(2, 2)\n    >>> x\n    tensor([[0, 1],\n            [2, 3]])\n    >>> torch.rot90(x, 1, [0, 1])\n    tensor([[1, 3],\n            [0, 2]])\n\n    >>> x = torch.arange(8).view(2, 2, 2)\n    >>> x\n    tensor([[[0, 1],\n             [2, 3]],\n\n            [[4, 5],\n             [6, 7]]])\n    >>> torch.rot90(x, 1, [1, 2])\n    tensor([[[1, 3],\n             [0, 2]],\n\n            [[5, 7],\n             [4, 6]]])\n'.format(**common_args))
add_docstr(torch.take, '\ntake(input, index) -> Tensor\n\nReturns a new tensor with the elements of :attr:`input` at the given indices.\nThe input tensor is treated as if it were viewed as a 1-D tensor. The result\ntakes the same shape as the indices.\n\nArgs:\n    {input}\n    indices (LongTensor): the indices into tensor\n\nExample::\n\n    >>> src = torch.tensor([[4, 3, 5],\n                            [6, 7, 8]])\n    >>> torch.take(src, torch.tensor([0, 2, 5]))\n    tensor([ 4,  5,  8])\n'.format(**common_args))
add_docstr(torch.tan, '\ntan(input, out=None) -> Tensor\n\nReturns a new tensor with the tangent of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\tan(\\text{input}_{i})\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-1.2027, -1.7687,  0.4412, -1.3856])\n    >>> torch.tan(a)\n    tensor([-2.5930,  4.9859,  0.4722, -5.3366])\n'.format(**common_args))
add_docstr(torch.tanh, '\ntanh(input, out=None) -> Tensor\n\nReturns a new tensor with the hyperbolic tangent of the elements\nof :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\tanh(\\text{input}_{i})\n' + '\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.8986, -0.7279,  1.1745,  0.2611])\n    >>> torch.tanh(a)\n    tensor([ 0.7156, -0.6218,  0.8257,  0.2553])\n'.format(**common_args))
add_docstr(torch.topk, '\ntopk(input, k, dim=None, largest=True, sorted=True, out=None) -> (Tensor, LongTensor)\n\nReturns the :attr:`k` largest elements of the given :attr:`input` tensor along\na given dimension.\n\nIf :attr:`dim` is not given, the last dimension of the `input` is chosen.\n\nIf :attr:`largest` is ``False`` then the `k` smallest elements are returned.\n\nA namedtuple of `(values, indices)` is returned, where the `indices` are the indices\nof the elements in the original `input` tensor.\n\nThe boolean option :attr:`sorted` if ``True``, will make sure that the returned\n`k` elements are themselves sorted\n\nArgs:\n    {input}\n    k (int): the k in "top-k"\n    dim (int, optional): the dimension to sort along\n    largest (bool, optional): controls whether to return largest or\n           smallest elements\n    sorted (bool, optional): controls whether to return the elements\n           in sorted order\n    out (tuple, optional): the output tuple of (Tensor, LongTensor) that can be\n        optionally given to be used as output buffers\n\nExample::\n\n    >>> x = torch.arange(1., 6.)\n    >>> x\n    tensor([ 1.,  2.,  3.,  4.,  5.])\n    >>> torch.topk(x, 3)\n    torch.return_types.topk(values=tensor([5., 4., 3.]), indices=tensor([4, 3, 2]))\n'.format(**common_args))
add_docstr(torch.trace, '\ntrace(input) -> Tensor\n\nReturns the sum of the elements of the diagonal of the input 2-D matrix.\n\nExample::\n\n    >>> x = torch.arange(1., 10.).view(3, 3)\n    >>> x\n    tensor([[ 1.,  2.,  3.],\n            [ 4.,  5.,  6.],\n            [ 7.,  8.,  9.]])\n    >>> torch.trace(x)\n    tensor(15.)\n')
add_docstr(torch.transpose, "\ntranspose(input, dim0, dim1) -> Tensor\n\nReturns a tensor that is a transposed version of :attr:`input`.\nThe given dimensions :attr:`dim0` and :attr:`dim1` are swapped.\n\nThe resulting :attr:`out` tensor shares it's underlying storage with the\n:attr:`input` tensor, so changing the content of one would change the content\nof the other.\n\nArgs:\n    {input}\n    dim0 (int): the first dimension to be transposed\n    dim1 (int): the second dimension to be transposed\n\nExample::\n\n    >>> x = torch.randn(2, 3)\n    >>> x\n    tensor([[ 1.0028, -0.9893,  0.5809],\n            [-0.1669,  0.7299,  0.4942]])\n    >>> torch.transpose(x, 0, 1)\n    tensor([[ 1.0028, -0.1669],\n            [-0.9893,  0.7299],\n            [ 0.5809,  0.4942]])\n".format(**common_args))
add_docstr(torch.triangular_solve, '\ntriangular_solve(input, A, upper=True, transpose=False, unitriangular=False) -> (Tensor, Tensor)\n\nSolves a system of equations with a triangular coefficient matrix :math:`A`\nand multiple right-hand sides :math:`b`.\n\nIn particular, solves :math:`AX = b` and assumes :math:`A` is upper-triangular\nwith the default keyword arguments.\n\n`torch.triangular_solve(b, A)` can take in 2D inputs `b, A` or inputs that are\nbatches of 2D matrices. If the inputs are batches, then returns\nbatched outputs `X`\n\nArgs:\n    input (Tensor): multiple right-hand sides of size :math:`(*, m, k)` where\n                :math:`*` is zero of more batch dimensions (:math:`b`)\n    A (Tensor): the input triangular coefficient matrix of size :math:`(*, m, m)`\n                where :math:`*` is zero or more batch dimensions\n    upper (bool, optional): whether to solve the upper-triangular system\n        of equations (default) or the lower-triangular system of equations. Default: ``True``.\n    transpose (bool, optional): whether :math:`A` should be transposed before\n        being sent into the solver. Default: ``False``.\n    unitriangular (bool, optional): whether :math:`A` is unit triangular.\n        If True, the diagonal elements of :math:`A` are assumed to be\n        1 and not referenced from :math:`A`. Default: ``False``.\n\nReturns:\n    A namedtuple `(solution, cloned_coefficient)` where `cloned_coefficient`\n    is a clone of :math:`A` and `solution` is the solution :math:`X` to :math:`AX = b`\n    (or whatever variant of the system of equations, depending on the keyword arguments.)\n\nExamples::\n\n    >>> A = torch.randn(2, 2).triu()\n    >>> A\n    tensor([[ 1.1527, -1.0753],\n            [ 0.0000,  0.7986]])\n    >>> b = torch.randn(2, 3)\n    >>> b\n    tensor([[-0.0210,  2.3513, -1.5492],\n            [ 1.5429,  0.7403, -1.0243]])\n    >>> torch.triangular_solve(b, A)\n    torch.return_types.triangular_solve(\n    solution=tensor([[ 1.7841,  2.9046, -2.5405],\n            [ 1.9320,  0.9270, -1.2826]]),\n    cloned_coefficient=tensor([[ 1.1527, -1.0753],\n            [ 0.0000,  0.7986]]))\n')
add_docstr(torch.tril, '\ntril(input, diagonal=0, out=None) -> Tensor\n\nReturns the lower triangular part of the matrix (2-D tensor) or batch of matrices\n:attr:`input`, the other elements of the result tensor :attr:`out` are set to 0.\n\nThe lower triangular part of the matrix is defined as the elements on and\nbelow the diagonal.\n\nThe argument :attr:`diagonal` controls which diagonal to consider. If\n:attr:`diagonal` = 0, all elements on and below the main diagonal are\nretained. A positive value includes just as many diagonals above the main\ndiagonal, and similarly a negative value excludes just as many diagonals below\nthe main diagonal. The main diagonal are the set of indices\n:math:`\\lbrace (i, i) \\rbrace` for :math:`i \\in [0, \\min\\{d_{1}, d_{2}\\} - 1]` where\n:math:`d_{1}, d_{2}` are the dimensions of the matrix.\n' + '\nArgs:\n    {input}\n    diagonal (int, optional): the diagonal to consider\n    {out}\n\nExample::\n\n    >>> a = torch.randn(3, 3)\n    >>> a\n    tensor([[-1.0813, -0.8619,  0.7105],\n            [ 0.0935,  0.1380,  2.2112],\n            [-0.3409, -0.9828,  0.0289]])\n    >>> torch.tril(a)\n    tensor([[-1.0813,  0.0000,  0.0000],\n            [ 0.0935,  0.1380,  0.0000],\n            [-0.3409, -0.9828,  0.0289]])\n\n    >>> b = torch.randn(4, 6)\n    >>> b\n    tensor([[ 1.2219,  0.5653, -0.2521, -0.2345,  1.2544,  0.3461],\n            [ 0.4785, -0.4477,  0.6049,  0.6368,  0.8775,  0.7145],\n            [ 1.1502,  3.2716, -1.1243, -0.5413,  0.3615,  0.6864],\n            [-0.0614, -0.7344, -1.3164, -0.7648, -1.4024,  0.0978]])\n    >>> torch.tril(b, diagonal=1)\n    tensor([[ 1.2219,  0.5653,  0.0000,  0.0000,  0.0000,  0.0000],\n            [ 0.4785, -0.4477,  0.6049,  0.0000,  0.0000,  0.0000],\n            [ 1.1502,  3.2716, -1.1243, -0.5413,  0.0000,  0.0000],\n            [-0.0614, -0.7344, -1.3164, -0.7648, -1.4024,  0.0000]])\n    >>> torch.tril(b, diagonal=-1)\n    tensor([[ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n            [ 0.4785,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n            [ 1.1502,  3.2716,  0.0000,  0.0000,  0.0000,  0.0000],\n            [-0.0614, -0.7344, -1.3164,  0.0000,  0.0000,  0.0000]])\n'.format(**common_args))
add_docstr(torch.tril_indices, "\ntril_indices(row, col, offset=0, dtype=torch.long, device='cpu', layout=torch.strided) -> Tensor\n\nReturns the indices of the lower triangular part of a :attr:`row`-by-\n:attr:`col` matrix in a 2-by-N Tensor, where the first row contains row\ncoordinates of all indices and the second row contains column coordinates.\nIndices are ordered based on rows and then columns.\n\nThe lower triangular part of the matrix is defined as the elements on and\nbelow the diagonal.\n\nThe argument :attr:`offset` controls which diagonal to consider. If\n:attr:`offset` = 0, all elements on and below the main diagonal are\nretained. A positive value includes just as many diagonals above the main\ndiagonal, and similarly a negative value excludes just as many diagonals below\nthe main diagonal. The main diagonal are the set of indices\n:math:`\\lbrace (i, i) \\rbrace` for :math:`i \\in [0, \\min\\{d_{1}, d_{2}\\} - 1]`\nwhere :math:`d_{1}, d_{2}` are the dimensions of the matrix.\n\n.. note::\n    When running on CUDA, ``row * col`` must be less than :math:`2^{59}` to\n    prevent overflow during calculation.\n" + '\nArgs:\n    row (``int``): number of rows in the 2-D matrix.\n    col (``int``): number of columns in the 2-D matrix.\n    offset (``int``): diagonal offset from the main diagonal.\n        Default: if not provided, 0.\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, ``torch.long``.\n    {device}\n    layout (:class:`torch.layout`, optional): currently only support ``torch.strided``.\n\nExample::\n    >>> a = torch.tril_indices(3, 3)\n    >>> a\n    tensor([[0, 1, 1, 2, 2, 2],\n            [0, 0, 1, 0, 1, 2]])\n\n    >>> a = torch.tril_indices(4, 3, -1)\n    >>> a\n    tensor([[1, 2, 2, 3, 3, 3],\n            [0, 0, 1, 0, 1, 2]])\n\n    >>> a = torch.tril_indices(4, 3, 1)\n    >>> a\n    tensor([[0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3],\n            [0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 2]])\n'.format(**factory_common_args))
add_docstr(torch.triu, '\ntriu(input, diagonal=0, out=None) -> Tensor\n\nReturns the upper triangular part of a matrix (2-D tensor) or batch of matrices\n:attr:`input`, the other elements of the result tensor :attr:`out` are set to 0.\n\nThe upper triangular part of the matrix is defined as the elements on and\nabove the diagonal.\n\nThe argument :attr:`diagonal` controls which diagonal to consider. If\n:attr:`diagonal` = 0, all elements on and above the main diagonal are\nretained. A positive value excludes just as many diagonals above the main\ndiagonal, and similarly a negative value includes just as many diagonals below\nthe main diagonal. The main diagonal are the set of indices\n:math:`\\lbrace (i, i) \\rbrace` for :math:`i \\in [0, \\min\\{d_{1}, d_{2}\\} - 1]` where\n:math:`d_{1}, d_{2}` are the dimensions of the matrix.\n' + '\nArgs:\n    {input}\n    diagonal (int, optional): the diagonal to consider\n    {out}\n\nExample::\n\n    >>> a = torch.randn(3, 3)\n    >>> a\n    tensor([[ 0.2309,  0.5207,  2.0049],\n            [ 0.2072, -1.0680,  0.6602],\n            [ 0.3480, -0.5211, -0.4573]])\n    >>> torch.triu(a)\n    tensor([[ 0.2309,  0.5207,  2.0049],\n            [ 0.0000, -1.0680,  0.6602],\n            [ 0.0000,  0.0000, -0.4573]])\n    >>> torch.triu(a, diagonal=1)\n    tensor([[ 0.0000,  0.5207,  2.0049],\n            [ 0.0000,  0.0000,  0.6602],\n            [ 0.0000,  0.0000,  0.0000]])\n    >>> torch.triu(a, diagonal=-1)\n    tensor([[ 0.2309,  0.5207,  2.0049],\n            [ 0.2072, -1.0680,  0.6602],\n            [ 0.0000, -0.5211, -0.4573]])\n\n    >>> b = torch.randn(4, 6)\n    >>> b\n    tensor([[ 0.5876, -0.0794, -1.8373,  0.6654,  0.2604,  1.5235],\n            [-0.2447,  0.9556, -1.2919,  1.3378, -0.1768, -1.0857],\n            [ 0.4333,  0.3146,  0.6576, -1.0432,  0.9348, -0.4410],\n            [-0.9888,  1.0679, -1.3337, -1.6556,  0.4798,  0.2830]])\n    >>> torch.triu(b, diagonal=1)\n    tensor([[ 0.0000, -0.0794, -1.8373,  0.6654,  0.2604,  1.5235],\n            [ 0.0000,  0.0000, -1.2919,  1.3378, -0.1768, -1.0857],\n            [ 0.0000,  0.0000,  0.0000, -1.0432,  0.9348, -0.4410],\n            [ 0.0000,  0.0000,  0.0000,  0.0000,  0.4798,  0.2830]])\n    >>> torch.triu(b, diagonal=-1)\n    tensor([[ 0.5876, -0.0794, -1.8373,  0.6654,  0.2604,  1.5235],\n            [-0.2447,  0.9556, -1.2919,  1.3378, -0.1768, -1.0857],\n            [ 0.0000,  0.3146,  0.6576, -1.0432,  0.9348, -0.4410],\n            [ 0.0000,  0.0000, -1.3337, -1.6556,  0.4798,  0.2830]])\n'.format(**common_args))
add_docstr(torch.triu_indices, "\ntriu_indices(row, col, offset=0, dtype=torch.long, device='cpu', layout=torch.strided) -> Tensor\n\nReturns the indices of the upper triangular part of a :attr:`row` by\n:attr:`col` matrix in a 2-by-N Tensor, where the first row contains row\ncoordinates of all indices and the second row contains column coordinates.\nIndices are ordered based on rows and then columns.\n\nThe upper triangular part of the matrix is defined as the elements on and\nabove the diagonal.\n\nThe argument :attr:`offset` controls which diagonal to consider. If\n:attr:`offset` = 0, all elements on and above the main diagonal are\nretained. A positive value excludes just as many diagonals above the main\ndiagonal, and similarly a negative value includes just as many diagonals below\nthe main diagonal. The main diagonal are the set of indices\n:math:`\\lbrace (i, i) \\rbrace` for :math:`i \\in [0, \\min\\{d_{1}, d_{2}\\} - 1]`\nwhere :math:`d_{1}, d_{2}` are the dimensions of the matrix.\n\n.. note::\n    When running on CUDA, ``row * col`` must be less than :math:`2^{59}` to\n    prevent overflow during calculation.\n" + '\nArgs:\n    row (``int``): number of rows in the 2-D matrix.\n    col (``int``): number of columns in the 2-D matrix.\n    offset (``int``): diagonal offset from the main diagonal.\n        Default: if not provided, 0.\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, ``torch.long``.\n    {device}\n    layout (:class:`torch.layout`, optional): currently only support ``torch.strided``.\n\nExample::\n    >>> a = torch.triu_indices(3, 3)\n    >>> a\n    tensor([[0, 0, 0, 1, 1, 2],\n            [0, 1, 2, 1, 2, 2]])\n\n    >>> a = torch.triu_indices(4, 3, -1)\n    >>> a\n    tensor([[0, 0, 0, 1, 1, 1, 2, 2, 3],\n            [0, 1, 2, 0, 1, 2, 1, 2, 2]])\n\n    >>> a = torch.triu_indices(4, 3, 1)\n    >>> a\n    tensor([[0, 0, 1],\n            [1, 2, 2]])\n'.format(**factory_common_args))
add_docstr(torch.true_divide, '\ntrue_divide(dividend, divisor) -> Tensor\n\nPerforms "true division" that always computes the division\nin floating point. Analogous to division in Python 3 and equivalent to\n:func:`torch.div` except when both inputs have bool or integer scalar types,\nin which case they are cast to the default (floating) scalar type before the division.\n\n.. math::\n    \\text{{out}}_i = \\frac{{\\text{{dividend}}_i}}{{\\text{{divisor}}}}\n\nArgs:\n    dividend (Tensor): the dividend\n    divisor (Tensor or Scalar): the divisor\n\nKeyword args:\n    {out}\n\nExample::\n\n    >>> dividend = torch.tensor([5, 3], dtype=torch.int)\n    >>> divisor = torch.tensor([3, 2], dtype=torch.int)\n    >>> torch.true_divide(dividend, divisor)\n    tensor([1.6667, 1.5000])\n    >>> torch.true_divide(dividend, 2)\n    tensor([2.5000, 1.5000])\n'.format(**common_args))
add_docstr(torch.trunc, '\ntrunc(input, out=None) -> Tensor\n\nReturns a new tensor with the truncated integer values of\nthe elements of :attr:`input`.\n\nArgs:\n    {input}\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 3.4742,  0.5466, -0.8008, -0.9079])\n    >>> torch.trunc(a)\n    tensor([ 3.,  0., -0., -0.])\n'.format(**common_args))
add_docstr(torch.unsqueeze, '\nunsqueeze(input, dim) -> Tensor\n\nReturns a new tensor with a dimension of size one inserted at the\nspecified position.\n\nThe returned tensor shares the same underlying data with this tensor.\n\nA :attr:`dim` value within the range ``[-input.dim() - 1, input.dim() + 1)``\ncan be used. Negative :attr:`dim` will correspond to :meth:`unsqueeze`\napplied at :attr:`dim` = ``dim + input.dim() + 1``.\n\nArgs:\n    {input}\n    dim (int): the index at which to insert the singleton dimension\n\nExample::\n\n    >>> x = torch.tensor([1, 2, 3, 4])\n    >>> torch.unsqueeze(x, 0)\n    tensor([[ 1,  2,  3,  4]])\n    >>> torch.unsqueeze(x, 1)\n    tensor([[ 1],\n            [ 2],\n            [ 3],\n            [ 4]])\n'.format(**common_args))
add_docstr(torch.var, "\n.. function:: var(input, unbiased=True) -> Tensor\n\nReturns the variance of all elements in the :attr:`input` tensor.\n\nIf :attr:`unbiased` is ``False``, then the variance will be calculated via the\nbiased estimator. Otherwise, Bessel's correction will be used.\n\nArgs:\n    {input}\n    unbiased (bool): whether to use the unbiased estimation or not\n\nExample::\n\n    >>> a = torch.randn(1, 3)\n    >>> a\n    tensor([[-0.3425, -1.2636, -0.4864]])\n    >>> torch.var(a)\n    tensor(0.2455)\n\n\n.. function:: var(input, dim, keepdim=False, unbiased=True, out=None) -> Tensor\n\nReturns the variance of each row of the :attr:`input` tensor in the given\ndimension :attr:`dim`.\n\n{keepdim_details}\n\nIf :attr:`unbiased` is ``False``, then the variance will be calculated via the\nbiased estimator. Otherwise, Bessel's correction will be used.\n\nArgs:\n    {input}\n    {dim}\n    {keepdim}\n    unbiased (bool): whether to use the unbiased estimation or not\n    {out}\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[-0.3567,  1.7385, -1.3042,  0.7423],\n            [ 1.3436, -0.1015, -0.9834, -0.8438],\n            [ 0.6056,  0.1089, -0.3112, -1.4085],\n            [-0.7700,  0.6074, -0.1469,  0.7777]])\n    >>> torch.var(a, 1)\n    tensor([ 1.7444,  1.1363,  0.7356,  0.5112])\n".format(**multi_dim_common))
add_docstr(torch.var_mean, "\n.. function:: var_mean(input, unbiased=True) -> (Tensor, Tensor)\n\nReturns the variance and mean of all elements in the :attr:`input` tensor.\n\nIf :attr:`unbiased` is ``False``, then the variance will be calculated via the\nbiased estimator. Otherwise, Bessel's correction will be used.\n\nArgs:\n    {input}\n    unbiased (bool): whether to use the unbiased estimation or not\n\nExample::\n\n    >>> a = torch.randn(1, 3)\n    >>> a\n    tensor([[0.0146, 0.4258, 0.2211]])\n    >>> torch.var_mean(a)\n    (tensor(0.0423), tensor(0.2205))\n\n.. function:: var_mean(input, dim, keepdim=False, unbiased=True) -> (Tensor, Tensor)\n\nReturns the variance and mean of each row of the :attr:`input` tensor in the given\ndimension :attr:`dim`.\n\n{keepdim_details}\n\nIf :attr:`unbiased` is ``False``, then the variance will be calculated via the\nbiased estimator. Otherwise, Bessel's correction will be used.\n\nArgs:\n    {input}\n    {dim}\n    {keepdim}\n    unbiased (bool): whether to use the unbiased estimation or not\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[-1.5650,  2.0415, -0.1024, -0.5790],\n            [ 0.2325, -2.6145, -1.6428, -0.3537],\n            [-0.2159, -1.1069,  1.2882, -1.3265],\n            [-0.6706, -1.5893,  0.6827,  1.6727]])\n    >>> torch.var_mean(a, 1)\n    (tensor([2.3174, 1.6403, 1.4092, 2.0791]), tensor([-0.0512, -1.0946, -0.3403,  0.0239]))\n".format(**multi_dim_common))
add_docstr(torch.zeros, '\nzeros(*size, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nReturns a tensor filled with the scalar value `0`, with the shape defined\nby the variable argument :attr:`size`.\n\nArgs:\n    size (int...): a sequence of integers defining the shape of the output tensor.\n        Can be a variable number of arguments or a collection like a list or tuple.\n    {out}\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n\nExample::\n\n    >>> torch.zeros(2, 3)\n    tensor([[ 0.,  0.,  0.],\n            [ 0.,  0.,  0.]])\n\n    >>> torch.zeros(5)\n    tensor([ 0.,  0.,  0.,  0.,  0.])\n'.format(**factory_common_args))
add_docstr(torch.zeros_like, '\nzeros_like(input, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns a tensor filled with the scalar value `0`, with the same size as\n:attr:`input`. ``torch.zeros_like(input)`` is equivalent to\n``torch.zeros(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.\n\n.. warning::\n    As of 0.4, this function does not support an :attr:`out` keyword. As an alternative,\n    the old ``torch.zeros_like(input, out=output)`` is equivalent to\n    ``torch.zeros(input.size(), out=output)``.\n\nArgs:\n    {input}\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n    {memory_format}\n\nExample::\n\n    >>> input = torch.empty(2, 3)\n    >>> torch.zeros_like(input)\n    tensor([[ 0.,  0.,  0.],\n            [ 0.,  0.,  0.]])\n'.format(**factory_like_common_args))
add_docstr(torch.empty, '\nempty(*size, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False, pin_memory=False) -> Tensor\n\nReturns a tensor filled with uninitialized data. The shape of the tensor is\ndefined by the variable argument :attr:`size`.\n\nArgs:\n    size (int...): a sequence of integers defining the shape of the output tensor.\n        Can be a variable number of arguments or a collection like a list or tuple.\n    {out}\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n    {pin_memory}\n    {memory_format}\n\nExample::\n\n    >>> torch.empty(2, 3)\n    tensor(1.00000e-08 *\n           [[ 6.3984,  0.0000,  0.0000],\n            [ 0.0000,  0.0000,  0.0000]])\n\n'.format(**factory_common_args))
add_docstr(torch.empty_like, '\nempty_like(input, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns an uninitialized tensor with the same size as :attr:`input`.\n``torch.empty_like(input)`` is equivalent to\n``torch.empty(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.\n\nArgs:\n    {input}\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n    {memory_format}\n\nExample::\n\n    >>> torch.empty((2,3), dtype=torch.int64)\n    tensor([[ 9.4064e+13,  2.8000e+01,  9.3493e+13],\n            [ 7.5751e+18,  7.1428e+18,  7.5955e+18]])\n'.format(**factory_like_common_args))
add_docstr(torch.empty_strided, '\nempty_strided(size, stride, dtype=None, layout=None, device=None, requires_grad=False, pin_memory=False) -> Tensor\n\nReturns a tensor filled with uninitialized data. The shape and strides of the tensor is\ndefined by the variable argument :attr:`size` and :attr:`stride` respectively.\n``torch.empty_strided(size, stride)`` is equivalent to\n``torch.empty(size).as_strided(size, stride)``.\n\n.. warning::\n    More than one element of the created tensor may refer to a single memory\n    location. As a result, in-place operations (especially ones that are\n    vectorized) may result in incorrect behavior. If you need to write to\n    the tensors, please clone them first.\n\nArgs:\n    size (tuple of ints): the shape of the output tensor\n    stride (tuple of ints): the strides of the output tensor\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n    {pin_memory}\n\nExample::\n\n    >>> a = torch.empty_strided((2, 3), (1, 2))\n    >>> a\n    tensor([[8.9683e-44, 4.4842e-44, 5.1239e+07],\n            [0.0000e+00, 0.0000e+00, 3.0705e-41]])\n    >>> a.stride()\n    (1, 2)\n    >>> a.size()\n    torch.Size([2, 3])\n'.format(**factory_common_args))
add_docstr(torch.full, '\nfull(size, fill_value, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nReturns a tensor of size :attr:`size` filled with :attr:`fill_value`.\n\n.. warning::\n    In PyTorch 1.5 a bool or integral :attr:`fill_value` will produce a warning if\n    :attr:`dtype` or :attr:`out` are not set.\n    In a future PyTorch release, when :attr:`dtype` and :attr:`out` are not set\n    a bool :attr:`fill_value` will return a tensor of torch.bool dtype,\n    and an integral :attr:`fill_value` will return a tensor of torch.long dtype.\n\nArgs:\n    size (int...): a list, tuple, or :class:`torch.Size` of integers defining the\n        shape of the output tensor.\n    fill_value: the number to fill the output tensor with.\n    {out}\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n\nExample::\n\n    >>> torch.full((2, 3), 3.141592)\n    tensor([[ 3.1416,  3.1416,  3.1416],\n            [ 3.1416,  3.1416,  3.1416]])\n\n'.format(**factory_common_args))
add_docstr(torch.full_like, '\nfull_like(input, fill_value, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False,\nmemory_format=torch.preserve_format) -> Tensor\n\nReturns a tensor with the same size as :attr:`input` filled with :attr:`fill_value`.\n``torch.full_like(input, fill_value)`` is equivalent to\n``torch.full(input.size(), fill_value, dtype=input.dtype, layout=input.layout, device=input.device)``.\n\nArgs:\n    {input}\n    fill_value: the number to fill the output tensor with.\n    {dtype}\n    {layout}\n    {device}\n    {requires_grad}\n    {memory_format}\n'.format(**factory_like_common_args))
add_docstr(torch.det, "\ndet(input) -> Tensor\n\nCalculates determinant of a square matrix or batches of square matrices.\n\n.. note::\n    Backward through :meth:`det` internally uses SVD results when :attr:`input` is\n    not invertible. In this case, double backward through :meth:`det` will be\n    unstable in when :attr:`input` doesn't have distinct singular values. See\n    :meth:`~torch.svd` for details.\n\nArguments:\n    input (Tensor): the input tensor of size ``(*, n, n)`` where ``*`` is zero or more\n                batch dimensions.\n\nExample::\n\n    >>> A = torch.randn(3, 3)\n    >>> torch.det(A)\n    tensor(3.7641)\n\n    >>> A = torch.randn(3, 2, 2)\n    >>> A\n    tensor([[[ 0.9254, -0.6213],\n             [-0.5787,  1.6843]],\n\n            [[ 0.3242, -0.9665],\n             [ 0.4539, -0.0887]],\n\n            [[ 1.1336, -0.4025],\n             [-0.7089,  0.9032]]])\n    >>> A.det()\n    tensor([1.1990, 0.4099, 0.7386])\n")
add_docstr(torch.where, '\n.. function:: where(condition, x, y) -> Tensor\n\nReturn a tensor of elements selected from either :attr:`x` or :attr:`y`, depending on :attr:`condition`.\n\nThe operation is defined as:\n\n.. math::\n    \\text{out}_i = \\begin{cases}\n        \\text{x}_i & \\text{if } \\text{condition}_i \\\\\n        \\text{y}_i & \\text{otherwise} \\\\\n    \\end{cases}\n\n.. note::\n    The tensors :attr:`condition`, :attr:`x`, :attr:`y` must be :ref:`broadcastable <broadcasting-semantics>`.\n\nArguments:\n    condition (BoolTensor): When True (nonzero), yield x, otherwise yield y\n    x (Tensor): values selected at indices where :attr:`condition` is ``True``\n    y (Tensor): values selected at indices where :attr:`condition` is ``False``\n\nReturns:\n    Tensor: A tensor of shape equal to the broadcasted shape of :attr:`condition`, :attr:`x`, :attr:`y`\n\nExample::\n\n    >>> x = torch.randn(3, 2)\n    >>> y = torch.ones(3, 2)\n    >>> x\n    tensor([[-0.4620,  0.3139],\n            [ 0.3898, -0.7197],\n            [ 0.0478, -0.1657]])\n    >>> torch.where(x > 0, x, y)\n    tensor([[ 1.0000,  0.3139],\n            [ 0.3898,  1.0000],\n            [ 0.0478,  1.0000]])\n\n.. function:: where(condition) -> tuple of LongTensor\n\n``torch.where(condition)`` is identical to\n``torch.nonzero(condition, as_tuple=True)``.\n\n.. note::\n    See also :func:`torch.nonzero`.\n')
add_docstr(torch.logdet, "\nlogdet(input) -> Tensor\n\nCalculates log determinant of a square matrix or batches of square matrices.\n\n.. note::\n    Result is ``-inf`` if :attr:`input` has zero log determinant, and is ``nan`` if\n    :attr:`input` has negative determinant.\n\n.. note::\n    Backward through :meth:`logdet` internally uses SVD results when :attr:`input`\n    is not invertible. In this case, double backward through :meth:`logdet` will\n    be unstable in when :attr:`input` doesn't have distinct singular values. See\n    :meth:`~torch.svd` for details.\n\nArguments:\n    input (Tensor): the input tensor of size ``(*, n, n)`` where ``*`` is zero or more\n                batch dimensions.\n\nExample::\n\n    >>> A = torch.randn(3, 3)\n    >>> torch.det(A)\n    tensor(0.2611)\n    >>> torch.logdet(A)\n    tensor(-1.3430)\n    >>> A\n    tensor([[[ 0.9254, -0.6213],\n             [-0.5787,  1.6843]],\n\n            [[ 0.3242, -0.9665],\n             [ 0.4539, -0.0887]],\n\n            [[ 1.1336, -0.4025],\n             [-0.7089,  0.9032]]])\n    >>> A.det()\n    tensor([1.1990, 0.4099, 0.7386])\n    >>> A.det().log()\n    tensor([ 0.1815, -0.8917, -0.3031])\n")
add_docstr(torch.slogdet, "\nslogdet(input) -> (Tensor, Tensor)\n\nCalculates the sign and log absolute value of the determinant(s) of a square matrix or batches of square matrices.\n\n.. note::\n    If ``input`` has zero determinant, this returns ``(0, -inf)``.\n\n.. note::\n    Backward through :meth:`slogdet` internally uses SVD results when :attr:`input`\n    is not invertible. In this case, double backward through :meth:`slogdet`\n    will be unstable in when :attr:`input` doesn't have distinct singular values.\n    See :meth:`~torch.svd` for details.\n\nArguments:\n    input (Tensor): the input tensor of size ``(*, n, n)`` where ``*`` is zero or more\n                batch dimensions.\n\nReturns:\n    A namedtuple (sign, logabsdet) containing the sign of the determinant, and the log\n    value of the absolute determinant.\n\nExample::\n\n    >>> A = torch.randn(3, 3)\n    >>> A\n    tensor([[ 0.0032, -0.2239, -1.1219],\n            [-0.6690,  0.1161,  0.4053],\n            [-1.6218, -0.9273, -0.0082]])\n    >>> torch.det(A)\n    tensor(-0.7576)\n    >>> torch.logdet(A)\n    tensor(nan)\n    >>> torch.slogdet(A)\n    torch.return_types.slogdet(sign=tensor(-1.), logabsdet=tensor(-0.2776))\n")
add_docstr(torch.pinverse, '\npinverse(input, rcond=1e-15) -> Tensor\n\nCalculates the pseudo-inverse (also known as the Moore-Penrose inverse) of a 2D tensor.\nPlease look at `Moore-Penrose inverse`_ for more details\n\n.. note::\n    This method is implemented using the Singular Value Decomposition.\n\n.. note::\n    The pseudo-inverse is not necessarily a continuous function in the elements of the matrix `[1]`_.\n    Therefore, derivatives are not always existent, and exist for a constant rank only `[2]`_.\n    However, this method is backprop-able due to the implementation by using SVD results, and\n    could be unstable. Double-backward will also be unstable due to the usage of SVD internally.\n    See :meth:`~torch.svd` for more details.\n\nArguments:\n    input (Tensor): The input tensor of size :math:`(*, m, n)` where :math:`*` is zero or more batch dimensions\n    rcond (float): A floating point value to determine the cutoff for small singular values.\n                   Default: 1e-15\n\nReturns:\n    The pseudo-inverse of :attr:`input` of dimensions :math:`(*, n, m)`\n\nExample::\n\n    >>> input = torch.randn(3, 5)\n    >>> input\n    tensor([[ 0.5495,  0.0979, -1.4092, -0.1128,  0.4132],\n            [-1.1143, -0.3662,  0.3042,  1.6374, -0.9294],\n            [-0.3269, -0.5745, -0.0382, -0.5922, -0.6759]])\n    >>> torch.pinverse(input)\n    tensor([[ 0.0600, -0.1933, -0.2090],\n            [-0.0903, -0.0817, -0.4752],\n            [-0.7124, -0.1631, -0.2272],\n            [ 0.1356,  0.3933, -0.5023],\n            [-0.0308, -0.1725, -0.5216]])\n    >>> # Batched pinverse example\n    >>> a = torch.randn(2,6,3)\n    >>> b = torch.pinverse(a)\n    >>> torch.matmul(b, a)\n    tensor([[[ 1.0000e+00,  1.6391e-07, -1.1548e-07],\n            [ 8.3121e-08,  1.0000e+00, -2.7567e-07],\n            [ 3.5390e-08,  1.4901e-08,  1.0000e+00]],\n\n            [[ 1.0000e+00, -8.9407e-08,  2.9802e-08],\n            [-2.2352e-07,  1.0000e+00,  1.1921e-07],\n            [ 0.0000e+00,  8.9407e-08,  1.0000e+00]]])\n\n.. _Moore-Penrose inverse: https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse\n\n.. _[1]: https://epubs.siam.org/doi/10.1137/0117004\n\n.. _[2]: https://www.jstor.org/stable/2156365\n')
add_docstr(torch.fft, '\nfft(input, signal_ndim, normalized=False) -> Tensor\n\nComplex-to-complex Discrete Fourier Transform\n\nThis method computes the complex-to-complex discrete Fourier transform.\nIgnoring the batch dimensions, it computes the following expression:\n\n.. math::\n    X[\\omega_1, \\dots, \\omega_d] =\n        \\sum_{n_1=0}^{N_1-1} \\dots \\sum_{n_d=0}^{N_d-1} x[n_1, \\dots, n_d]\n         e^{-j\\ 2 \\pi \\sum_{i=0}^d \\frac{\\omega_i n_i}{N_i}},\n\nwhere :math:`d` = :attr:`signal_ndim` is number of dimensions for the\nsignal, and :math:`N_i` is the size of signal dimension :math:`i`.\n\nThis method supports 1D, 2D and 3D complex-to-complex transforms, indicated\nby :attr:`signal_ndim`. :attr:`input` must be a tensor with last dimension\nof size 2, representing the real and imaginary components of complex\nnumbers, and should have at least ``signal_ndim + 1`` dimensions with optionally\narbitrary number of leading batch dimensions. If :attr:`normalized` is set to\n``True``, this normalizes the result by dividing it with\n:math:`\\sqrt{\\prod_{i=1}^K N_i}` so that the operator is unitary.\n\nReturns the real and the imaginary parts together as one tensor of the same\nshape of :attr:`input`.\n\nThe inverse of this function is :func:`~torch.ifft`.\n\n.. note::\n    For CUDA tensors, an LRU cache is used for cuFFT plans to speed up\n    repeatedly running FFT methods on tensors of same geometry with same\n    configuration. See :ref:`cufft-plan-cache` for more details on how to\n    monitor and control the cache.\n\n.. warning::\n    For CPU tensors, this method is currently only available with MKL. Use\n    :func:`torch.backends.mkl.is_available` to check if MKL is installed.\n\nArguments:\n    input (Tensor): the input tensor of at least :attr:`signal_ndim` ``+ 1``\n        dimensions\n    signal_ndim (int): the number of dimensions in each signal.\n        :attr:`signal_ndim` can only be 1, 2 or 3\n    normalized (bool, optional): controls whether to return normalized results.\n        Default: ``False``\n\nReturns:\n    Tensor: A tensor containing the complex-to-complex Fourier transform result\n\nExample::\n\n    >>> # unbatched 2D FFT\n    >>> x = torch.randn(4, 3, 2)\n    >>> torch.fft(x, 2)\n    tensor([[[-0.0876,  1.7835],\n             [-2.0399, -2.9754],\n             [ 4.4773, -5.0119]],\n\n            [[-1.5716,  2.7631],\n             [-3.8846,  5.2652],\n             [ 0.2046, -0.7088]],\n\n            [[ 1.9938, -0.5901],\n             [ 6.5637,  6.4556],\n             [ 2.9865,  4.9318]],\n\n            [[ 7.0193,  1.1742],\n             [-1.3717, -2.1084],\n             [ 2.0289,  2.9357]]])\n    >>> # batched 1D FFT\n    >>> torch.fft(x, 1)\n    tensor([[[ 1.8385,  1.2827],\n             [-0.1831,  1.6593],\n             [ 2.4243,  0.5367]],\n\n            [[-0.9176, -1.5543],\n             [-3.9943, -2.9860],\n             [ 1.2838, -2.9420]],\n\n            [[-0.8854, -0.6860],\n             [ 2.4450,  0.0808],\n             [ 1.3076, -0.5768]],\n\n            [[-0.1231,  2.7411],\n             [-0.3075, -1.7295],\n             [-0.5384, -2.0299]]])\n    >>> # arbitrary number of batch dimensions, 2D FFT\n    >>> x = torch.randn(3, 3, 5, 5, 2)\n    >>> y = torch.fft(x, 2)\n    >>> y.shape\n    torch.Size([3, 3, 5, 5, 2])\n\n')
add_docstr(torch.ifft, '\nifft(input, signal_ndim, normalized=False) -> Tensor\n\nComplex-to-complex Inverse Discrete Fourier Transform\n\nThis method computes the complex-to-complex inverse discrete Fourier\ntransform. Ignoring the batch dimensions, it computes the following\nexpression:\n\n.. math::\n    X[\\omega_1, \\dots, \\omega_d] =\n        \\frac{1}{\\prod_{i=1}^d N_i} \\sum_{n_1=0}^{N_1-1} \\dots \\sum_{n_d=0}^{N_d-1} x[n_1, \\dots, n_d]\n         e^{\\ j\\ 2 \\pi \\sum_{i=0}^d \\frac{\\omega_i n_i}{N_i}},\n\nwhere :math:`d` = :attr:`signal_ndim` is number of dimensions for the\nsignal, and :math:`N_i` is the size of signal dimension :math:`i`.\n\nThe argument specifications are almost identical with :func:`~torch.fft`.\nHowever, if :attr:`normalized` is set to ``True``, this instead returns the\nresults multiplied by :math:`\\sqrt{\\prod_{i=1}^d N_i}`, to become a unitary\noperator. Therefore, to invert a :func:`~torch.fft`, the :attr:`normalized`\nargument should be set identically for :func:`~torch.fft`.\n\nReturns the real and the imaginary parts together as one tensor of the same\nshape of :attr:`input`.\n\nThe inverse of this function is :func:`~torch.fft`.\n\n.. note::\n    For CUDA tensors, an LRU cache is used for cuFFT plans to speed up\n    repeatedly running FFT methods on tensors of same geometry with same\n    configuration. See :ref:`cufft-plan-cache` for more details on how to\n    monitor and control the cache.\n\n.. warning::\n    For CPU tensors, this method is currently only available with MKL. Use\n    :func:`torch.backends.mkl.is_available` to check if MKL is installed.\n\nArguments:\n    input (Tensor): the input tensor of at least :attr:`signal_ndim` ``+ 1``\n        dimensions\n    signal_ndim (int): the number of dimensions in each signal.\n        :attr:`signal_ndim` can only be 1, 2 or 3\n    normalized (bool, optional): controls whether to return normalized results.\n        Default: ``False``\n\nReturns:\n    Tensor: A tensor containing the complex-to-complex inverse Fourier transform result\n\nExample::\n\n    >>> x = torch.randn(3, 3, 2)\n    >>> x\n    tensor([[[ 1.2766,  1.3680],\n             [-0.8337,  2.0251],\n             [ 0.9465, -1.4390]],\n\n            [[-0.1890,  1.6010],\n             [ 1.1034, -1.9230],\n             [-0.9482,  1.0775]],\n\n            [[-0.7708, -0.8176],\n             [-0.1843, -0.2287],\n             [-1.9034, -0.2196]]])\n    >>> y = torch.fft(x, 2)\n    >>> torch.ifft(y, 2)  # recover x\n    tensor([[[ 1.2766,  1.3680],\n             [-0.8337,  2.0251],\n             [ 0.9465, -1.4390]],\n\n            [[-0.1890,  1.6010],\n             [ 1.1034, -1.9230],\n             [-0.9482,  1.0775]],\n\n            [[-0.7708, -0.8176],\n             [-0.1843, -0.2287],\n             [-1.9034, -0.2196]]])\n\n')
add_docstr(torch.rfft, '\nrfft(input, signal_ndim, normalized=False, onesided=True) -> Tensor\n\nReal-to-complex Discrete Fourier Transform\n\nThis method computes the real-to-complex discrete Fourier transform. It is\nmathematically equivalent with :func:`~torch.fft` with differences only in\nformats of the input and output.\n\nThis method supports 1D, 2D and 3D real-to-complex transforms, indicated\nby :attr:`signal_ndim`. :attr:`input` must be a tensor with at least\n``signal_ndim`` dimensions with optionally arbitrary number of leading batch\ndimensions. If :attr:`normalized` is set to ``True``, this normalizes the result\nby dividing it with :math:`\\sqrt{\\prod_{i=1}^K N_i}` so that the operator is\nunitary, where :math:`N_i` is the size of signal dimension :math:`i`.\n\nThe real-to-complex Fourier transform results follow conjugate symmetry:\n\n.. math::\n    X[\\omega_1, \\dots, \\omega_d] = X^*[N_1 - \\omega_1, \\dots, N_d - \\omega_d],\n\nwhere the index arithmetic is computed modulus the size of the corresponding\ndimension, :math:`\\ ^*` is the conjugate operator, and\n:math:`d` = :attr:`signal_ndim`. :attr:`onesided` flag controls whether to avoid\nredundancy in the output results. If set to ``True`` (default), the output will\nnot be full complex result of shape :math:`(*, 2)`, where :math:`*` is the shape\nof :attr:`input`, but instead the last dimension will be halfed as of size\n:math:`\\lfloor \\frac{N_d}{2} \\rfloor + 1`.\n\nThe inverse of this function is :func:`~torch.irfft`.\n\n.. note::\n    For CUDA tensors, an LRU cache is used for cuFFT plans to speed up\n    repeatedly running FFT methods on tensors of same geometry with same\n    configuration. See :ref:`cufft-plan-cache` for more details on how to\n    monitor and control the cache.\n\n.. warning::\n    For CPU tensors, this method is currently only available with MKL. Use\n    :func:`torch.backends.mkl.is_available` to check if MKL is installed.\n\nArguments:\n    input (Tensor): the input tensor of at least :attr:`signal_ndim` dimensions\n    signal_ndim (int): the number of dimensions in each signal.\n        :attr:`signal_ndim` can only be 1, 2 or 3\n    normalized (bool, optional): controls whether to return normalized results.\n        Default: ``False``\n    onesided (bool, optional): controls whether to return half of results to\n        avoid redundancy. Default: ``True``\n\nReturns:\n    Tensor: A tensor containing the real-to-complex Fourier transform result\n\nExample::\n\n    >>> x = torch.randn(5, 5)\n    >>> torch.rfft(x, 2).shape\n    torch.Size([5, 3, 2])\n    >>> torch.rfft(x, 2, onesided=False).shape\n    torch.Size([5, 5, 2])\n\n')
add_docstr(torch.irfft, '\nirfft(input, signal_ndim, normalized=False, onesided=True, signal_sizes=None) -> Tensor\n\nComplex-to-real Inverse Discrete Fourier Transform\n\nThis method computes the complex-to-real inverse discrete Fourier transform.\nIt is mathematically equivalent with :func:`ifft` with differences only in\nformats of the input and output.\n\nThe argument specifications are almost identical with :func:`~torch.ifft`.\nSimilar to :func:`~torch.ifft`, if :attr:`normalized` is set to ``True``,\nthis normalizes the result by multiplying it with\n:math:`\\sqrt{\\prod_{i=1}^K N_i}` so that the operator is unitary, where\n:math:`N_i` is the size of signal dimension :math:`i`.\n\n.. note::\n    Due to the conjugate symmetry, :attr:`input` do not need to contain the full\n    complex frequency values. Roughly half of the values will be sufficient, as\n    is the case when :attr:`input` is given by :func:`~torch.rfft` with\n    ``rfft(signal, onesided=True)``. In such case, set the :attr:`onesided`\n    argument of this method to ``True``. Moreover, the original signal shape\n    information can sometimes be lost, optionally set :attr:`signal_sizes` to be\n    the size of the original signal (without the batch dimensions if in batched\n    mode) to recover it with correct shape.\n\n    Therefore, to invert an :func:`~torch.rfft`, the :attr:`normalized` and\n    :attr:`onesided` arguments should be set identically for :func:`~torch.irfft`,\n    and preferably a :attr:`signal_sizes` is given to avoid size mismatch. See the\n    example below for a case of size mismatch.\n\n    See :func:`~torch.rfft` for details on conjugate symmetry.\n\nThe inverse of this function is :func:`~torch.rfft`.\n\n.. warning::\n    Generally speaking, input to this function should contain values\n    following conjugate symmetry. Note that even if :attr:`onesided` is\n    ``True``, often symmetry on some part is still needed. When this\n    requirement is not satisfied, the behavior of :func:`~torch.irfft` is\n    undefined. Since :func:`torch.autograd.gradcheck` estimates numerical\n    Jacobian with point perturbations, :func:`~torch.irfft` will almost\n    certainly fail the check.\n\n.. note::\n    For CUDA tensors, an LRU cache is used for cuFFT plans to speed up\n    repeatedly running FFT methods on tensors of same geometry with same\n    configuration. See :ref:`cufft-plan-cache` for more details on how to\n    monitor and control the cache.\n\n.. warning::\n    For CPU tensors, this method is currently only available with MKL. Use\n    :func:`torch.backends.mkl.is_available` to check if MKL is installed.\n\nArguments:\n    input (Tensor): the input tensor of at least :attr:`signal_ndim` ``+ 1``\n        dimensions\n    signal_ndim (int): the number of dimensions in each signal.\n        :attr:`signal_ndim` can only be 1, 2 or 3\n    normalized (bool, optional): controls whether to return normalized results.\n        Default: ``False``\n    onesided (bool, optional): controls whether :attr:`input` was halfed to avoid\n        redundancy, e.g., by :func:`rfft`. Default: ``True``\n    signal_sizes (list or :class:`torch.Size`, optional): the size of the original\n        signal (without batch dimension). Default: ``None``\n\nReturns:\n    Tensor: A tensor containing the complex-to-real inverse Fourier transform result\n\nExample::\n\n    >>> x = torch.randn(4, 4)\n    >>> torch.rfft(x, 2, onesided=True).shape\n    torch.Size([4, 3, 2])\n    >>>\n    >>> # notice that with onesided=True, output size does not determine the original signal size\n    >>> x = torch.randn(4, 5)\n\n    >>> torch.rfft(x, 2, onesided=True).shape\n    torch.Size([4, 3, 2])\n    >>>\n    >>> # now we use the original shape to recover x\n    >>> x\n    tensor([[-0.8992,  0.6117, -1.6091, -0.4155, -0.8346],\n            [-2.1596, -0.0853,  0.7232,  0.1941, -0.0789],\n            [-2.0329,  1.1031,  0.6869, -0.5042,  0.9895],\n            [-0.1884,  0.2858, -1.5831,  0.9917, -0.8356]])\n    >>> y = torch.rfft(x, 2, onesided=True)\n    >>> torch.irfft(y, 2, onesided=True, signal_sizes=x.shape)  # recover x\n    tensor([[-0.8992,  0.6117, -1.6091, -0.4155, -0.8346],\n            [-2.1596, -0.0853,  0.7232,  0.1941, -0.0789],\n            [-2.0329,  1.1031,  0.6869, -0.5042,  0.9895],\n            [-0.1884,  0.2858, -1.5831,  0.9917, -0.8356]])\n\n')
add_docstr(torch.hann_window, '\nhann_window(window_length, periodic=True, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n' + '\nHann window function.\n\n.. math::\n    w[n] = \\frac{1}{2}\\ \\left[1 - \\cos \\left( \\frac{2 \\pi n}{N - 1} \\right)\\right] =\n            \\sin^2 \\left( \\frac{\\pi n}{N - 1} \\right),\n\nwhere :math:`N` is the full window size.\n\nThe input :attr:`window_length` is a positive integer controlling the\nreturned window size. :attr:`periodic` flag determines whether the returned\nwindow trims off the last duplicate value from the symmetric window and is\nready to be used as a periodic window with functions like\n:meth:`torch.stft`. Therefore, if :attr:`periodic` is true, the :math:`N` in\nabove formula is in fact :math:`\\text{window\\_length} + 1`. Also, we always have\n``torch.hann_window(L, periodic=True)`` equal to\n``torch.hann_window(L + 1, periodic=False)[:-1])``.\n\n.. note::\n    If :attr:`window_length` :math:`=1`, the returned window contains a single value 1.\n' + '\nArguments:\n    window_length (int): the size of returned window\n    periodic (bool, optional): If True, returns a window to be used as periodic\n        function. If False, return a symmetric window.\n    {dtype} Only floating point types are supported.\n    layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only\n          ``torch.strided`` (dense layout) is supported.\n    {device}\n    {requires_grad}\n\nReturns:\n    Tensor: A 1-D tensor of size :math:`(\\text{{window\\_length}},)` containing the window\n\n'.format(**factory_common_args))
add_docstr(torch.hamming_window, '\nhamming_window(window_length, periodic=True, alpha=0.54, beta=0.46, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n' + '\nHamming window function.\n\n.. math::\n    w[n] = \\alpha - \\beta\\ \\cos \\left( \\frac{2 \\pi n}{N - 1} \\right),\n\nwhere :math:`N` is the full window size.\n\nThe input :attr:`window_length` is a positive integer controlling the\nreturned window size. :attr:`periodic` flag determines whether the returned\nwindow trims off the last duplicate value from the symmetric window and is\nready to be used as a periodic window with functions like\n:meth:`torch.stft`. Therefore, if :attr:`periodic` is true, the :math:`N` in\nabove formula is in fact :math:`\\text{window\\_length} + 1`. Also, we always have\n``torch.hamming_window(L, periodic=True)`` equal to\n``torch.hamming_window(L + 1, periodic=False)[:-1])``.\n\n.. note::\n    If :attr:`window_length` :math:`=1`, the returned window contains a single value 1.\n\n.. note::\n    This is a generalized version of :meth:`torch.hann_window`.\n' + '\nArguments:\n    window_length (int): the size of returned window\n    periodic (bool, optional): If True, returns a window to be used as periodic\n        function. If False, return a symmetric window.\n    alpha (float, optional): The coefficient :math:`\\alpha` in the equation above\n    beta (float, optional): The coefficient :math:`\\beta` in the equation above\n    {dtype} Only floating point types are supported.\n    layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only\n          ``torch.strided`` (dense layout) is supported.\n    {device}\n    {requires_grad}\n\nReturns:\n    Tensor: A 1-D tensor of size :math:`(\\text{{window\\_length}},)` containing the window\n\n'.format(**factory_common_args))
add_docstr(torch.bartlett_window, '\nbartlett_window(window_length, periodic=True, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n' + '\nBartlett window function.\n\n.. math::\n    w[n] = 1 - \\left| \\frac{2n}{N-1} - 1 \\right| = \\begin{cases}\n        \\frac{2n}{N - 1} & \\text{if } 0 \\leq n \\leq \\frac{N - 1}{2} \\\\\n        2 - \\frac{2n}{N - 1} & \\text{if } \\frac{N - 1}{2} < n < N \\\\\n    \\end{cases},\n\nwhere :math:`N` is the full window size.\n\nThe input :attr:`window_length` is a positive integer controlling the\nreturned window size. :attr:`periodic` flag determines whether the returned\nwindow trims off the last duplicate value from the symmetric window and is\nready to be used as a periodic window with functions like\n:meth:`torch.stft`. Therefore, if :attr:`periodic` is true, the :math:`N` in\nabove formula is in fact :math:`\\text{window\\_length} + 1`. Also, we always have\n``torch.bartlett_window(L, periodic=True)`` equal to\n``torch.bartlett_window(L + 1, periodic=False)[:-1])``.\n\n.. note::\n    If :attr:`window_length` :math:`=1`, the returned window contains a single value 1.\n' + '\nArguments:\n    window_length (int): the size of returned window\n    periodic (bool, optional): If True, returns a window to be used as periodic\n        function. If False, return a symmetric window.\n    {dtype} Only floating point types are supported.\n    layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only\n          ``torch.strided`` (dense layout) is supported.\n    {device}\n    {requires_grad}\n\nReturns:\n    Tensor: A 1-D tensor of size :math:`(\\text{{window\\_length}},)` containing the window\n\n'.format(**factory_common_args))
add_docstr(torch.blackman_window, '\nblackman_window(window_length, periodic=True, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n' + '\nBlackman window function.\n\n.. math::\n    w[n] = 0.42 - 0.5 \\cos \\left( \\frac{2 \\pi n}{N - 1} \\right) + 0.08 \\cos \\left( \\frac{4 \\pi n}{N - 1} \\right)\n\nwhere :math:`N` is the full window size.\n\nThe input :attr:`window_length` is a positive integer controlling the\nreturned window size. :attr:`periodic` flag determines whether the returned\nwindow trims off the last duplicate value from the symmetric window and is\nready to be used as a periodic window with functions like\n:meth:`torch.stft`. Therefore, if :attr:`periodic` is true, the :math:`N` in\nabove formula is in fact :math:`\\text{window\\_length} + 1`. Also, we always have\n``torch.blackman_window(L, periodic=True)`` equal to\n``torch.blackman_window(L + 1, periodic=False)[:-1])``.\n\n.. note::\n    If :attr:`window_length` :math:`=1`, the returned window contains a single value 1.\n' + '\nArguments:\n    window_length (int): the size of returned window\n    periodic (bool, optional): If True, returns a window to be used as periodic\n        function. If False, return a symmetric window.\n    {dtype} Only floating point types are supported.\n    layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only\n          ``torch.strided`` (dense layout) is supported.\n    {device}\n    {requires_grad}\n\nReturns:\n    Tensor: A 1-D tensor of size :math:`(\\text{{window\\_length}},)` containing the window\n\n'.format(**factory_common_args))
add_docstr(torch.unbind, '\nunbind(input, dim=0) -> seq\n\nRemoves a tensor dimension.\n\nReturns a tuple of all slices along a given dimension, already without it.\n\nArguments:\n    input (Tensor): the tensor to unbind\n    dim (int): dimension to remove\n\nExample::\n\n    >>> torch.unbind(torch.tensor([[1, 2, 3],\n    >>>                            [4, 5, 6],\n    >>>                            [7, 8, 9]]))\n    (tensor([1, 2, 3]), tensor([4, 5, 6]), tensor([7, 8, 9]))\n')
add_docstr(torch.combinations, "\ncombinations(input, r=2, with_replacement=False) -> seq\n\nCompute combinations of length :math:`r` of the given tensor. The behavior is similar to\npython's `itertools.combinations` when `with_replacement` is set to `False`, and\n`itertools.combinations_with_replacement` when `with_replacement` is set to `True`.\n\nArguments:\n    input (Tensor): 1D vector.\n    r (int, optional): number of elements to combine\n    with_replacement (boolean, optional): whether to allow duplication in combination\n\nReturns:\n    Tensor: A tensor equivalent to converting all the input tensors into lists, do\n    `itertools.combinations` or `itertools.combinations_with_replacement` on these\n    lists, and finally convert the resulting list into tensor.\n\nExample::\n\n    >>> a = [1, 2, 3]\n    >>> list(itertools.combinations(a, r=2))\n    [(1, 2), (1, 3), (2, 3)]\n    >>> list(itertools.combinations(a, r=3))\n    [(1, 2, 3)]\n    >>> list(itertools.combinations_with_replacement(a, r=2))\n    [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]\n    >>> tensor_a = torch.tensor(a)\n    >>> torch.combinations(tensor_a)\n    tensor([[1, 2],\n            [1, 3],\n            [2, 3]])\n    >>> torch.combinations(tensor_a, r=3)\n    tensor([[1, 2, 3]])\n    >>> torch.combinations(tensor_a, with_replacement=True)\n    tensor([[1, 1],\n            [1, 2],\n            [1, 3],\n            [2, 2],\n            [2, 3],\n            [3, 3]])\n")
add_docstr(torch.trapz, '\n.. function:: trapz(y, x, *, dim=-1) -> Tensor\n\nEstimate :math:`\\int y\\,dx` along `dim`, using the trapezoid rule.\n\nArguments:\n    y (Tensor): The values of the function to integrate\n    x (Tensor): The points at which the function `y` is sampled.\n        If `x` is not in ascending order, intervals on which it is decreasing\n        contribute negatively to the estimated integral (i.e., the convention\n        :math:`\\int_a^b f = -\\int_b^a f` is followed).\n    dim (int): The dimension along which to integrate.\n        By default, use the last dimension.\n\nReturns:\n    A Tensor with the same shape as the input, except with `dim` removed.\n    Each element of the returned tensor represents the estimated integral\n    :math:`\\int y\\,dx` along `dim`.\n\nExample::\n\n    >>> y = torch.randn((2, 3))\n    >>> y\n    tensor([[-2.1156,  0.6857, -0.2700],\n            [-1.2145,  0.5540,  2.0431]])\n    >>> x = torch.tensor([[1, 3, 4], [1, 2, 3]])\n    >>> torch.trapz(y, x)\n    tensor([-1.2220,  0.9683])\n\n.. function:: trapz(y, *, dx=1, dim=-1) -> Tensor\n\nAs above, but the sample points are spaced uniformly at a distance of `dx`.\n\nArguments:\n    y (Tensor): The values of the function to integrate\n    dx (float): The distance between points at which `y` is sampled.\n    dim (int): The dimension along which to integrate.\n        By default, use the last dimension.\n\nReturns:\n    A Tensor with the same shape as the input, except with `dim` removed.\n    Each element of the returned tensor represents the estimated integral\n    :math:`\\int y\\,dx` along `dim`.\n')
add_docstr(torch.repeat_interleave, '\n.. function:: repeat_interleave(input, repeats, dim=None) -> Tensor\n\nRepeat elements of a tensor.\n\n.. warning::\n\n    This is different from :meth:`torch.Tensor.repeat` but similar to ``numpy.repeat``.\n\nArgs:\n    {input}\n    repeats (Tensor or int): The number of repetitions for each element.\n        repeats is broadcasted to fit the shape of the given axis.\n    dim (int, optional): The dimension along which to repeat values.\n        By default, use the flattened input array, and return a flat output\n        array.\n\nReturns:\n    Tensor: Repeated tensor which has the same shape as input, except along the\n     given axis.\n\nExample::\n\n    >>> x = torch.tensor([1, 2, 3])\n    >>> x.repeat_interleave(2)\n    tensor([1, 1, 2, 2, 3, 3])\n    >>> y = torch.tensor([[1, 2], [3, 4]])\n    >>> torch.repeat_interleave(y, 2)\n    tensor([1, 1, 2, 2, 3, 3, 4, 4])\n    >>> torch.repeat_interleave(y, 3, dim=1)\n    tensor([[1, 1, 1, 2, 2, 2],\n            [3, 3, 3, 4, 4, 4]])\n    >>> torch.repeat_interleave(y, torch.tensor([1, 2]), dim=0)\n    tensor([[1, 2],\n            [3, 4],\n            [3, 4]])\n\n.. function:: repeat_interleave(repeats) -> Tensor\n\nIf the `repeats` is `tensor([n1, n2, n3, ...])`, then the output will be\n`tensor([0, 0, ..., 1, 1, ..., 2, 2, ..., ...])` where `0` appears `n1` times,\n`1` appears `n2` times, `2` appears `n3` times, etc.\n'.format(**common_args))
add_docstr(torch.quantize_per_tensor, '\nquantize_per_tensor(input, scale, zero_point, dtype) -> Tensor\n\nConverts a float tensor to quantized tensor with given scale and zero point.\n\nArguments:\n    input (Tensor): float tensor to quantize\n    scale (float): scale to apply in quantization formula\n    zero_point (int): offset in integer value that maps to float zero\n    dtype (:class:`torch.dtype`): the desired data type of returned tensor.\n        Has to be one of the quantized dtypes: ``torch.quint8``, ``torch.qint8``, ``torch.qint32``\n\nReturns:\n    Tensor: A newly quantized tensor\n\nExample::\n\n    >>> torch.quantize_per_tensor(torch.tensor([-1.0, 0.0, 1.0, 2.0]), 0.1, 10, torch.quint8)\n    tensor([-1.,  0.,  1.,  2.], size=(4,), dtype=torch.quint8,\n           quantization_scheme=torch.per_tensor_affine, scale=0.1, zero_point=10)\n    >>> torch.quantize_per_tensor(torch.tensor([-1.0, 0.0, 1.0, 2.0]), 0.1, 10, torch.quint8).int_repr()\n    tensor([ 0, 10, 20, 30], dtype=torch.uint8)\n')
add_docstr(torch.quantize_per_channel, '\nquantize_per_channel(input, scales, zero_points, axis, dtype) -> Tensor\n\nConverts a float tensor to per-channel quantized tensor with given scales and zero points.\n\nArguments:\n    input (Tensor): float tensor to quantize\n    scales (Tensor): float 1D tensor of scales to use, size should match ``input.size(axis)``\n    zero_points (int): integer 1D tensor of offset to use, size should match ``input.size(axis)``\n    axis (int): dimension on which apply per-channel quantization\n    dtype (:class:`torch.dtype`): the desired data type of returned tensor.\n        Has to be one of the quantized dtypes: ``torch.quint8``, ``torch.qint8``, ``torch.qint32``\n\nReturns:\n    Tensor: A newly quantized tensor\n\nExample::\n\n    >>> x = torch.tensor([[-1.0, 0.0], [1.0, 2.0]])\n    >>> torch.quantize_per_channel(x, torch.tensor([0.1, 0.01]), torch.tensor([10, 0]), 0, torch.quint8)\n    tensor([[-1.,  0.],\n            [ 1.,  2.]], size=(2, 2), dtype=torch.quint8,\n           quantization_scheme=torch.per_channel_affine,\n           scale=tensor([0.1000, 0.0100], dtype=torch.float64),\n           zero_point=tensor([10,  0]), axis=0)\n    >>> torch.quantize_per_channel(x, torch.tensor([0.1, 0.01]), torch.tensor([10, 0]), 0, torch.quint8).int_repr()\n    tensor([[  0,  10],\n            [100, 200]], dtype=torch.uint8)\n')
add_docstr(torch._C.Generator, "\nGenerator(device='cpu') -> Generator\n\nCreates and returns a generator object which manages the state of the algorithm that\nproduces pseudo random numbers. Used as a keyword argument in many :ref:`inplace-random-sampling`\nfunctions.\n\nArguments:\n    device (:class:`torch.device`, optional): the desired device for the generator.\n\nReturns:\n    Generator: An torch.Generator object.\n\nExample::\n\n    >>> g_cpu = torch.Generator()\n    >>> g_cuda = torch.Generator(device='cuda')\n")
add_docstr(torch._C.Generator.set_state, '\nGenerator.set_state(new_state) -> void\n\nSets the Generator state.\n\nArguments:\n    new_state (torch.ByteTensor): The desired state.\n\nExample::\n\n    >>> g_cpu = torch.Generator()\n    >>> g_cpu_other = torch.Generator()\n    >>> g_cpu.set_state(g_cpu_other.get_state())\n')
add_docstr(torch._C.Generator.get_state, '\nGenerator.get_state() -> Tensor\n\nReturns the Generator state as a ``torch.ByteTensor``.\n\nReturns:\n    Tensor: A ``torch.ByteTensor`` which contains all the necessary bits\n    to restore a Generator to a specific point in time.\n\nExample::\n\n    >>> g_cpu = torch.Generator()\n    >>> g_cpu.get_state()\n')
add_docstr(torch._C.Generator.manual_seed, '\nGenerator.manual_seed(seed) -> Generator\n\nSets the seed for generating random numbers. Returns a `torch.Generator` object.\nIt is recommended to set a large seed, i.e. a number that has a good balance of 0\nand 1 bits. Avoid having many 0 bits in the seed.\n\nArguments:\n    seed (int): The desired seed.\n\nReturns:\n    Generator: An torch.Generator object.\n\nExample::\n\n    >>> g_cpu = torch.Generator()\n    >>> g_cpu.manual_seed(2147483647)\n')
add_docstr(torch._C.Generator.initial_seed, '\nGenerator.initial_seed() -> int\n\nReturns the initial seed for generating random numbers.\n\nExample::\n\n    >>> g_cpu = torch.Generator()\n    >>> g_cpu.initial_seed()\n    2147483647\n')
add_docstr(torch._C.Generator.seed, '\nGenerator.seed() -> int\n\nGets a non-deterministic random number from std::random_device or the current\ntime and uses it to seed a Generator.\n\nExample::\n\n    >>> g_cpu = torch.Generator()\n    >>> g_cpu.seed()\n    1516516984916\n')
add_docstr(torch._C.Generator.device, "\nGenerator.device -> device\n\nGets the current device of the generator.\n\nExample::\n\n    >>> g_cpu = torch.Generator()\n    >>> g_cpu.device\n    device(type='cpu')\n")

